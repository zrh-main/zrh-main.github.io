---
title: 耦合
categories: 其它
date: 2021-12-06 10:31:16
---

## 程序的耦合 
耦合性(Coupling)，也叫耦合度
模块间的耦合度是指**模块之间的依赖关系**，包括控制关系、调用关系、数据传递关系
模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)
在项目中，耦合指的是`对象之间的依赖性`;对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小

软件设计中的一个准则就是**高内聚低耦合**。
## 分类： 
（1）内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 
一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 
（2）公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 
量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 
（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传 
递该全局变量的信息，则称之为外部耦合。 
（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 
行适当的动作，这种耦合被称为控制耦合。 
（5）标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间 
存在一个标记耦合。 
（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形 
式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另 
一些模块的输入数据。 
（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实 
现的。 
## 总结： 
耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须 
存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 
内聚与耦合 
内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从 
功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件 
结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通 
过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之 
间的相互依存度却要不那么紧密。 
内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他 
模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合.
我们在开发中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。 


第2章 IoC 的概念和作用 
2.1 程序的耦合和解耦[理解] 

请看下面的示例代码： 
/** 
* 账户的业务层实现类 
* @author 德源教育 
* @Company http://www.deyuan.com 
* @Version 1.0 
*/ 
public class AccountServiceImpl implements IAccountService { 
private IAccountDao accountDao = new AccountDaoImpl(); 
} 
上面的代码表示： 
业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译 
将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决

再比如： 
早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采 
用 Class.forName 的方式？ 
public class JdbcDemo1 { 
/** 
* @author 德源教育 
* @Company http://www.doyens.com 
* @Version 1.0 
* @param args 
* @throws Exception 
*/ 
public static void main(String[] args) throws Exception { 
//1.注册驱动 
//DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 
Class.forName("com.mysql.jdbc.Driver"); 
//2.获取连接 
//3.获取预处理 sql 语句对象 
//4.获取结果集 
//5.遍历结果集 
} 
} 
原因就是： 
我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要 
修改源码来重新数据库驱动。这显然不是我们想要的。 



2.1.2 解决程序耦合的思路 
当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： 
Class.forName("com.mysql.jdbc.Driver");//此处只是一个字符串

此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运 
行就不要想了，没有驱动不可能运行成功的）。 
同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 
源码。 
解决这个问题也很简单，使用配置文件配置。

2.1.3 工厂模式解耦 
在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 
方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 
那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 
2.1.4 控制反转-Inversion Of Control 
上一小节解耦的思路有 2 个问题： 
1、存哪去？ 
分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。 
到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。 
所以我们的答案就是 
在应用加载时，创建一个 Map，用于存放三层对象。 
我们把这个 map 称之为容器。 
2、还是没解释什么是工厂？ 
工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 
原来： 
我们在获取对象时，都是采用 new 的方式。是主动的。

现在： 
我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的