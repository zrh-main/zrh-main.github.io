---
title: MySQL 面试题
tags:
  - MySQL
categories:
  MySQL
---

1. 查询中不使用select * 的原因
增加查询分析器解析成本。

增减字段容易与 resultMap 配置不一致。
不需要的列会增加数据传输时间和网络开销
对于无用的大字段，如 varchar、blob、text，会增加 io 操作
失去MySQL优化器“覆盖索引”策略优化的可能性
2. 主键ID生成方案
主键id的生成方案
数据库中主键id的生成方案，主要有三种
数据库自增ID
采用随机数生成不重复的ID
采用jdk提供的uuid

主键id性能排列
自增ID > 雪花算法生成的ID >uuid生成的ID。

实际使用
在实际使用过程中，推荐使用主键自增ID和雪花算法生成的随机ID。

3. 联合索引的优势
 减少开销
 覆盖索引
 效率高
4. 索引是建的越多越好吗
数据量小的表不需要建立索引，建立会增加额外的索引开销

不经常引用的列不要建立索引，因为不常用，即使建立了索引也没有多大意义

经常频繁更新的列不要建立索引，因为肯定会影响插入或更新的效率

数据重复且分布平均的字段，因此他建立索引就没有太大的效果（例如性别字段，只有男女，不适合建立索引）

数据变更需要维护索引，意味着索引越多维护成本越高。

5. 什么情况下考虑分库分表？
不管是IO瓶颈还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载的活跃连接数的阈值。在业务service来看， 就是可用数据库连接少甚至无连接可用，接下来就可以想象了（并发量、吞吐量、崩溃）。
IO瓶颈
第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询会产生大量的IO，降低查询速度->分库和垂直分表
第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 ->分库
CPU瓶颈
第一种：SQl问题：如SQL中包含join,group by, order by，非索引字段条件查询等，增加CPU运算的操作->SQL优化，建立合适的索引，在业务Service层进行业务计算。
第二种：单表数据量太大，查询时扫描的行太多，SQl效率低，增加CPU运算的操作。->水平分表。
能不分就不分
数据量过大，正常运维影响业务访问
随着业务发展，需要对某些字段垂直拆分
数据量快速增长
6. 分库分表带来的问题
事务一致性问题
分布式事务
当更新内容同时存在于不同库找那个，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用“XA协议”和“两阶段提交”处理。分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间，导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。
最终一致性
对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误立刻回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等。
跨节点关联查询join问题
切分之前，系统中很多列表和详情表的数据可以通过join来完成，但是切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。解决的一些方法：
全局表
全局表，也可看做“数据字典表”，就是系统中所有模块都可能依赖的一些表，为了避免库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少修改，所以不必担心一致性的问题。
字段冗余
一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。例如，订单表在保存userId的时候，也将userName也冗余的保存一份，这样查询订单详情顺表就可以查到用户名userName，就不用查询买家user表了。但这种方法适用场景也有限，比较适用依赖字段比较少的情况，而冗余字段的一致性也较难保证。
数据组装
在系统service业务层面，分两次查询，第一次查询的结果集找出关联的数据id，然后根据id发起器二次请求得到关联数据，最后将获得的结果进行字段组装。这是比较常用的方法。
ER分片
关系型数据库中，如果已经确定了表之间的关联关系（如订单表和订单详情表），并且将那些存在关联关系的表记录存放在同一个分片上，那么就能较好地避免跨分片join的问题，可以在一个分片内进行join。在1:1或1：n的情况下，通常按照主表的ID进行主键切分。
跨节点分页、排序、函数问题
跨节点多库进行查询时，会出现limit分页、order by 排序等问题。分页需要按照指定字段进行排序，当排序字段就是分页字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂.需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户 

7. delete和truncate的区别


