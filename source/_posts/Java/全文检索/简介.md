---
title: 简介
tags:
  - 全文检索
categories:
  - Java
---


## 前言
搜索: 
  入口:
    全文检索:

    分类检索:
    最终的检索页面信息:
      品牌:
      平台属性+ 平台属性值:
      库存单元基本数据: skuInfo
      分页:
      过滤:
      排序:
## 全文检索:
  站内搜索(全文检索):`指的是在自己系统的数据库中进行搜索`

## 查询: 
`模糊查询,如果你的数据库中的数据有几万条数据,不会影响查询速度,也不会影响客户体验度`	
员工表中姓张的员工都列出来
  select * from emp where ename like '张%'
  查询出员工表中名字中含有亮 
  select * from emp where ename like '%亮%'
    
如果数据量比较大, 超过百万条的数据, 必须使用站内搜索	
## 站内搜索常见技术
lucene,   solr,  `ElasticSearch`

## ElasticSearch简介
Elasticsearch 是搜索引擎;简称ES
Elasticsearch 是一个免费及开放（free and open）的项目
Elasticsearch 是一个分布式的基于 REST 接口的为云而设计的搜索引擎
Elasticsearch 是由 Elastic 公司创建
## ELK 软件栈
Elastic 公司拥有 Logstash,Kibana,Elasticsearch开源项目
这个三个项目组合在一起，就形成了 ELK 软件栈
他们三个共同形成了一个强大的生态圈
  - `Logstash 负责数据的采集，处理（丰富数据，数据转换等）`
  - `Kibana 负责数据展示，分析，管理，监督及应用`
  - `Elasticsearch 处于最核心的位置，它可以帮我们对数据进行快速地搜索及分析`
## ElasticSearch功能
Elasticsearch是一个基于 Apache Lucene （TM）的开源搜索引擎
无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库
  - 一个完全用 Java 编写的搜索引擎库
  - 截止2005年，是一个顶级的 Apache 开源项目
  - 提供强大的全文搜索功能

## 索引
正排索引
倒排索引(ElasticSearch使用)

## 
Elasticsearch 类似于数据库(MySQL)

## 版本对比
- ES 7.0之前(ES 6.8.1)
  - Index   数据库
  - Type    表
  - Document  行
  - Field   列    数据库字段id,name...等
- ES 7.0之后,不再有Type列
  - Index   数据库
  - Document  行
  - Field   列    数据库字段id,name...等

## CRUD增删改查命令
GET     获取数据
PUT     保存数据(新增数据)
POST    修改数据(没有实际的修改操作,相当于删除数据+新增数据)
DELETE  删除数据
### 复杂查询DSL语句
查询
过滤
分页
排序
高亮
聚合

## 
9200开发端口
9300客户端访问端口

## 客户端工具kibana
在客户端工具kibana的`Dev Tools`页面`左侧进行数据的增删改查操作`;`右侧为执行的结果`

### 语法


**查询**
``` 
# ES 7.0使用
GET /goods/_search

# ES 6.8使用
GET /goods/info/_search

# 模糊查询语法;查询title为荣耀的数据
GET /goods/info/_search
{
  "query":{
    "match":{
      "title":"荣耀"
    }
  }
}

# 过滤查询语法;按照tmId(品牌id)为2的查询
GET /goods/info/_search
{
  "query":{
    "bool":{
      "filter":{
        "term":{
          "tmId":"2"
        }
      }
    }
  }
}

# 分页+过滤语法
##  过滤:按照tmId(品牌id)为2的查询
##  分页:从索引为0开始显示(关键字:from),显示一条数据(关键字:size)
GET /goods/info/_search
{
  "query":{
    "bool":{
      "filter":{
        "term":{
          "tmId":"2"
        }
      }
    }
  },
  "from":0,
  "size":1
}

# 过滤+排序
# 过滤:查询tmId(品牌id)为2的
# 排序:关键字sort；按照id排序，排列顺序order：倒序desc
GET /goods/info/_search
{
  "query":{
    "bool":{
      "filter":{
        "term":{
          "tmId":"2"
        }
      }
    }
  },
  "sort":[
    {
      "id":{
        "order":"desc"
      }
    }
  ]
}

# 模糊查询+高亮
# 查询title为荣耀的数据
# 高亮显示 关键字highlight,会给title的数据添加em标签进行高亮显示
GET /goods/info/_search
{
  "query":{
    "match":{
      "title":"荣耀"
    }
  }，
  "highlight":{
    "fields":{
      "title":{}
    }
  }
}

# 分组查询,按照品牌统计
# 关键字aggs,分组field,按照tmId分组;查询个数size
GET /goods/info/_search
{
  "query":{
    "match":{
      "title":"荣耀"
    }
  },
  "aggs":{
    "tmAg:{
      "terms":{
        "field":"tmId",
        "size":10
      }
    }
  }
}
```

## mapping 映射
类似数据库的ddl语句
ES:Mapping
  规定了索引库index及数据类型

### 根据业务搭建数据结构

关注方向：
1. 分词:
  - 作用: 把查询的内容(分词),当作索引进行使用,可以加快查询使用
  - 技术: IK分词器,把`新华字典`里有的词作为一个词;自定义分词:手动录入,es中有个dic文件,将新增的分词录入到这个文件,es会自动进行加载
  - 例如：商品名称
2. 哪些字段进行过滤
平台属性值
分类Id
3. 哪些字段我们需要通过搜索查询出来。
商品名称,价格,图片等。

### 数据类型
date varchar 等,es的特殊类型:nested
建立数据默认的数据类型是Object
nested类型是一种特殊的对象;允许对象数组彼此独立地进行索引和查询;`嵌套类型`(nested数据类型)，`可以防止数据出现扁平化的错误`

#### 扁平化的错误示例:
```
# 添加数据
PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ 
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}
# 执行查询
GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}
## 预期结果:查询出来为空
## 实际结果:user中的两个对象都会显示
## 说明:不符合预期结果(业务逻辑)
## 解决方案:使用nested嵌套类型
```

建立nested类型
```
# 删除当前索引
DELETE /my_index

# 修改类型为nested类型
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "user": {
          # 这里使用nested类型
          "type": "nested" 
        }
      }
    }
  }
}
# 执行查询
GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}
## 预期结果:查询出来为空
## 实际结果:数据为空

# nested查询语法
GET /my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            {"match": {"user.first": "Alice"}},
            {"match": {"user.last" : "White"}} 
          ]
        }
      }
    }
  }
}
# nested聚合查询语法
GET my_index/_search
{
  "query": {
    "match": {
      "group": "fans"
    }
  },
  "aggs": {
    "fan": {
      "nested": {
        "path": "user"
      }
    }
  }
}
```

## 构建实体与es mapping映射关系
定义:搜索页面中的展示数据
Goods.java实体类
``` Java
package com.doyens.gmall.model.list;
import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;
import java.util.Date;
import java.util.List;
// Index = goods , Type = info
@Data
@Document(indexName = "goods" ,type = "info",shards = 3,replicas = 2)
public class Goods {
    // 商品Id
    @Id
    private Long id;

    @Field(type = FieldType.Keyword, index = false)
    private String defaultImg;

    //  es 中能分词的字段，这个字段数据类型必须是 text！keyword 不分词！
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String title;

    @Field(type = FieldType.Double)
    private Double price;

    @Field(type = FieldType.Date)
    private Date createTime; // 新品

    @Field(type = FieldType.Long)
    private Long tmId;

    @Field(type = FieldType.Keyword)
    private String tmName;

    @Field(type = FieldType.Keyword)
    private String tmLogoUrl;

    @Field(type = FieldType.Long)
    private Long category1Id;

    @Field(type = FieldType.Keyword)
    private String category1Name;

    @Field(type = FieldType.Long)
    private Long category2Id;

    @Field(type = FieldType.Keyword)
    private String category2Name;

    @Field(type = FieldType.Long)
    private Long category3Id;

    @Field(type = FieldType.Keyword)
    private String category3Name;

    //  商品的热度！
    @Field(type = FieldType.Long)
    private Long hotScore = 0L;

    // 平台属性集合对象
    // Nested 支持嵌套查询
    @Field(type = FieldType.Nested)
    private List<SearchAttr> attrs;
}
```
说明:
``` Java
@Document(indexName = "goods" ,type = "info",shards = 3,replicas = 2)
//            库                表             分片         副本
```
shards分片:意思是我们的es库,一台服务器放不下,分几台服务器进行存储
replicas副本:备份;分片的数据可能出现问题,需要备份应对意外情况


## 常用操作
`GET /索引库名/_search` 查看数据库信息
`GET /索引库名/_mapping` 查看数据的映射关系,对应Java实体类中的字段

## 使用
1. 引入依赖
``` xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
    </dependency>
</dependencies>
```
2. 配置application.yml
``` yml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: 192.168.200.128:8858
  zipkin:
    base-url: http://192.168.200.128:9411
    discovery-client-enabled: false
    sender:
      type: web
    sleuth:
      sampler:
        probability: 1
  # ElasticSearch相关配置
  elasticsearch:
    rest:
      uris: http://192.168.200.128:9200
```
3. 编写mapping对应实体类
``` Java
import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;

import java.util.Date;
import java.util.List;

// Index = goods , Type = info
@Data
@Document(indexName = "goods" ,type = "info",shards = 3,replicas = 2)
public class Goods {
    // 商品Id
    @Id
    private Long id;

    @Field(type = FieldType.Keyword, index = false)
    private String defaultImg;

    //  es 中能分词的字段，这个字段数据类型必须是 text！keyword 不分词！
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String title;

    @Field(type = FieldType.Double)
    private Double price;

    @Field(type = FieldType.Date)
    private Date createTime; // 新品

    @Field(type = FieldType.Long)
    private Long tmId;

    @Field(type = FieldType.Keyword)
    private String tmName;

    @Field(type = FieldType.Keyword)
    private String tmLogoUrl;

    @Field(type = FieldType.Long)
    private Long category1Id;

    @Field(type = FieldType.Keyword)
    private String category1Name;

    @Field(type = FieldType.Long)
    private Long category2Id;

    @Field(type = FieldType.Keyword)
    private String category2Name;

    @Field(type = FieldType.Long)
    private Long category3Id;

    @Field(type = FieldType.Keyword)
    private String category3Name;

    //  商品的热度！
    @Field(type = FieldType.Long)
    private Long hotScore = 0L;

    // 平台属性集合对象
    // Nested 支持嵌套查询
    @Field(type = FieldType.Nested)
    private List<SearchAttr> attrs;

}

```
4. 创建索引库
``` Java
import com.doyens.gmall.common.result.Result;
import com.doyens.gmall.model.list.Goods;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/list")
public class ListApiController {

    //引入es客户端
    @Autowired
    private ElasticsearchRestTemplate elasticsearchRestTemplate;

    @GetMapping("inner/createIndex")
    public Result createIndex(){
        //  创建索引库
        elasticsearchRestTemplate.createIndex(Goods.class);
        //  mapping映射
        elasticsearchRestTemplate.putMapping(Goods.class);
        return Result.ok();
    }

}
```
5. 往索引库存入内容
关注方向：
  1. 分词:
    - 作用: 把查询的内容(分词),当作索引进行使用,可以加快查询使用
    - 技术: IK分词器,把`新华字典`里有的词作为一个词;自定义分词:手动录入,es中有个dic文件,将新增的分词录入到这个文件,es会自动进行加载
    - 例如：商品名称
  2. 哪些字段进行过滤
  平台属性值
  分类Id
  3. 哪些字段我们需要通过搜索查询出来。
  商品名称,价格,图片等。
6. 搜索
数据的上架与下架
  上架: 将对应的数据放到es索引库中 
  下架: 从es索引库中删除对应数据
上架和下架, 操作的数据库不是mysql数据库
现在操作的是 es索引库.
实现流程:pojo---> repository  ---> service --->controller  

## ElasticsearchRepository接口
ElasticsearchRepository类似于MybatisPlus的BaseMapper
继承ElasticsearchRepository后,索引库的单表操作不需要手动实现
``` Java
import com.doyens.gmall.model.list.Goods;
import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;
@Repository
//  Goods为对应的实体类,Long为主键类型
public interface GoodsRepository extends ElasticsearchRepository<Goods,Long> {

}
```

## 热度排名:
1. 根据索引库中的 hotScore 进行排名    
2. hotScore应该根据什么进行变化呢?  
  思路:
        查询商品详情, 查询一次商品详情,把字段更新 +1 
        每次有一个人查看都更新一次索引库,频率太高,
        我们把这个字段存到redis一份, 如果 %100==0  我再让更新索引库,		   

## 搜索功能
搜索条件
过滤条件
分页
排序

### 搜索条件
```
GET /goods/info/_search
{
  "query":{
    "match":{
      "title":{
        #query 查询  小米手机的数据
        "query":"小米手机",
        # 默认"operator"的值为"or",查询小米|手机的数据
        # 可以设置"operator"的值为"and",查询包含'小米手机'的数据
        "operator":"or"
      }
    }
  }
}
```
### 过滤条件

```
# 单个过滤条件
GET /goods/info/_search
{
  "query":{
    "bool":{
      # 过滤出category3Id为61的数据
      "filter":{
        "term":{
          "category3Id":"61"
        }
      }
    }
  }
}
# 多个过滤条件
GET /goods/info/_search
{
  "query":{
    "bool":{
      # 过滤出category3Id为61并且tmId为2的数据
      "filter":[
         {"term":{"category3Id":"61"}},
         {"term":{"tmId":"2"}}
      ]
    }
  }
}
```
### nested类型数据
```
GET /goods/info/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": {
              "query": "荣耀手机",
              "operator": "and"
            }
          }
        },
        {
          "nested": {
            "path": "attrs",
            "query": {
              "bool": {
                "must": [
                  {
                    "term": {
                      "attrs.attrId": {
                        "value": "3"
                      }
                    }
                  },
                  {
                    "term": {
                      "attrs.attrValue": {
                        "value": "8GB"
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      ]
    }
  }
}
```
### 合并
```
#分页查询
#过滤条件
#排序 
#高亮显示   
GET /goods/info/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": {
              "query": "小米手机",
              "operator": "or"
            }
          }
        },
        {
          "nested": {
            "path": "attrs",
            "query": {
              "bool": {
                "must": [
                  {
                    "term": {
                      "attrs.attrId": {
                        "value": "3"
                      }
                    }
                  },
                  {
                    "term": {
                      "attrs.attrValue": {
                        "value": "8GB"
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      ]
    }
  },
  "from": 0,
  "size": 2,
  "sort": [
    {
      "hotScore": {
        "order": "desc"
      }
    }
  ],
  "highlight": {
    "pre_tags": ["<span style=color:red>"],
    "fields": {
      "title": {}
    },
    "post_tags": ["</span>"]
  }
}
```

## Java代码实现DSL语句
检索的条件对象: 实体类
检索的请求信息url.参数等,controller

检索类型:
  关键字检索
  索引检索




























