---
title: 简介
tags:
  - SpringMVC
categories:
  - Java
---

## 开发形式
  - 形式一 C/S 架构(客户端/服务器)
  - 形式二 B/S 架构(浏览器服务器)

## 在 B/S 架构中，系统标准的三层架构

### 表现层(web层)
负责接收客户端请求，向客户端响应结果，通常使用http协议请求;接收 http 请求，完成 http 响应
表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示
表现层的设计一般使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）
**MVC 模型**
MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，
是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：
Model（模型）：
数据模型;用于封装数据
View（视图）：
jsp 或者 html;展示数据的;视图是依据模型数据创建的
Controller（控制器）：
应用程序中处理用户交互的部分。处理程序逻辑的。

### 业务层(service 层)
负责业务逻辑处理，和开发项目的需求息息相关
业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（事务应该放到业务层来控制）

### 持久层(dao 层)
负责数据持久化，包括数据层即数据库和数据访问层
持久层就是和数据库交互，对数据库表进行曾删改查的。

## SpringMVC概述
SpringMVC 是基于 Java 实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架
Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块
SpringMVC 为目前最主流的 MVC 框架之一
通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口;同时还支持**RESTful** 编程风格的请求

## 优势
1. 清晰的角色划分：
  - 前端控制器（DispatcherServlet）
  - 请求到处理器映射（HandlerMapping）
  - 处理器适配器（HandlerAdapter）
  - 视图解析器（ViewResolver）
  - 处理器或页面控制器（Controller）
  - 验证器（ Validator）
  - 命令对象（Command 请求参数绑定到的对象就叫命令对象）
  - 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。
2. 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 
3. 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 
4. 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 
5. 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 
6. 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 
7. 功能强大的数据验证、格式化、绑定机制。 
8. 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 
9. 本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。
10. 强大的 JSP 标签库，使 JSP 编写更容易。
………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配
置支持等等。

## 使用
1. 在web.xml的web-app中配置
``` xml
<!-- 配置spring mvc 核心控制器 -->
<servlet>
    <servlet-name>SpringMVCDispatcherServlet</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 -->
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:SpringMVC.xml</param-value>
    </init-param>
    <!-- 配置 servlet 的对象的创建时间点：应用加载时创建。
    取值只能是非 0 正整数，表示启动顺序 -->
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>SpringMVCDispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```
2. 在resources下添加SpringMVC.xml
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/mvc
      http://www.springframework.org/schema/mvc/spring-mvc.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd">
  <!-- 配置创建 spring 容器要扫描的包 -->
  <context:component-scan base-package="cn.dy"></context:component-scan>
  <!-- 配置视图解析器 -->
  <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
      <property name="prefix" value="/WEB-INF/pages/"></property>
      <property name="suffix" value=".jsp"></property>
  </bean>
</beans>
```
3. 编写controller控制器
``` Java
@Controller("helloController")
@RequestMapping("/hello")
public class HelloController {
    @RequestMapping("/world1")
    public String sayHello1() {
        System.out.println("HelloController 的 sayHello1 方法执行了。。。。");
        return "success";
    }
    @RequestMapping("/world2")
    public String sayHello2() {
        System.out.println("HelloController 的 sayHello2 方法执行了。。。。");
        return "success";
    }
}
```
4. 编写jsp发送请求
``` jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
      <title>Title</title>
  </head>
  <body>
    <a href="${pageContext.request.contextPath}/hello/world1">SpringMVC 入门案例</a> <br/>
    <a href="hello/world2">SpringMVC 入门案例</a>
  </body>
</html>
```
5. 使用tomcat运行程序,点击链接,查看tomcat控制台打印的信息

## 执行过程
1. 服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象
2. 浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发
的路径是根据请求 URL，匹配@RequestMapping 中的内容。
3. 匹配到了后，执行对应方法。该方法有一个返回值。
4. 根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。
5. 渲染结果视图，响应浏览器。

## 涉及的组件
### DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由
它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。
### HandlerMapping：处理器映射器
HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的
映射方式，例如：配置文件方式，实现接口方式，注解方式等。
### Handler：处理器
它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由
Handler 对具体的用户请求进行处理。
### HandlAdapter：处理器适配器
通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理
器进行执行。
### View Resolver：视图解析器
View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名
即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。
### View：视图
SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView
等。我们最常用的视图就是 jsp。
一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开
发具体的页面。
### <mvc:annotation-driven>说明
在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。
使 用 <mvc:annotation-driven> 自动加载 RequestMappingHandlerMapping （处理映射器） 和
RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用
<mvc:annotation-driven>替代注解处理器和适配器的配置。
相当于在 xml 中配置了：
<!-- 上面的标签相当于 如下配置-->
``` xml <bean
class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerM
apping"></bean> <bean
class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"></bean>
<!-- HandlerAdapter --> <bean
class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerA
dapter"></bean> <bean
class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"></bean> <bean
class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"></bean>
<!-- HadnlerExceptionResolvers --> <bean
class="org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExcept
ionResolver"></bean> <bean
class="org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolv
er"></bean> <bean
class="org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"
></bean>
```
注意：
一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还
有具体的使用场景）。
明确：
我们只需要编写处理具体业务的控制器以及视图。
