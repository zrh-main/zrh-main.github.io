<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简介</title>
      <link href="/2022/05/12/Java/RabbitMQ/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/05/12/Java/RabbitMQ/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外部启动SpringBoot</title>
      <link href="/2022/05/12/Java/SpringBoot/%E5%A4%96%E9%83%A8%E5%90%AF%E5%8A%A8SpringBoot/"/>
      <url>/2022/05/12/Java/SpringBoot/%E5%A4%96%E9%83%A8%E5%90%AF%E5%8A%A8SpringBoot/</url>
      
        <content type="html"><![CDATA[<ol><li>打成jar包<br><code>maven打成jar包</code></li><li>运行jar包<br><code>java -jar 文件名.jar</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="/2022/05/08/Java/%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2022/05/08/Java/%E7%99%BB%E5%BD%95/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="登录问题"><a href="#登录问题" class="headerlink" title="登录问题"></a>登录问题</h2><p>传统登录,保存在session中;解决方案:session共享,问题:用户量大,内存溢出</p><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>简称sso,sso:在多个应用系统中,用户只需要登录一次就可以访问所有相互信任的应用系统</p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现:"></a>技术实现:</h3><ul><li>CAS(免费开源) + SpringSecurity</li><li>redis + cookie</li></ul><h3 id><a href="#" class="headerlink" title></a></h3><p>分布式，SSO(single sign on)模式<br>  解决 ：<br>用户身份信息独立管理，更好的分布式管理。<br>      可以自己扩展安全策略<br>      跨域不是问题</p><p>缺点：<br>     认证服务器访问压力较大</p><h2 id="单点登录执行流程"><a href="#单点登录执行流程" class="headerlink" title="单点登录执行流程"></a>单点登录执行流程</h2><ol><li>检查cookie中是否有用户认证信息(token)</li></ol><ul><li>存在,允许进入</li><li>不存在,重定向到认证中心</li></ul><ol start="2"><li>认证中心;提示用户登录,注册</li><li>校验用户登录信息</li></ol><ul><li>失败,重定向到认证中心</li><li>成功,使用cookie携带用户信息(token)进入应用系统;</li></ul><ol start="4"><li>用户继续访问应用,校验用户信息(token)是否正确</li></ol><ul><li>不正确,重定向到认证中心</li><li>正确,允许访问</li></ul><h2 id="登录功能实现"><a href="#登录功能实现" class="headerlink" title="登录功能实现:"></a>登录功能实现:</h2><p>查询用户表,  把用户名和密码作为查询条件, 能查询出内容,说明登录成功,失败<br>select * from user_info where login_name = “cctv” and passwd = “96e79218965eb72c92a549dd5a330112”</p><pre><code>UserInfo userinfo = userService.login(loginName,password);if(userinfo!=null)&#123;    登录成功&#125;else&#123;    登录失败&#125; 退出登录:   http://api.gmall.com/api/user/passport/logout      cookie中的信息删掉,删除到redis中的信息   </code></pre><p>你们单点登录怎么实现?<br>   cookie +redis 实现的单点登录<br>   如果cookie禁用了可以使用另外一个客户端的存储,<br>    location<br>    storage.<br>  APP端移动端, 也有存储客户数据的位置, location或者</p><p>  用了cookie,跨域怎么解决的?<br>   设置domain,域名降级</p><h2 id="单点登录与网关整合"><a href="#单点登录与网关整合" class="headerlink" title="单点登录与网关整合:"></a>单点登录与网关整合:</h2><pre><code>判断哪些必须要登录的, 判断URL需要登录   </code></pre><p>  a. trade.html  用户订单页面, 要求他必须登录</p><p>  b.用户访问的时候, 访问内部接口的时候是不允许直接访问api/product/inner/getSkuInfo/{skuId}</p><p>  c.下订单的时候,可能访问到的URL<br>      api/<strong>/order/</strong>  也需要登录</p><pre><code>  以上这些业务处理,就得在网关中进行处理, 过滤器</code></pre><p>面试题:<br>     场景题,如何判断用户两次访问的ip地址都是同一个IP地址?</p><pre><code>    key值就是 token值.        用户第一次访问的时候把ip存入到redis一份    第二次再访问的时候,取出当前访问的客户ip地址,与redis中进行对比,如果一致,    说明是同一个ip地址, </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/05/06/Java/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/05/06/Java/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搜索:<br>  入口:<br>    全文检索:</p><pre><code>分类检索:最终的检索页面信息:  品牌:  平台属性+ 平台属性值:  库存单元基本数据: skuInfo  分页:  过滤:  排序:</code></pre><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索:"></a>全文检索:</h2><p>  站内搜索(全文检索):<code>指的是在自己系统的数据库中进行搜索</code></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询:"></a>查询:</h2><p><code>模糊查询,如果你的数据库中的数据有几万条数据,不会影响查询速度,也不会影响客户体验度</code><br>员工表中姓张的员工都列出来<br>  select * from emp where ename like ‘张%’<br>  查询出员工表中名字中含有亮<br>  select * from emp where ename like ‘%亮%’</p><p>如果数据量比较大, 超过百万条的数据, 必须使用站内搜索    </p><h2 id="站内搜索常见技术"><a href="#站内搜索常见技术" class="headerlink" title="站内搜索常见技术"></a>站内搜索常见技术</h2><p>lucene,   solr,  <code>ElasticSearch</code></p><h2 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h2><p>Elasticsearch 是搜索引擎;简称ES<br>Elasticsearch 是一个免费及开放（free and open）的项目<br>Elasticsearch 是一个分布式的基于 REST 接口的为云而设计的搜索引擎<br>Elasticsearch 是由 Elastic 公司创建</p><h2 id="ELK-软件栈"><a href="#ELK-软件栈" class="headerlink" title="ELK 软件栈"></a>ELK 软件栈</h2><p>Elastic 公司拥有 Logstash,Kibana,Elasticsearch开源项目<br>这个三个项目组合在一起，就形成了 ELK 软件栈<br>他们三个共同形成了一个强大的生态圈</p><ul><li><code>Logstash 负责数据的采集，处理（丰富数据，数据转换等）</code></li><li><code>Kibana 负责数据展示，分析，管理，监督及应用</code></li><li><code>Elasticsearch 处于最核心的位置，它可以帮我们对数据进行快速地搜索及分析</code><h2 id="ElasticSearch功能"><a href="#ElasticSearch功能" class="headerlink" title="ElasticSearch功能"></a>ElasticSearch功能</h2>Elasticsearch是一个基于 Apache Lucene （TM）的开源搜索引擎<br>无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库</li><li>一个完全用 Java 编写的搜索引擎库</li><li>截止2005年，是一个顶级的 Apache 开源项目</li><li>提供强大的全文搜索功能</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>正排索引<br>倒排索引(ElasticSearch使用)</p><h2 id><a href="#" class="headerlink" title></a></h2><p>Elasticsearch 类似于数据库(MySQL)</p><h2 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h2><ul><li>ES 7.0之前(ES 6.8.1)<ul><li>Index   数据库</li><li>Type    表</li><li>Document  行</li><li>Field   列    数据库字段id,name…等</li></ul></li><li>ES 7.0之后,不再有Type列<ul><li>Index   数据库</li><li>Document  行</li><li>Field   列    数据库字段id,name…等</li></ul></li></ul><h2 id="CRUD增删改查命令"><a href="#CRUD增删改查命令" class="headerlink" title="CRUD增删改查命令"></a>CRUD增删改查命令</h2><p>GET     获取数据<br>PUT     保存数据(新增数据)<br>POST    修改数据(没有实际的修改操作,相当于删除数据+新增数据)<br>DELETE  删除数据</p><h3 id="复杂查询DSL语句"><a href="#复杂查询DSL语句" class="headerlink" title="复杂查询DSL语句"></a>复杂查询DSL语句</h3><p>查询<br>过滤<br>分页<br>排序<br>高亮<br>聚合</p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><p>9200开发端口<br>9300客户端访问端口</p><h2 id="客户端工具kibana"><a href="#客户端工具kibana" class="headerlink" title="客户端工具kibana"></a>客户端工具kibana</h2><p>在客户端工具kibana的<code>Dev Tools</code>页面<code>左侧进行数据的增删改查操作</code>;<code>右侧为执行的结果</code></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>查询</strong></p><pre><code># ES 7.0使用GET /goods/_search# ES 6.8使用GET /goods/info/_search# 模糊查询语法;查询title为荣耀的数据GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;title&quot;:&quot;荣耀&quot;    &#125;  &#125;&#125;# 过滤查询语法;按照tmId(品牌id)为2的查询GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;:&#123;      &quot;filter&quot;:&#123;        &quot;term&quot;:&#123;          &quot;tmId&quot;:&quot;2&quot;        &#125;      &#125;    &#125;  &#125;&#125;# 分页+过滤语法##  过滤:按照tmId(品牌id)为2的查询##  分页:从索引为0开始显示(关键字:from),显示一条数据(关键字:size)GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;:&#123;      &quot;filter&quot;:&#123;        &quot;term&quot;:&#123;          &quot;tmId&quot;:&quot;2&quot;        &#125;      &#125;    &#125;  &#125;,  &quot;from&quot;:0,  &quot;size&quot;:1&#125;# 过滤+排序# 过滤:查询tmId(品牌id)为2的# 排序:关键字sort；按照id排序，排列顺序order：倒序descGET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;:&#123;      &quot;filter&quot;:&#123;        &quot;term&quot;:&#123;          &quot;tmId&quot;:&quot;2&quot;        &#125;      &#125;    &#125;  &#125;,  &quot;sort&quot;:[    &#123;      &quot;id&quot;:&#123;        &quot;order&quot;:&quot;desc&quot;      &#125;    &#125;  ]&#125;# 模糊查询+高亮# 查询title为荣耀的数据# 高亮显示 关键字highlight,会给title的数据添加em标签进行高亮显示GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;title&quot;:&quot;荣耀&quot;    &#125;  &#125;，  &quot;highlight&quot;:&#123;    &quot;fields&quot;:&#123;      &quot;title&quot;:&#123;&#125;    &#125;  &#125;&#125;# 分组查询,按照品牌统计# 关键字aggs,分组field,按照tmId分组;查询个数sizeGET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;title&quot;:&quot;荣耀&quot;    &#125;  &#125;,  &quot;aggs&quot;:&#123;    &quot;tmAg:&#123;      &quot;terms&quot;:&#123;        &quot;field&quot;:&quot;tmId&quot;,        &quot;size&quot;:10      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="mapping-映射"><a href="#mapping-映射" class="headerlink" title="mapping 映射"></a>mapping 映射</h2><p>类似数据库的ddl语句<br>ES:Mapping<br>  规定了索引库index及数据类型</p><h3 id="根据业务搭建数据结构"><a href="#根据业务搭建数据结构" class="headerlink" title="根据业务搭建数据结构"></a>根据业务搭建数据结构</h3><p>关注方向：</p><ol><li>分词:</li></ol><ul><li>作用: 把查询的内容(分词),当作索引进行使用,可以加快查询使用</li><li>技术: IK分词器,把<code>新华字典</code>里有的词作为一个词;自定义分词:手动录入,es中有个dic文件,将新增的分词录入到这个文件,es会自动进行加载</li><li>例如：商品名称</li></ul><ol start="2"><li>哪些字段进行过滤<br>平台属性值<br>分类Id</li><li>哪些字段我们需要通过搜索查询出来。<br>商品名称,价格,图片等。</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>date varchar 等,es的特殊类型:nested<br>建立数据默认的数据类型是Object<br>nested类型是一种特殊的对象;允许对象数组彼此独立地进行索引和查询;<code>嵌套类型</code>(nested数据类型)，<code>可以防止数据出现扁平化的错误</code></p><h4 id="扁平化的错误示例"><a href="#扁平化的错误示例" class="headerlink" title="扁平化的错误示例:"></a>扁平化的错误示例:</h4><pre><code># 添加数据PUT my_index/_doc/1&#123;  &quot;group&quot; : &quot;fans&quot;,  &quot;user&quot; : [     &#123;      &quot;first&quot; : &quot;John&quot;,      &quot;last&quot; :  &quot;Smith&quot;    &#125;,    &#123;      &quot;first&quot; : &quot;Alice&quot;,      &quot;last&quot; :  &quot;White&quot;    &#125;  ]&#125;# 执行查询GET my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123; &quot;match&quot;: &#123; &quot;user.first&quot;: &quot;Alice&quot; &#125;&#125;,        &#123; &quot;match&quot;: &#123; &quot;user.last&quot;:  &quot;Smith&quot; &#125;&#125;      ]    &#125;  &#125;&#125;## 预期结果:查询出来为空## 实际结果:user中的两个对象都会显示## 说明:不符合预期结果(业务逻辑)## 解决方案:使用nested嵌套类型</code></pre><p>建立nested类型</p><pre><code># 删除当前索引DELETE /my_index# 修改类型为nested类型PUT my_index&#123;  &quot;mappings&quot;: &#123;    &quot;_doc&quot;: &#123;      &quot;properties&quot;: &#123;        &quot;user&quot;: &#123;          # 这里使用nested类型          &quot;type&quot;: &quot;nested&quot;         &#125;      &#125;    &#125;  &#125;&#125;# 执行查询GET my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123; &quot;match&quot;: &#123; &quot;user.first&quot;: &quot;Alice&quot; &#125;&#125;,        &#123; &quot;match&quot;: &#123; &quot;user.last&quot;:  &quot;Smith&quot; &#125;&#125;      ]    &#125;  &#125;&#125;## 预期结果:查询出来为空## 实际结果:数据为空# nested查询语法GET /my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;nested&quot;: &#123;      &quot;path&quot;: &quot;user&quot;,      &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;          &quot;must&quot;: [            &#123;&quot;match&quot;: &#123;&quot;user.first&quot;: &quot;Alice&quot;&#125;&#125;,            &#123;&quot;match&quot;: &#123;&quot;user.last&quot; : &quot;White&quot;&#125;&#125;           ]        &#125;      &#125;    &#125;  &#125;&#125;# nested聚合查询语法GET my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;group&quot;: &quot;fans&quot;    &#125;  &#125;,  &quot;aggs&quot;: &#123;    &quot;fan&quot;: &#123;      &quot;nested&quot;: &#123;        &quot;path&quot;: &quot;user&quot;      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="构建实体与es-mapping映射关系"><a href="#构建实体与es-mapping映射关系" class="headerlink" title="构建实体与es mapping映射关系"></a>构建实体与es mapping映射关系</h2><p>定义:搜索页面中的展示数据<br>Goods.java实体类</p><pre class=" language-Java"><code class="language-Java">package com.doyens.gmall.model.list;import lombok.Data;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldType;import java.util.Date;import java.util.List;// Index = goods , Type = info@Data@Document(indexName = "goods" ,type = "info",shards = 3,replicas = 2)public class Goods &#123;    // 商品Id    @Id    private Long id;    @Field(type = FieldType.Keyword, index = false)    private String defaultImg;    //  es 中能分词的字段，这个字段数据类型必须是 text！keyword 不分词！    @Field(type = FieldType.Text, analyzer = "ik_max_word")    private String title;    @Field(type = FieldType.Double)    private Double price;    @Field(type = FieldType.Date)    private Date createTime; // 新品    @Field(type = FieldType.Long)    private Long tmId;    @Field(type = FieldType.Keyword)    private String tmName;    @Field(type = FieldType.Keyword)    private String tmLogoUrl;    @Field(type = FieldType.Long)    private Long category1Id;    @Field(type = FieldType.Keyword)    private String category1Name;    @Field(type = FieldType.Long)    private Long category2Id;    @Field(type = FieldType.Keyword)    private String category2Name;    @Field(type = FieldType.Long)    private Long category3Id;    @Field(type = FieldType.Keyword)    private String category3Name;    //  商品的热度！    @Field(type = FieldType.Long)    private Long hotScore = 0L;    // 平台属性集合对象    // Nested 支持嵌套查询    @Field(type = FieldType.Nested)    private List<SearchAttr> attrs;&#125;</code></pre><p>说明:</p><pre class=" language-Java"><code class="language-Java">@Document(indexName = "goods" ,type = "info",shards = 3,replicas = 2)//            库                表             分片         副本</code></pre><p>shards分片:意思是我们的es库,一台服务器放不下,分几台服务器进行存储<br>replicas副本:备份;分片的数据可能出现问题,需要备份应对意外情况</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p><code>GET /索引库名/_search</code> 查看数据库信息<br><code>GET /索引库名/_mapping</code> 查看数据的映射关系,对应Java实体类中的字段</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>引入依赖<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre></li><li>配置application.yml<pre class=" language-yml"><code class="language-yml">spring:cloud: sentinel:   transport:     dashboard: 192.168.200.128:8858zipkin: base-url: http://192.168.200.128:9411 discovery-client-enabled: false sender:   type: web sleuth:   sampler:     probability: 1# ElasticSearch相关配置elasticsearch: rest:   uris: http://192.168.200.128:9200</code></pre></li><li>编写mapping对应实体类<br>``` Java<br>import lombok.Data;<br>import org.springframework.data.annotation.Id;<br>import org.springframework.data.elasticsearch.annotations.Document;<br>import org.springframework.data.elasticsearch.annotations.Field;<br>import org.springframework.data.elasticsearch.annotations.FieldType;</li></ol><p>import java.util.Date;<br>import java.util.List;</p><p>// Index = goods , Type = info<br>@Data<br>@Document(indexName = “goods” ,type = “info”,shards = 3,replicas = 2)<br>public class Goods {<br>    // 商品Id<br>    @Id<br>    private Long id;</p><pre><code>@Field(type = FieldType.Keyword, index = false)private String defaultImg;//  es 中能分词的字段，这个字段数据类型必须是 text！keyword 不分词！@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)private String title;@Field(type = FieldType.Double)private Double price;@Field(type = FieldType.Date)private Date createTime; // 新品@Field(type = FieldType.Long)private Long tmId;@Field(type = FieldType.Keyword)private String tmName;@Field(type = FieldType.Keyword)private String tmLogoUrl;@Field(type = FieldType.Long)private Long category1Id;@Field(type = FieldType.Keyword)private String category1Name;@Field(type = FieldType.Long)private Long category2Id;@Field(type = FieldType.Keyword)private String category2Name;@Field(type = FieldType.Long)private Long category3Id;@Field(type = FieldType.Keyword)private String category3Name;//  商品的热度！@Field(type = FieldType.Long)private Long hotScore = 0L;// 平台属性集合对象// Nested 支持嵌套查询@Field(type = FieldType.Nested)private List&lt;SearchAttr&gt; attrs;</code></pre><p>}</p><pre><code>4. 创建索引库``` Javaimport com.doyens.gmall.common.result.Result;import com.doyens.gmall.model.list.Goods;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/api/list&quot;)public class ListApiController &#123;    //引入es客户端    @Autowired    private ElasticsearchRestTemplate elasticsearchRestTemplate;    @GetMapping(&quot;inner/createIndex&quot;)    public Result createIndex()&#123;        //  创建索引库        elasticsearchRestTemplate.createIndex(Goods.class);        //  mapping映射        elasticsearchRestTemplate.putMapping(Goods.class);        return Result.ok();    &#125;&#125;</code></pre><ol start="5"><li>往索引库存入内容<br>关注方向：</li><li>分词:    - 作用: 把查询的内容(分词),当作索引进行使用,可以加快查询使用    - 技术: IK分词器,把<code>新华字典</code>里有的词作为一个词;自定义分词:手动录入,es中有个dic文件,将新增的分词录入到这个文件,es会自动进行加载    - 例如：商品名称</li><li>哪些字段进行过滤<br>平台属性值<br>分类Id</li><li>哪些字段我们需要通过搜索查询出来。<br>商品名称,价格,图片等。</li><li>搜索<br>数据的上架与下架<br>上架: 将对应的数据放到es索引库中<br>下架: 从es索引库中删除对应数据<br>上架和下架, 操作的数据库不是mysql数据库<br>现在操作的是 es索引库.<br>实现流程:pojo—&gt; repository  —&gt; service —&gt;controller  </li></ol><h2 id="ElasticsearchRepository接口"><a href="#ElasticsearchRepository接口" class="headerlink" title="ElasticsearchRepository接口"></a>ElasticsearchRepository接口</h2><p>ElasticsearchRepository类似于MybatisPlus的BaseMapper<br>继承ElasticsearchRepository后,索引库的单表操作不需要手动实现</p><pre class=" language-Java"><code class="language-Java">import com.doyens.gmall.model.list.Goods;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;@Repository//  Goods为对应的实体类,Long为主键类型public interface GoodsRepository extends ElasticsearchRepository<Goods,Long> &#123;&#125;</code></pre><h2 id="热度排名"><a href="#热度排名" class="headerlink" title="热度排名:"></a>热度排名:</h2><ol><li>根据索引库中的 hotScore 进行排名    </li><li>hotScore应该根据什么进行变化呢?<br>思路:<pre><code> 查询商品详情, 查询一次商品详情,把字段更新 +1  每次有一个人查看都更新一次索引库,频率太高, 我们把这个字段存到redis一份, 如果 %100==0  我再让更新索引库,           </code></pre></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>搜索条件<br>过滤条件<br>分页<br>排序</p><h3 id="搜索条件"><a href="#搜索条件" class="headerlink" title="搜索条件"></a>搜索条件</h3><pre><code>GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;title&quot;:&#123;        #query 查询  小米手机的数据        &quot;query&quot;:&quot;小米手机&quot;,        # 默认&quot;operator&quot;的值为&quot;or&quot;,查询小米|手机的数据        # 可以设置&quot;operator&quot;的值为&quot;and&quot;,查询包含&#39;小米手机&#39;的数据        &quot;operator&quot;:&quot;or&quot;      &#125;    &#125;  &#125;&#125;</code></pre><h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><pre><code># 单个过滤条件GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;:&#123;      # 过滤出category3Id为61的数据      &quot;filter&quot;:&#123;        &quot;term&quot;:&#123;          &quot;category3Id&quot;:&quot;61&quot;        &#125;      &#125;    &#125;  &#125;&#125;# 多个过滤条件GET /goods/info/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;:&#123;      # 过滤出category3Id为61并且tmId为2的数据      &quot;filter&quot;:[         &#123;&quot;term&quot;:&#123;&quot;category3Id&quot;:&quot;61&quot;&#125;&#125;,         &#123;&quot;term&quot;:&#123;&quot;tmId&quot;:&quot;2&quot;&#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><h3 id="nested类型数据"><a href="#nested类型数据" class="headerlink" title="nested类型数据"></a>nested类型数据</h3><pre><code>GET /goods/info/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;title&quot;: &#123;              &quot;query&quot;: &quot;荣耀手机&quot;,              &quot;operator&quot;: &quot;and&quot;            &#125;          &#125;        &#125;,        &#123;          &quot;nested&quot;: &#123;            &quot;path&quot;: &quot;attrs&quot;,            &quot;query&quot;: &#123;              &quot;bool&quot;: &#123;                &quot;must&quot;: [                  &#123;                    &quot;term&quot;: &#123;                      &quot;attrs.attrId&quot;: &#123;                        &quot;value&quot;: &quot;3&quot;                      &#125;                    &#125;                  &#125;,                  &#123;                    &quot;term&quot;: &#123;                      &quot;attrs.attrValue&quot;: &#123;                        &quot;value&quot;: &quot;8GB&quot;                      &#125;                    &#125;                  &#125;                ]              &#125;            &#125;          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><pre><code>#分页查询#过滤条件#排序 #高亮显示   GET /goods/info/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;title&quot;: &#123;              &quot;query&quot;: &quot;小米手机&quot;,              &quot;operator&quot;: &quot;or&quot;            &#125;          &#125;        &#125;,        &#123;          &quot;nested&quot;: &#123;            &quot;path&quot;: &quot;attrs&quot;,            &quot;query&quot;: &#123;              &quot;bool&quot;: &#123;                &quot;must&quot;: [                  &#123;                    &quot;term&quot;: &#123;                      &quot;attrs.attrId&quot;: &#123;                        &quot;value&quot;: &quot;3&quot;                      &#125;                    &#125;                  &#125;,                  &#123;                    &quot;term&quot;: &#123;                      &quot;attrs.attrValue&quot;: &#123;                        &quot;value&quot;: &quot;8GB&quot;                      &#125;                    &#125;                  &#125;                ]              &#125;            &#125;          &#125;        &#125;      ]    &#125;  &#125;,  &quot;from&quot;: 0,  &quot;size&quot;: 2,  &quot;sort&quot;: [    &#123;      &quot;hotScore&quot;: &#123;        &quot;order&quot;: &quot;desc&quot;      &#125;    &#125;  ],  &quot;highlight&quot;: &#123;    &quot;pre_tags&quot;: [&quot;&lt;span style=color:red&gt;&quot;],    &quot;fields&quot;: &#123;      &quot;title&quot;: &#123;&#125;    &#125;,    &quot;post_tags&quot;: [&quot;&lt;/span&gt;&quot;]  &#125;&#125;</code></pre><h2 id="Java代码实现DSL语句"><a href="#Java代码实现DSL语句" class="headerlink" title="Java代码实现DSL语句"></a>Java代码实现DSL语句</h2><p>检索的条件对象: 实体类<br>检索的请求信息url.参数等,controller</p><p>检索类型:<br>  关键字检索<br>  索引检索</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2022/05/05/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/05/05/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>串行化执行改为并行化执行</p></li><li><p>串行化:纵向执行</p></li><li><p>并行化:横向执行<br>Java异步关键类:<code>CompletableFuture</code></p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>Java 8新增<code>CompletableFuture</code><br><code>CompletableFuture</code>实现<code>CompletionStage</code>接口和<code>Future</code>接口<br><code>CompletableFuture</code>提供Future的扩展功能;简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法</p></li></ul><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><p><code>thenApply</code> ：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。<br><code>thenAccept</code>：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。<br><code>thenRun</code>   ：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作<br>方法带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/05/Java/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2022/05/05/Java/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>什么是集群?什么是分布式?二者的区别<br>孔汤姆<br>于 2019-05-07 09:37:53 发布<br>7761<br>收藏 156<br>分类专栏： 架构<br>版权<br>架构<br>专栏收录该内容<br>14 篇文章1 订阅<br>订阅专栏<br>1.单机结构<br>大家最最最熟悉的就是单机结构，一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。<br>那么，单机结构有啥缺点呢？我想缺点是显而易见的，单机的处理能力毕竟是有限的，<br>当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式.<br>2.什么是集群<br>集群的背景:<br>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。<br>负载均衡:<br>但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，<br>然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。<br>集群结构的优势:<br>集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。<br>集群存在的问题:<br>当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。<br>3.什么是分布式<br>分布式的概念:<br>分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，<br>在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。<br>例子:<br>假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。<br>如果服务之间有依赖关系，那么通过RPC方式调用。<br>分布式的优势:<br>系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。<br>系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。<br>服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。<br>3.二者的区别<br>从单机结构到集群结构，你的代码基本无需要作任何修改，<br>你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了<br>。但是，当你要从集群结构演进到微服务结构的时候，之前的那套代码就需要发生较大的改动了。所以对于新系统我们建议，系统设计之初就采用微服务架构，这样后期运维的成本更低。但如果一套老系统需要升级成微服务结构的话，那就得对代码大动干戈了。所以，对于老系统而言，究竟是继续保持集群模式，还是升级成微服务架构，这需要你们的架构师深思熟虑、权衡投入产出比。<br>我记得在一本讲 tcp/ip 的书上有这样一句话：分布式是指 多个系统协同合作完成一个特定任务的系统。<br>分布式是解决中心化管理的问题，把所有的任务叠加到一个节点处理，太慢了。<br>所以把一个大的问题拆分为多个小的问题，并分别解决，最终协同合作。分布式的主要工作是分解任务，将职能拆解。<br>2） 集群主要的使用场景是为了分担请求的压力，也就是在几个服务器上部署相同的应用程序，来分担客户端请求。<br>当压力进一步增大的时候，可能在需要存储的部分，mysql无法面对很多的写压力。因为在mysql做成集群之后，主要的写压力还是在master的机器上面，其他slave机器无法分担写压力，从而这个时候，也就引出来分布式。<br>分布式的主要应用场景是单台机器已经无法满足这种性能的要求，必须要融合多个节点，并且节点之间是相关之间有交互的。相当于在写mysql的时候，每个节点存储部分数据，也就是分布式存储的由来。在存储一些非结构化数据：静态文件、图片、pdf、小视频 … 这些也就是分布式文件系统的由来。<br>3）集群主要是简单加机器解决问题，对于问题本身不做任何分解；<br>集群和分布式都是由多个节点组成，但是集群之间的通信协调基本不需要；而分布式各个节点的通信协调必不可少。<br>将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），然后部署多个相同的子系统在不同的服务器上（这叫集群），部署在不同服务器上的同一个子系统应做负载均衡。<br>分布式：一个业务拆分为多个子业务，部署在多个服务器上 。<br>集群：同一个业务，部署在多个服务器上 。<br>集群：多个人在一起作同样的事 。<br>分布式 ：多个人在一起作不同的事 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存相关</title>
      <link href="/2022/05/04/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/05/04/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>是指缓存中某一个key失效,如果出现高并发,则直接查询数据库,导致系统崩溃</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><pre><code>加锁: 分布式锁基于redis实现分布式锁.锁的本质是: 可以放过一个请求,去数据库里查询,让其他的请求处于睡眠状态,放过的请求;查询到数据,放到缓存中后,再唤醒其他的请求,其他请求就直接查询缓存了,给数据库减轻了压力.                         </code></pre><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>  是指用户查询一个在数据库中根本不存在的数据,(数据库中没有这条记录),那么我们<br>  做缓存的时候,不向缓存中放入数据的话,会导致缓存穿透.<br>  :不进缓存,直接进入数据库</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式:"></a>解决方式:</h3><pre><code>代码判断  if(数据库也没有数据)&#123;  在缓存中设置一个null值  set 49 null   expire 49  60*10  设置一个10分钟失效&#125;                </code></pre><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><pre><code>是指在同一时刻,缓存中的多个key全部失效,如果出现高并发,则会直接查询数据库</code></pre><p>  <code>可能导致系统崩溃</code></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>  缓存key,不要设置同一过期时间!   expire key timout </p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存相关面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存相关</title>
      <link href="/2022/05/04/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/05/04/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>是指缓存中某一个key失效,如果出现高并发,则直接查询数据库,导致系统崩溃</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><pre><code>加锁: 分布式锁基于redis实现分布式锁.锁的本质是: 可以放过一个请求,去数据库里查询,让其他的请求处于睡眠状态,放过的请求;查询到数据,放到缓存中后,再唤醒其他的请求,其他请求就直接查询缓存了,给数据库减轻了压力.                         </code></pre><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>  是指用户查询一个在数据库中根本不存在的数据,(数据库中没有这条记录),那么我们<br>  做缓存的时候,不向缓存中放入数据的话,会导致缓存穿透.<br>  :不进缓存,直接进入数据库</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式:"></a>解决方式:</h3><pre><code>代码判断  if(数据库也没有数据)&#123;  在缓存中设置一个null值  set 49 null   expire 49  60*10  设置一个10分钟失效&#125;                </code></pre><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><pre><code>是指在同一时刻,缓存中的多个key全部失效,如果出现高并发,则会直接查询数据库</code></pre><p>  <code>可能导致系统崩溃</code></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>  缓存key,不要设置同一过期时间!   expire key timout </p><h2 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h2><h3 id="本地锁-synchronized"><a href="#本地锁-synchronized" class="headerlink" title="本地锁(synchronized):"></a>本地锁(synchronized):</h3><p>  单服务<br>  结果：没有问题<br>  多服务(集群)<br>  server.port 8206<br>  server.port 8226<br>  server.port 8236<br>  结果：数据错误</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>测试本地锁: 单击版本  没有问题</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>使用redis做分布式锁(redisson )</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问量较大</title>
      <link href="/2022/05/04/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%AE%BF%E9%97%AE%E9%87%8F%E8%BE%83%E5%A4%A7/"/>
      <url>/2022/05/04/Java/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%AE%BF%E9%97%AE%E9%87%8F%E8%BE%83%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="引发问题"><a href="#引发问题" class="headerlink" title="引发问题"></a>引发问题</h2><p>访问量较大,可能引发:服务器宕机;客户体验度不好</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="优化SQL语句"><a href="#优化SQL语句" class="headerlink" title="优化SQL语句"></a>优化SQL语句</h3><h3 id="避免直接查询数据库-使用缓存"><a href="#避免直接查询数据库-使用缓存" class="headerlink" title="避免直接查询数据库,使用缓存"></a>避免直接查询数据库,使用缓存</h3><p>这里使用redis进行缓存</p><ol><li>添加缓存依赖(pom)<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- redis --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- spring2.X集成redis所需common-pool2--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li>创建配置类<br> com.doyens.gmall.common.config.RedisConfig</li><li>使用<br> 见名知意   set  key名称:id值  数据</li><li>定义好的key名称<br> com.doyens.gmall.common.constant.RedisConst</li><li>缓存使用规则:<br>   查询时:  先访问缓存是否有数据<pre><code>   true: 直接返回   false: 没有,需要查询数据库,并将结果存储到缓存,同时将数据库数据返回给客户端.</code></pre></li></ol><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/05/04/Java/SpringBoot+Redis/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/05/04/Java/SpringBoot+Redis/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><p>  访问量较大,可能引发:服务器宕机;客户体验度不好</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>添加缓存依赖(pom)<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- redis --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- spring2.X集成redis所需common-pool2--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li>创建配置类<br> com.doyens.gmall.common.config.RedisConfig</li><li>使用<br> 见名知意   set  key名称:id值  数据</li><li>定义好的key名称<br> com.doyens.gmall.common.constant.RedisConst</li><li>缓存使用规则:<br>   查询时:  先访问缓存是否有数据<pre><code>   true: 直接返回   false: 没有,需要查询数据库,并将结果存储到缓存,同时将数据库数据返回给客户端.</code></pre></li></ol><h2 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h2><p>官网Github 地址：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>导入依赖</li><li>配置类</li><li>使用<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3>解决并发引起的问题,可异步</li></ol><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>保证读的数据和写的数据一致</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot+Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="/2022/05/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/05/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>关于InnoDB 存储引擎的有聚集索引和非聚集索引，覆盖索引，回表，索引下推等概念，这些知识点比较多，也比较零碎，但是概念都是基于索引建立的，本文从索引查找数据讲述上述概念。</p><p>聚集索引和非聚集索引<br>在 MySQL 数据库中 InnoDB 存储引擎，B+ 树可分为聚集索引和非聚集索引。聚集索引也叫聚簇索引，非聚集索引也叫辅助索引或者二级索引。<br>建表的时候都会创建一个聚集索引，每张表都有唯一的聚集索引：</p><p>如果主键被定义了，那么这个主键就是作为聚集索引</p><p>如果没有主键被定义，那么该表的第一个唯一非空索引作为聚集索引</p><p>如果没有主键也没有唯一索引，InnoDB 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个 6 个字节的列，该类的值会随着数据的插入自增。</p><p>在创建表添加的索引都是非聚集索引，非聚集索引就是一个为了找到聚集索引的二级索引，通过二级索引索引找到主键，再查找数据。<br>创建一个表 T,表中有个一个主键id。表中有字段 k,并创建在 k 字段上创建索引。</p><p>mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;<br>在表中插入数据分别为(100,1)、（200,2）、（300,3）、（500,5）、（600,6），分别用R1~R5表示。当创建表和插入数据后会生成两棵树：</p><p>其中左边的是聚集索引，右边的是非聚集索引。非聚集索引叶子节点存储的是主键的值，聚集索引存储的是整行的数据。<br>执行 select * from T where k between 3 and 5,有以下的执行流程：</p><p>1、在 k 索引树上找到 k = 3,取得ID = 300</p><p>2、再到 ID 索引树查到 ID=300对应的R3</p><p>3、在 k 索引树取下一个值 k=5，取得ID=500</p><p>4、再回到 ID 索引树查到 ID=500对应的 R4</p><p>5、在 k 索引树取下一个值 k=6，不满足条件，查询结束</p><p>在这个过程中，从二级索引回答主键索引树查找的过程，称为回表。上面流程回表了两次，分别是步骤2和步骤4。</p><p>覆盖索引<br>如果执行的语句是 select ID from T where k between 3 and 5,这个时候只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，这个时候就不需要回表，也就是说在这个查询中，索引 k “覆盖了”查询，这个称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数，提高查询性能，所以使用覆盖索引是一个常用的索引优化手段。</p><p>使用覆盖索引最常见的方法是创建联合索引，将需要查询的字段都放在联合索引上。</p><p>最左前缀原则<br>最左前缀原则，指的是在一个复合索引中（a,b,c），b+ 树会按照从左往右的顺序建立搜索树，b+ 树会优先比较 a，如果 a 相同在依次比较 b 和 c，最后得到检索数据，但是像查询（b，c）这样的数据没有 a 字段，b+树就不知道从哪个结点查起了。因为搜索树的第一个比较因子就是 a。</p><p>索引下推（icp）<br>索引下推是 mysql 5.6 新特性</p><p>创建一个表 use,其中主要有几个字段：id、name、age、address。建立联合索引（name,age）。</p><p>mysql&gt; create table use(id int primary key, name varchar(16), age int ,index(name,age))engine=InnoDB;<br>在表中分别插入数据，（ID3，张六，30），（ID4，张三，10），（ID5，张三，10），（106，张三,20）<br>要执行以下查询：</p><p>select * from user where name like ‘张%’ and age=10<br>上面说到 InnoDB 索引满足最左匹配原则，当不符合最左前缀，会怎么样呢？在这个搜索树中，只能用“张”，找到一个满足条件 103,然后再判断其他条件是否满足。</p><p>这条语句在 Mysql 5.6 之前和 Mysql 5.6 以及 Mysql 5.6 以后版本执行是不一致的。</p><p>Mysql 5.6 之前<br>在 5.6 之前是没有索引下推的，只能从 ID3 开始一个个回表，虚线表示回表。到主键索引上找数据行，再对比字段值，如下图：</p><p>5.6 引入了索引下推，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤到不满足条件的记录，减少回表次数。如下图：</p><p>有了索引下推后，InnoDB 在（name，age）索引内就判断了 age 是否等于 10，不等于 10 的直接跳过，所以上面只需要回表 2 次。</p><p>总结<br>本文从索引查询数据流程上介绍了数据库索引的概念，包括聚集索引、非聚集索引、覆盖索引、回表、最左匹配、索引下推，对于基础的掌握可以更快的做数据库的优化，比如减少回表的次数，最好使用聚集索引，或者覆盖索引。加快数据查询速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 回表查询和索引覆盖</title>
      <link href="/2022/05/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/"/>
      <url>/2022/05/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>InnoDB有两大类索引</p><ul><li>聚集索引(clustered index)<ul><li>InnoDB 聚集索引 的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引</li><li>(1)如果表定义了PK，则PK就是聚集索引；</li><li>(2)如果表没有定义PK，则第一个not NULL unique列是聚集索引；</li><li>(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</li><li>PK查询非常快，直接定位行记录。</li></ul></li><li>普通索引(secondary index)<ul><li>InnoDB 普通索引 的叶子节点存储主键值。</li><li>注意，不是存储行记录头指针，MyISAM的索引叶子节点存储记录指针。<h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2>(1)先通过普通索引定位到主键值id=5；<br>(2)在通过聚集索引定位到行记录；<br>这就是所谓的 回表查询 ，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sku与spu</title>
      <link href="/2022/05/01/%E4%B8%9A%E5%8A%A1/spu%E4%B8%8Esku/"/>
      <url>/2022/05/01/%E4%B8%9A%E5%8A%A1/spu%E4%B8%8Esku/</url>
      
        <content type="html"><![CDATA[<h2 id="spu的概述"><a href="#spu的概述" class="headerlink" title="spu的概述"></a>spu的概述</h2><p>SPU(Standard Product Unit)：标准化产品单元<br>用简单的话来说就是一类商品，比如手机里的一种牌子，如小米，iPhone，都是一类。然后加入具体的类型，如小米10、iPhone X。那么它就是一个spu。</p><h2 id="sku的概述"><a href="#sku的概述" class="headerlink" title="sku的概述"></a>sku的概述</h2><p>SKU(Stock keeping Unit)：库存保有单位<br>sku简单来说就是在spu原有的基础上加入具体的类型，如小米10，银色，8+128g。组合起来就是一个完整地sku。所以sku就是一类商品的各种样式的组合。<br>sku的组合无关其他只影响该商品的价格。</p><h2 id="spu和sku的关系"><a href="#spu和sku的关系" class="headerlink" title="spu和sku的关系"></a>spu和sku的关系</h2><p>spu和sku就是上下级关系，没有spu就没有sku。因为假如都没有这一类商品那何谈这件商品具体的颜色尺寸呢？<br>如下图：假如没有选择任何类型那么他就是一个单独的spu，但是当它选择了具体的颜色，版本，购买方式等等，那么他就是一个sku。</p><p>sku是一种库存计量单位。</p><p>sku和spu的区别：计量单位不同、描述特性不同、产品分类不同。</p><p>一、计量单位不同：</p><p>SPU = Standard Product Unit （标准产品单位），SPU是商品信息聚合的最小单位；</p><p>SKU=stock keeping unit(库存量单位)，SKU即库存进出计量的单位。</p><p>二、描述特性不同：</p><p>SPU是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性；</p><p>SKU的计量可以是以件、盒、托盘等为单体，就是物理上不可分割的最小存货单元。</p><p>三、产品分类不同：</p><p>SPU描述的就是属性值、特性相同的商品。例如：iphone4就是一个SPU，与商家，与颜色、款式、套餐都无关。</p><p>SKU在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。例如：纺织品中一个SKU通常表示：规格、颜色、款式。</p>]]></content>
      
      
      <categories>
          
          <category> 业务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电商 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 视图</title>
      <link href="/2022/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E8%A7%86%E5%9B%BE/"/>
      <url>/2022/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL 视图（View）是虚拟存在的表，视图也由列和行构成，但<strong>视图并不实际存在于数据库中</strong>。<br>行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据库中只存放视图的定义，并没有存放视图中的数据，这些数据都存放在定义视图查询所引用的真实表中。<br><strong>使用视图查询数据时，数据库会从真实表中取出对应的数据</strong>。<br>因此，视图中的数据是依赖于真实表中的数据的。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。</p><p>视图可以从原有的表上选取对用户有用的信息，那些对用户没用，或者用户没有权限了解的信息，都可以直接屏蔽掉，作用类似于筛选。这样做既使应用简单化，也保证了系统的安全。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>视图不是真实的表，而是虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的<br>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。<br>数据实际上是存储在视图所引用的真实表中的。<br>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。<br>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。<br>视图的建立和删除只影响视图本身，不影响对应的基本表</p><h2 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h2><p>视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。同时，视图具有如下优点：</p><ol><li>定制用户数据，聚焦特定的数据<br>在实际的应用过程中，不同的用户可能对不同的数据有不同的要求。</li></ol><p>例如，当数据库同时存在时，如学生基本信息表、课程表和教师信息表等多种表同时存在时，可以根据需求让不同的用户使用各自的数据。学生查看修改自己基本信息的视图，安排课程人员查看修改课程表和教师信息的视图，教师查看学生信息和课程信息表的视图。<br>2) 简化数据操作<br>在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。<br>3) 提高数据的安全性<br>视图是虚拟的，物理上是不存在的。可以只授予用户视图的权限，而不具体指定使用表的权限，来保护基础数据的安全。<br>4) 共享所需数据<br>通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。<br>5) 更改数据格式<br>通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中。<br>6) 重用 SQL 语句<br>视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图。</p><p>要注意区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>创建视图需要足够的访问权限。<br>创建视图的数目没有限制。<br>视图可以嵌套，即从其他视图中检索数据的查询来创建视图。<br>视图不能索引，也不能有关联的触发器、默认值或规则。<br>视图可以和表一起使用。<br>视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。<br>提示：ORDER BY 子句可以用在视图中，但若该视图检索数据的 SELECT 语句中也含有 ORDER BY 子句，则该视图中的 ORDER BY 子句将被覆盖。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>如果经常需要从多个表查询指定字段的数据，可以在这些表上建立一个视图，通过这个视图显示这些字段的数据</strong>。</p><p>MySQL 的视图不支持输入参数的功能，因此交互性上还有欠缺。但对于变化不是很大的操作，使用视图可以很大程度上简化用户的操作。</p><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>CREATE VIEW base_category_view AS<br>select<br>c3.id as id,<br>c1.id as category1_id, c1.name as category1_name,<br>c2.id as category2_id, c2.name as category2_name,<br>c3.id as category3_id, c3.name as category3_name<br>from base_category1 c1<br>inner join base_category2 c2 on c2.category1_id = c1.id<br>inner join base_category3 c3 on c3.category2_id = c2.id</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>service的支持</title>
      <link href="/2022/04/26/Java/MybatisPlus/%E5%AF%B9service%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2022/04/26/Java/MybatisPlus/%E5%AF%B9service%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MybatisPlus提供了对Service的支持<br>Service的接口继承Iservice,Service的实体类继承ServiceImpl即可使用MybatisPlus提供的方法</p><h2 id="Iservice"><a href="#Iservice" class="headerlink" title="Iservice"></a>Iservice<T></T></h2><p>service接口继承Iservice&lt;pojo实体类&gt;<br>Iservice内部提供了一些单表操作方法</p><h2 id="ServiceImpl-lt-mapper接口-class-pojo实体类-gt"><a href="#ServiceImpl-lt-mapper接口-class-pojo实体类-gt" class="headerlink" title="ServiceImpl&lt;mapper接口.class,pojo实体类&gt;"></a>ServiceImpl&lt;mapper接口.class,pojo实体类&gt;</h2><p>service实现类继承ServiceImpl&lt;mapper接口,pojo实体类&gt;即可使用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2022/04/26/Java/fastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/26/Java/fastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>FastDFS 是一个由 C 语言实现的开源轻量级分布式文件系统，<br>支持 Linux、FreeBSD、AID 等 Unix 系统<br>解决了大数据存储和读写负载均衡等问题<br>适合存储 <code>4KB~500MB</code> 之间的小文件，如图片网站、短视频网站、文档、app 下载站等</p><h2 id="FastDFS上传的流程"><a href="#FastDFS上传的流程" class="headerlink" title="FastDFS上传的流程"></a>FastDFS上传的流程</h2><p><img src="/2022/04/26/Java/fastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%AE%80%E4%BB%8B/%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B.png"><br>只要 storage 返回图片的路径图片名称，就能通过浏览器来访问图片<br>图片服务器在linux;  nginx 做反向代理{图片服务器}</p><h2 id="利用Java客户端调用FastDFS"><a href="#利用Java客户端调用FastDFS" class="headerlink" title="利用Java客户端调用FastDFS"></a>利用Java客户端调用FastDFS</h2><p>tracker.config  FastDFS的配置文件</p><h2 id="文件上传服务器"><a href="#文件上传服务器" class="headerlink" title="文件上传服务器"></a>文件上传服务器</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>安装fastDFS服务器 配置</p></li><li><p>写配置文件 定义上传的地址</p></li><li><p>Java实现文件上传操作</p></li><li><p>配置tracker.config 文件上传地址</p></li><li><p>配置fileServerUrl 文件访问地址</p></li><li><p>实现</p></li><li><p>加载配置文件 tracker.conf 文件</p></li><li><p>初始化文件</p></li><li><p>创建TrackerClient</p></li><li><p>创建TrackerServer</p></li><li><p>创建StorgeServer</p></li><li><p>上传文件</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-Java"><code class="language-Java">package com.doyens.gmall.product.controller;import com.doyens.gmall.common.result.Result;import org.apache.commons.io.FilenameUtils;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;/** * @author zrh * @date 2022/4/26 * @apiNote */@RestController@RequestMapping("admin/product/")public class FileUploadController &#123;    @Value("$&#123;fileServer.url&#125;")    private String fileUrl;    @RequestMapping("fileUpload")    public Result<String> fileUpload(MultipartFile file) throws Exception &#123;        String configFile = this.getClass().getResource("/tracker.conf").getFile();        String path = null;        if (configFile != null) &#123;            // 初始化            ClientGlobal.init(configFile);            // 创建trackerClient            TrackerClient trackerClient = new TrackerClient();            // 获取trackerService            TrackerServer trackerServer = trackerClient.getConnection();            // 创建storageClient1            StorageClient1 storageClient1 = new StorageClient1(trackerServer, null);            path = storageClient1.upload_appender_file1(file.getBytes(), FilenameUtils.getExtension(file.getOriginalFilename()), null);            System.out.println(fileUrl + path);        &#125;        return Result.ok(fileUrl + path);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastDFS服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/04/21/Java/docker/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/21/Java/docker/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot单元测试</title>
      <link href="/2022/04/20/Java/SpringBoot/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/04/20/Java/SpringBoot/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBootTest"><a href="#SpringBootTest" class="headerlink" title="@SpringBootTest"></a>@SpringBootTest</h2><p>测试类需要添加@SpringBootTest注解<br>@SpringBootTest(classes = 启动类.class)</p><pre class=" language-Java"><code class="language-Java">@SpringBootTestclass TestApplicationTests &#123;    @Test    void contextLoads() &#123;    &#125;&#125;</code></pre><h2 id="RunWith-SpringRunner-class"><a href="#RunWith-SpringRunner-class" class="headerlink" title="@RunWith(SpringRunner.class)"></a>@RunWith(SpringRunner.class)</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate</title>
      <link href="/2022/04/19/Java/Spring/RestTemplate/"/>
      <url>/2022/04/19/Java/Spring/RestTemplate/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化。<br>RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/"/>
      <url>/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Thymeleaf简介"><a href="#1-Thymeleaf简介" class="headerlink" title="1.Thymeleaf简介"></a>1.Thymeleaf简介</h1><p>官方网站：<a href="https://www.thymeleaf.org/index.html">https://www.thymeleaf.org/index.html</a></p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526434145635.png" alt="1526434145635"></p><p><strong>Thymeleaf</strong>是用来开发Web和独立环境项目的现代服务器端Java模板引擎。</p><p>Thymeleaf的主要目标是为您的开发工作流程带来优雅的<em>自然模板</em> - HTML。可以在直接浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。</p><p>借助Spring Framework的模块，可以根据自己的喜好进行自由选择，可插拔功能组件，Thymeleaf是现代HTML5 JVM Web开发的理想选择 - 尽管它可以做的更多。</p><p>Spring官方支持的服务的渲染模板中，并不包含jsp。而是Thymeleaf和Freemarker等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h1><p>特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><h1 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3.环境准备"></a>3.环境准备</h1><p>我们来创建一个module，为学习Thymeleaf做准备：</p><h2 id="3-1-创建module"><a href="#3-1-创建module" class="headerlink" title="3.1.创建module"></a>3.1.创建module</h2><p>使用spring 脚手架创建：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435213659.png" alt="1526435213659"></p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435267302.png" alt="1526435267302"></p><p>勾选web和Thymeleaf的依赖：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435317440.png" alt="1526435317440"></p><p>项目结构：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435434999.png" alt="1526435434999"></p><p>pom：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.leyou.demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>thymeleaf-demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>thymeleaf-demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h2 id="3-2-默认配置"><a href="#3-2-默认配置" class="headerlink" title="3.2.默认配置"></a>3.2.默认配置</h2><p>不需要做任何配置，启动器已经帮我们把Thymeleaf的视图器配置完成：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435647041.png" alt="1526435647041"></p><p>而且，还配置了模板文件（html）的位置，与jsp类似的前缀+ 视图名 + 后缀风格：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526435706301.png" alt="1526435706301"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>Thymeleaf默认会开启页面缓存，提高页面并发能力。但会导致我们修改页面不会立即被展现，因此我们关闭缓存：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 关闭Thymeleaf的缓存</span><span class="token attr-name">spring.thymeleaf.cache</span><span class="token punctuation">=</span><span class="token attr-value">false</span></code></pre><p>另外，修改完毕页面，需要使用快捷键：<code>Ctrl + Shift + F9</code>来刷新工程。</p><h2 id="3-3-快速开始"><a href="#3-3-快速开始" class="headerlink" title="3.3.快速开始"></a>3.3.快速开始</h2><p>我们准备一个controller，控制视图跳转：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"show1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">show1</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"Hello, Thymeleaf!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>新建一个html模板：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;msg&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>大家好<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p><strong>注意</strong>，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><p>启动项目，访问页面：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526436248528.png" alt="1526436248528"></p><h1 id="4-语法"><a href="#4-语法" class="headerlink" title="4.语法"></a>4.语法</h1><p>Thymeleaf的主要作用是把model中的数据渲染到html中，因此其语法主要是如何解析model中的数据。从以下方面来学习：</p><ul><li>变量</li><li>方法</li><li>条件判断</li><li>循环</li><li>运算<ul><li>逻辑运算</li><li>布尔运算</li><li>比较运算</li><li>条件运算</li></ul></li><li>其它</li></ul><h2 id="4-1-变量"><a href="#4-1-变量" class="headerlink" title="4.1.变量"></a>4.1.变量</h2><h3 id="变量案例"><a href="#变量案例" class="headerlink" title="变量案例"></a>变量案例</h3><p>我们先新建一个实体类：User</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    User friend<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 对象类型属性</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>然后在模型中添加数据</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"show2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">show2</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Jack Chen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setFriend</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"李小龙"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"show2"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>语法说明：</p></blockquote><p>Thymeleaf通过<code>$&#123;&#125;</code>来获取model中的变量，注意这不是el表达式，而是ognl表达式，但是语法非常像。</p><blockquote><p>示例：</p></blockquote><p>我们在页面获取user数据：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>    欢迎您：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>请登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre><p>效果：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526438010948.png" alt="1526438010948"></p><p>感觉跟el表达式几乎是一样的。不过区别在于，我们的表达式写在一个名为：<code>th:text</code>的标签属性中，这个叫做<code>指令</code></p><h3 id="动静结合"><a href="#动静结合" class="headerlink" title="动静结合"></a>动静结合</h3><blockquote><p>指令：</p></blockquote><p>Thymeleaf崇尚<code>自然模板</code>，意思就是模板是纯正的html代码，脱离模板引擎，在纯静态环境也可以直接运行。现在如果我们直接在html中编写 <code>$&#123;&#125;</code>这样的表达式，显然在静态环境下就会出错，这不符合Thymeleaf的理念。</p><p>Thymeleaf中所有的表达式都需要写在<code>指令</code>中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以<code>th:</code>开头。因为表达式<code>$&#123;user.name&#125;</code>是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了！</p><p>现在，我们不经过SpringMVC，而是直接用浏览器打开页面看看：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526438337869.png" alt="1526438337869"></p><ul><li>静态页面中，<code>th</code>指令不被识别，但是浏览器也不会报错，把它当做一个普通属性处理。这样<code>span</code>的默认值<code>请登录</code>就会展现在页面</li><li>如果是在Thymeleaf环境下，<code>th</code>指令就会被识别和解析，而<code>th:text</code>的含义就是替<strong>换所在标签中的文本内容</strong>，于是<code>user.name</code>的值就替代了 <code>span</code>中默认的请登录</li></ul><p>指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。</p><blockquote><p>向下兼容</p></blockquote><p>但是要注意，如果浏览器不支持Html5怎么办？</p><p>如果不支持这种<code>th:</code>的命名空间写法，那么可以把<code>th:text</code>换成 <code>data-th-text</code>，Thymeleaf也可以兼容。</p><blockquote><p>escape</p></blockquote><p>另外，<code>th:text</code>指令出于安全考虑，会把表达式读取到的值进行处理，防止html的注入。</p><p>例如，<code>&lt;p&gt;你好&lt;/p&gt;</code>将会被格式化输出为<code>$lt;p$gt;你好$lt;/p$lt;</code>。</p><p>如果想要不进行格式化输出，而是要输出原始内容，则使用<code>th:utext</code>来代替.</p><h3 id="ognl表达式的语法糖"><a href="#ognl表达式的语法糖" class="headerlink" title="ognl表达式的语法糖"></a>ognl表达式的语法糖</h3><p>刚才获取变量值，我们使用的是经典的<code>对象.属性名</code>方式。但有些情况下，我们的属性名可能本身也是变量，怎么办？</p><p>ognl提供了类似js的语法方式：</p><p>例如：<code>$&#123;user.name&#125;</code> 可以写作<code>$&#123;user[&#39;name&#39;]&#125;</code></p><h2 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2.自定义变量"></a>4.2.自定义变量</h2><blockquote><p>场景</p></blockquote><p>看下面的案例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Name: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Jack<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Age: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>friend: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.friend.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Rose<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></code></pre><p>我们获取用户的所有信息，分别展示。</p><p>当数据量比较多的时候，频繁的写<code>user.</code>就会非常麻烦。</p><p>因此，Thymeleaf提供了自定义变量来解决：</p><blockquote><p>示例：</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name"><span class="token namespace">th:</span>object</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Name: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*&amp;#123;name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Jack<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Age: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*&amp;#123;age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>friend: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*&amp;#123;friend.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Rose<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></code></pre><ul><li>首先在 <code>h2</code>上 用 <code>th:object=&quot;$&#123;user&#125;&quot;</code>获取user的值，并且保存</li><li>然后，在<code>h2</code>内部的任意元素上，可以通过 <code>*&#123;属性名&#125;</code>的方式，来获取user中的属性，这样就省去了大量的<code>user.</code>前缀了</li></ul><h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3.方法"></a>4.3.方法</h2><blockquote><p>ognl表达式中的方法调用</p></blockquote><p>ognl表达式本身就支持方法调用，例如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name"><span class="token namespace">th:</span>object</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>FirstName: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*&amp;#123;name.split(<span class="token punctuation">'</span> <span class="token punctuation">'</span>)[0]&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Jack<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>LastName: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*&amp;#123;name.split(<span class="token punctuation">'</span> <span class="token punctuation">'</span>)[1]&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></code></pre><ul><li>这里我们调用了name（是一个字符串）的split方法。</li></ul><blockquote><p>Thymeleaf内置对象</p></blockquote><p>Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用<code>#对象名</code>来引用。</p><ul><li>一些环境相关对象</li></ul><table><thead><tr><th align="center">对象</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center"><code>#ctx</code></td><td align="left">获取Thymeleaf自己的Context对象</td></tr><tr><td align="center"><code>#requset</code></td><td align="left">如果是web程序，可以获取HttpServletRequest对象</td></tr><tr><td align="center"><code>#response</code></td><td align="left">如果是web程序，可以获取HttpServletReponse对象</td></tr><tr><td align="center"><code>#session</code></td><td align="left">如果是web程序，可以获取HttpSession对象</td></tr><tr><td align="center"><code>#servletContext</code></td><td align="left">如果是web程序，可以获取HttpServletContext对象</td></tr><tr><td align="center"></td><td align="left"></td></tr></tbody></table><ul><li>Thymeleaf提供的全局对象：</li></ul><table><thead><tr><th align="center">对象</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center"><code>#dates</code></td><td align="left">处理java.util.date的工具对象</td></tr><tr><td align="center"><code>#calendars</code></td><td align="left">处理java.util.calendar的工具对象</td></tr><tr><td align="center"><code>#numbers</code></td><td align="left">用来对数字格式化的方法</td></tr><tr><td align="center"><code>#strings</code></td><td align="left">用来处理字符串的方法</td></tr><tr><td align="center"><code>#bools</code></td><td align="left">用来判断布尔值的方法</td></tr><tr><td align="center"><code>#arrays</code></td><td align="left">用来护理数组的方法</td></tr><tr><td align="center"><code>#lists</code></td><td align="left">用来处理List集合的方法</td></tr><tr><td align="center"><code>#sets</code></td><td align="left">用来处理set集合的方法</td></tr><tr><td align="center"><code>#maps</code></td><td align="left">用来处理map集合的方法</td></tr></tbody></table><ul><li>举例</li></ul><p>我们在环境变量中添加日期类型对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"show3"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">show3</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"today"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"show3"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在页面中处理</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  今天是: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;#dates.format(today,<span class="token punctuation">'</span>yyyy-MM-dd<span class="token punctuation">'</span>)&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2018-04-25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p> 效果：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526440538848.png" alt="1526440538848"></p><h2 id="4-4-字面值"><a href="#4-4-字面值" class="headerlink" title="4.4 字面值"></a>4.4 字面值</h2><p>有的时候，我们需要在指令中填写基本类型如：字符串、数值、布尔等，并不希望被Thymeleaf解析为变量，这个时候称为字面值。</p><ul><li><p>字符串字面值</p><p>使用一对<code>&#39;</code>引用的内容就是字符串字面值了：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  你正在观看 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>thymeleaf<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>template<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 的字符串常量值.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p><code>th:text</code>中的thymeleaf并不会被认为是变量，而是一个字符串</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526958538157.png" alt="1526958538157"></p></li><li><p>数字字面值</p><p>数字不需要任何特殊语法， 写的什么就是什么，而且可以直接进行算术运算</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>今年是 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2018<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1900<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>两年后将会是 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2018 + 2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1902<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526958856078.png" alt="1526958856078"></p></li><li><p>布尔字面值</p><p>布尔类型的字面值是true或false：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    你填的是true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>这里引用了一个<code>th:if</code>指令，跟vue中的<code>v-if</code>类似</p></li></ul><h2 id="4-5-拼接"><a href="#4-5-拼接" class="headerlink" title="4.5 拼接"></a>4.5 拼接</h2><p>我们经常会用到普通字符串与表达式拼接的情况：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>欢迎您:<span class="token punctuation">'</span> + $&amp;#123;user.name&amp;#125; + <span class="token punctuation">'</span>!<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>字符串字面值需要用<code>&#39;&#39;</code>，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对<code>|</code>即可：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>|欢迎您:$&amp;#123;user.name&amp;#125;|<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>与上面是完全等效的，这样就省去了字符串字面值的书写。</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526959781368.png" alt="1526959781368"></p><h2 id="4-6-运算"><a href="#4-6-运算" class="headerlink" title="4.6 运算"></a>4.6 运算</h2><p>需要注意：<code>$&#123;&#125;</code>内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在<code>$&#123;&#125;</code>外进行。</p><ul><li><p>算术运算</p><p>支持的算术运算符：<code>+ - * / %</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;%2 <span class="token punctuation">=</span><span class="token punctuation">=</span> 0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526959990356.png" alt="1526959990356"></p></li><li><p>比较运算</p><p>支持的比较运算：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code>  ，但是<code>&gt;</code>, <code>&lt;</code>不能直接使用，因为xml会解析为标签，要使用别名。</p><p>注意 <code>==</code> and <code>!=</code>不仅可以比较数值，类似于equals的功能。</p><p>可以使用的别名：<code>gt (&gt;), lt (&lt;), ge (&gt;=), le (&lt;=), not (!). Also eq (==), neq/ne (!=).</code></p></li><li><p>条件运算</p><ul><li>三元运算</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.sex&amp;#125; ? <span class="token punctuation">'</span>男<span class="token punctuation">'</span>:<span class="token punctuation">'</span>女<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>三元运算符的三个部分：conditon ? then : else</p><p>​    condition：条件</p><p>​    then：条件成立的结果</p><p>​    else：不成立的结果</p><p>其中的每一个部分都可以是Thymeleaf中的任意表达式。</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526960230778.png" alt="1526960230778"></p><ul><li><p>默认值</p><p>有的时候，我们取一个值可能为空，这个时候需要做非空判断，可以使用 <code>表达式 ?: 默认值</code>简写：</p></li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125; ?: <span class="token punctuation">'</span>二狗<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>当前面的表达式值为null时，就会使用后面的默认值。</p><p>注意：<code>?:</code>之间没有空格。</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526960384564.png" alt="1526960384564"></p></li></ul><h2 id="4-7-循环"><a href="#4-7-循环" class="headerlink" title="4.7 循环"></a>4.7 循环</h2><p>循环也是非常频繁使用的需求，我们使用<code>th:each</code>指令来完成：</p><p>假如有用户的集合：users在Context中。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user : $&amp;#123;users&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Onions<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2.41<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span></code></pre><ul><li>${users} 是要遍历的集合，可以是以下类型：<ul><li>Iterable，实现了Iterable接口的类</li><li>Enumeration，枚举</li><li>Interator，迭代器</li><li>Map，遍历得到的是Map.Entry</li><li>Array，数组及其它一切符合数组结果的对象</li></ul></li></ul><p>在迭代的同时，我们也可以获取迭代的状态对象：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user,stat : $&amp;#123;users&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Onions<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2.41<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span></code></pre><p>stat对象包含以下属性：</p><ul><li>index，从0开始的角标</li><li>count，元素的个数，从1开始</li><li>size，总元素个数</li><li>current，当前遍历到的元素</li><li>even/odd，返回是否为奇偶，boolean值</li><li>first/last，返回是否为第一或最后，boolean值</li></ul><h2 id="4-8-逻辑判断"><a href="#4-8-逻辑判断" class="headerlink" title="4.8 逻辑判断"></a>4.8 逻辑判断</h2><p>有了<code>if和else</code>，我们能实现一切功能^_^。</p><p>Thymeleaf中使用<code>th:if</code> 或者 <code>th:unless</code> ，两者的意思恰好相反。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125; &lt; 24<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>小鲜肉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。</p><p>以下情况被认定为true：</p><ul><li>表达式值为true</li><li>表达式值为非0数值</li><li>表达式值为非0字符</li><li>表达式值为字符串，但不是<code>&quot;false&quot;</code>,<code>&quot;no&quot;</code>,<code>&quot;off&quot;</code></li><li>表达式不是布尔、字符串、数字、字符中的任何一种</li></ul><p>其它情况包括null都被认定为false</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526960499522.png" alt="1526960499522"></p><h2 id="4-9-分支控制switch"><a href="#4-9-分支控制switch" class="headerlink" title="4.9 分支控制switch"></a>4.9 分支控制switch</h2><p>这里要使用两个指令：<code>th:switch</code> 和 <code>th:case</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>switch</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.role&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>admin<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户是管理员<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>manager<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户是经理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户是别的玩意<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。</p><p>另外<code>th:case=&quot;*&quot;</code>表示默认，放最后。</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526960621714.png" alt="1526960621714"></p><p>页面：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526961251878.png" alt="1526961251878"></p><h2 id="4-10-JS模板"><a href="#4-10-JS模板" class="headerlink" title="4.10.JS模板"></a>4.10.JS模板</h2><p>模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name"><span class="token namespace">th:</span>inline</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*[[$&amp;#123;user&amp;#125;]]*/</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*[[$&amp;#123;user.age&amp;#125;]]*/</span> <span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><ul><li><p>在script标签中通过<code>th:inline=&quot;javascript&quot;</code>来声明这是要特殊处理的js脚本</p></li><li><p>语法结构：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*[[Thymeleaf表达式]]*/</span> <span class="token string">"静态环境下的默认值"</span><span class="token punctuation">;</span></code></pre><p>因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。</p></li></ul><p>看看页面的源码：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526961583904.png" alt="1526961583904"></p><p>我们的User对象被直接处理为json格式了，非常方便。</p><p>控制台：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B2/1526961525185.png" alt="1526961525185"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Thymeleaf-快速入门"><a href="#5-Thymeleaf-快速入门" class="headerlink" title="5.Thymeleaf 快速入门"></a>5.Thymeleaf 快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/1525517263421.png" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="5-1-为什么是Thymeleaf？"><a href="#5-1-为什么是Thymeleaf？" class="headerlink" title="5.1.为什么是Thymeleaf？"></a>5.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="5-2-提供数据"><a href="#5-2-提供数据" class="headerlink" title="5.2.提供数据"></a>5.2.提供数据</h2><p>编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/all"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">all</span><span class="token punctuation">(</span>ModelMap model<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查询用户</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 放入模型</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"users"</span><span class="token punctuation">,</span> users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span>    <span class="token keyword">return</span> <span class="token string">"users"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="5-3-引入启动器"><a href="#5-3-引入启动器" class="headerlink" title="5.3.引入启动器"></a>5.3.引入启动器</h2><p>直接引入启动器：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/1528133744136.png" alt="1528133744136"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/1528133816179.png" alt="1528133816179"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="5-4-静态页面"><a href="#5-4-静态页面" class="headerlink" title="5.4.静态页面"></a>5.4.静态页面</h2><p>根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：</p><p> <img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/1528134057401.png" alt="1528134057401"></p><p>编写html模板，渲染模型中的数据：</p><p>注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        table &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span><span class="token property">border-collapse</span><span class="token punctuation">:</span> collapse<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">14</span>px<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">80%</span><span class="token punctuation">;</span> <span class="token property">margin</span><span class="token punctuation">:</span> auto&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        table, th, td &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid darkslategray<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-align</span><span class="token punctuation">:</span> center</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> darkslategray<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">30</span>px</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>欢迎光临！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>用户名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>年龄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>性别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>生日<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user : $&amp;#123;users&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.id&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.name&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.userName&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>zhangsan<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.age&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.sex&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;user.birthday&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1980-02-30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>我们看到这里使用了以下语法：</p><ul><li><code>$&#123;&#125;</code> ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;$&#123;user.id&#125;&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5.测试"></a>5.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/1528134027726.png" alt="1528134027726"></p><h2 id="5-6-模板缓存"><a href="#5-6-模板缓存" class="headerlink" title="5.6.模板缓存"></a>5.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 开发阶段关闭thymeleaf的模板缓存</span><span class="token attr-name">spring.thymeleaf.cache</span><span class="token punctuation">=</span><span class="token attr-value">false</span></code></pre><p><strong>注意</strong>：</p><pre><code>在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。eclipse中没有测试过。</code></pre><p>我们可以修改页面，测试一下。</p><p>Emp表:</p><p> 查询 全部     empno   ename    sal      hiredate    deptno</p><p>拔高题:  两表查询</p><p>dept表:  deptno   dname  local   </p><h2 id="idea配置thymeleaf语法报错"><a href="#idea配置thymeleaf语法报错" class="headerlink" title="idea配置thymeleaf语法报错"></a>idea配置thymeleaf语法报错</h2><p>插件Plugins安装Thmeleaf<br><img src="/2022/04/19/Java/Thymeleaf/%E7%AE%80%E4%BB%8B/idea%E4%B8%ADthymeleaf%E6%8A%A5%E9%94%99.png"></p><h2 id="SpringBoot集成thymeleaf开启热部署"><a href="#SpringBoot集成thymeleaf开启热部署" class="headerlink" title="SpringBoot集成thymeleaf开启热部署"></a>SpringBoot集成thymeleaf开启热部署</h2><pre class=" language-yml"><code class="language-yml">spring:  thymeleaf:    cache: false # 改成false启用热部署</code></pre><h2 id="html解析"><a href="#html解析" class="headerlink" title="html解析"></a>html解析</h2><p>th:utext解析html标签</p><p>存入域中</p><pre class=" language-Java"><code class="language-Java">package com.doyens.controller;import com.sun.deploy.net.HttpRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.util.Arrays;import java.util.List;/** * @author zrh * @date 2022/4/29 * @apiNote */@Controllerpublic class IndexController &#123;    @GetMapping("index")    public String index(HttpServletRequest request, HttpSession session) &#123;        request.setAttribute("msg", "提示信息");        List<String> list = Arrays.asList("谢霆锋", "刘德华", "王源");        request.setAttribute("sList", list);        request.setAttribute("age", 18);        session.setAttribute("sname","刘德华");        request.setAttribute("green","<span style=color:green>test</span>");        return "index";    &#125;&#125;</code></pre><p>html页面</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html ></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/1999/xhtml<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>index<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>样式解析1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;green&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>样式解析2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>utext</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;green&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot事务</title>
      <link href="/2022/04/19/Java/SpringBoot/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/04/19/Java/SpringBoot/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="4-6-整合事务"><a href="#4-6-整合事务" class="headerlink" title="4.6.整合事务"></a>4.6.整合事务</h2><p>其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了</p><p> <img src="/2022/04/19/Java/SpringBoot/%E4%BA%8B%E5%8A%A1/1528128711716.png" alt="1528128711716"></p><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token keyword">public</span> User <span class="token function">queryById</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteById</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="4-7-启动测试"><a href="#4-7-启动测试" class="headerlink" title="4.7.启动测试"></a>4.7.启动测试</h2><p>在UserController中添加测试方法，内容：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;id&amp;#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> User <span class="token function">queryUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>Long id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"hello ssm"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们启动项目，查看：</p><p><img src="/2022/04/19/Java/SpringBoot/%E4%BA%8B%E5%8A%A1/1540900351215.png" alt="1540900351215"></p><h2 id="4-8-完整项目结构"><a href="#4-8-完整项目结构" class="headerlink" title="4.8.完整项目结构"></a>4.8.完整项目结构</h2><p> <img src="/2022/04/19/Java/SpringBoot/%E4%BA%8B%E5%8A%A1/assets%5C1574089557722.png" alt="1574089557722"></p><p>完整的pom.xml：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.doyens.user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>doyens-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--jdbc的启动器，默认使用HikariCP连接池--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--mybatis --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 通用mapper --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>tk.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>完整的application.properties：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span><span class="token attr-name">logging.level.org.springframework</span><span class="token punctuation">=</span><span class="token attr-value">debug</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/test</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token comment" spellcheck="true"># mybatis 别名扫描</span><span class="token attr-name">mybatis.type-aliases-package</span><span class="token punctuation">=</span><span class="token attr-value">com.doyens.pojo</span><span class="token comment" spellcheck="true"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><span class="token comment" spellcheck="true"># mybatis.mapper-locations=classpath:mappers/*.xml</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Mybatis</title>
      <link href="/2022/04/19/Java/SpringBoot/mybatis/"/>
      <url>/2022/04/19/Java/SpringBoot/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="4-5-整合mybatis"><a href="#4-5-整合mybatis" class="headerlink" title="4.5.整合mybatis"></a>4.5.整合mybatis</h2><h3 id="4-5-1-mybatis"><a href="#4-5-1-mybatis" class="headerlink" title="4.5.1.mybatis"></a>4.5.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter">官方</a>自己实现了：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mybatis --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>配置，基本没有需要配置的：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># mybatis 别名扫描</span><span class="token attr-name">mybatis.type-aliases-package</span><span class="token punctuation">=</span><span class="token attr-value">com.doyens.pojo</span><span class="token comment" spellcheck="true"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:mappers/*.xml</span></code></pre><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><p> <img src="/2022/04/19/Java/SpringBoot/mybatis/assets%5C1574088323996.png" alt="1574088323996"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>user对象参照课前资料，需要通用mapper的注解：</p><p><img src="/2022/04/19/Java/SpringBoot/mybatis/1540899330478.png" alt="1540899330478"></p><p>接下来，就去集成通用mapper。</p><h3 id="4-5-2-通用mapper"><a href="#4-5-2-通用mapper" class="headerlink" title="4.5.2.通用mapper"></a>4.5.2.通用mapper</h3><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 通用mapper --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>tk.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>不需要做任何配置就可以使用了。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">tk<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>common<span class="token punctuation">.</span>Mapper</span><span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot连接池</title>
      <link href="/2022/04/19/Java/SpringBoot/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2022/04/19/Java/SpringBoot/%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="4-4-整合连接池"><a href="#4-4-整合连接池" class="headerlink" title="4.4.整合连接池"></a>4.4.整合连接池</h2><p>jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><p><img src="/2022/04/19/Java/SpringBoot/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1528126755717.png" alt="1528126755717"></p><p>在pom.xml中引入jdbc的启动器：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--jdbc的启动器，默认使用HikariCP连接池--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src="/2022/04/19/Java/SpringBoot/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1528126862203.png" alt="1528126862203"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src="/assets/1525516441005.png" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 连接四大参数</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/test</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token comment" spellcheck="true"># 可省略，SpringBoot自动推断</span><span class="token attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.hikari.idle-timeout</span><span class="token punctuation">=</span><span class="token attr-value">60000</span><span class="token attr-name">spring.datasource.hikari.maximum-pool-size</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">spring.datasource.hikari.minimum-idle</span><span class="token punctuation">=</span><span class="token attr-value">10</span></code></pre><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Druid连接池 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#初始化连接数</span><span class="token attr-name">spring.datasource.druid.initial-size</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token comment" spellcheck="true">#最小空闲连接</span><span class="token attr-name">spring.datasource.druid.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token comment" spellcheck="true">#最大活动连接</span><span class="token attr-name">spring.datasource.druid.max-active</span><span class="token punctuation">=</span><span class="token attr-value">20</span><span class="token comment" spellcheck="true">#获取连接时测试是否可用</span><span class="token attr-name">spring.datasource.druid.test-on-borrow</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true">#监控页面启动</span><span class="token attr-name">spring.datasource.druid.stat-view-servlet.allow</span><span class="token punctuation">=</span><span class="token attr-value">true</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yml介绍</title>
      <link href="/2022/04/18/Java/SpringBoot/yml%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/04/18/Java/SpringBoot/yml%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h2><p>YAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 YAML 作为属性配置文件（以 .yml 或 .yaml 结尾），需要将 <code>SnakeYAML</code> 库添加到 classpath 下<br>Spring Boot 中的 spring-boot-starter-web 或 spring-boot-starter 都对 SnakeYAML 库做了集成， 只要项目中引用了这两个 Starter 中的任何一个，Spring Boot 会自动添加 SnakeYAML 库到 classpath 下</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>简单的 application.yml 属性配置文件。<br>server:<br>  port: 8081</p><h2 id="YAML-语法"><a href="#YAML-语法" class="headerlink" title="YAML 语法"></a>YAML 语法</h2><p>使用缩进表示层级关系。<br>缩进时不允许使用 Tab 键，只允许使用空格<br>缩进的空格数不重要，但同级元素必须左侧对齐<br>大小写敏感</p><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><pre class=" language-yml"><code class="language-yml">spring:  profiles: dev  datasource:    url: jdbc:mysql://127.0.01/banchengbang_springboot    username: root    password: root    driver-class-name: com.mysql.jdbc.Driver</code></pre><h2 id="YAML-常用写法"><a href="#YAML-常用写法" class="headerlink" title="YAML 常用写法"></a>YAML 常用写法</h2><p>YAML 支持以下三种数据结构：</p><ol><li>对象：键值对的集合</li><li>数组：一组按次序排列的值</li><li>字面量：单个的、不可拆分的值</li></ol><h3 id="YAML-字面量写法"><a href="#YAML-字面量写法" class="headerlink" title="YAML 字面量写法"></a>YAML 字面量写法</h3><p>字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。<br>在 YAML 中，使用“key:[空格]value”的形式表示一对键值对（空格不能省略），如 <code>url: www.biancheng.net</code><br>字面量直接写在键值对的“value”中即可，<code>且默认情况下字符串是不需要使用单引号或双引号的</code></p><ol><li><p>使用单引号，则会转义特殊字符。<br><code>name: &#39;zhangsan \n lisi&#39;</code><br>输出结果为：<br>zhangsan \n lisi</p></li><li><p>使用双引号，则不会转义特殊字符，特殊字符会输出为其本身想表达的含义<br><code>name: &quot;zhangsan \n lisi&quot;</code><br>输出结果为：<br>zhangsan<br>lisi</p></li></ol><h3 id="YAML-对象写法"><a href="#YAML-对象写法" class="headerlink" title="YAML 对象写法"></a>YAML 对象写法</h3><p>在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对;YAML 为对象提供了 2 种写法：</p><ol><li><p>普通写法，使用缩进表示对象与属性的层级关系。</p><pre class=" language-yml"><code class="language-yml">website: name: bianchengbangurl: www.biancheng.net</code></pre></li><li><p>行内写法：</p><pre class=" language-yml"><code class="language-yml">website: &#123;name: bianchengbang,url: www.biancheng.net&#125;</code></pre><h3 id="YAML-数组写法"><a href="#YAML-数组写法" class="headerlink" title="YAML 数组写法"></a>YAML 数组写法</h3><p>YAML 使用“-”表示数组中的元素</p></li><li><p>普通写法如下：<br>``` yml<br>pets:</p></li></ol><p>  -dog<br>  -cat<br>  -pig</p><pre><code>2. 行内写法``` ymlpets: [dog,cat,pig]</code></pre><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>以上三种数据结构可以任意组合使用，以实现不同的用户需求，例如：</p><pre class=" language-yml"><code class="language-yml">person:  name: zhangsan  age: 30  pets:    -dog    -cat    -pig  car:    name: QQ  child:    name: zhangxiaosan    age: 2</code></pre><h2 id="YAML-组织结构"><a href="#YAML-组织结构" class="headerlink" title="YAML 组织结构"></a>YAML 组织结构</h2><p>一个 YAML 文件可以由一个或多个文档组成，文档之间使用“—”作为分隔符，且个文档相互独立，互不干扰。<br>如果 YAML 文件只包含一个文档，则“—”分隔符可以省略。<br>多文档示例:</p><pre class=" language-yml"><code class="language-yml">---website:  name: bianchengbang  url: www.biancheng.net---website: &#123;name: bianchengbang,url: www.biancheng.net&#125;pets:  -dog  -cat  -pig---pets: [dog,cat,pig]name: "zhangsan \n lisi"---name: 'zhangsan \n lisi'</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot拦截器注入方式</title>
      <link href="/2022/04/18/Java/SpringBoot/starter%20%E5%90%AF%E5%8A%A8%E5%99%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/18/Java/SpringBoot/starter%20%E5%90%AF%E5%8A%A8%E5%99%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h2><p>Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器）<br>starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。</p><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些 starter 都遵循着约定成俗的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原则。</p><h2 id="个别第三方技术"><a href="#个别第三方技术" class="headerlink" title="个别第三方技术"></a>个别第三方技术</h2><p>有部分 starter 是第三方技术厂商提供的，例如 druid-spring-boot-starter 和 mybatis-spring-boot-starter 等等。当然也存在个别第三方技术，Spring Boot 官方没提供 starter，第三方技术厂商也没有提供 starter。<br>可，而不需要额外导入 Web 服务器和其他的 Web 依赖。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在 pom.xml 中引入 spring-boot-starter-web，示例代码如下。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--SpringBoot父项目依赖管理--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--导入 spring-boot-starter-web--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>在以上 pom.xml 的配置中，引入依赖 spring-boot-starter-web 时，并没有指明其版本（version），这些版本信息是由 spring-boot-starter-parent（版本仲裁中心） 统一控制的。</p><h2 id="spring-boot-starter-parent"><a href="#spring-boot-starter-parent" class="headerlink" title="spring-boot-starter-parent"></a>spring-boot-starter-parent</h2><p>spring-boot-starter-parent 是所有 Spring Boot 项目的父级依赖，它被称为 Spring Boot 的版本仲裁中心，可以对项目内的部分常用依赖进行统一管理。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--SpringBoot父项目依赖管理--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>Spring Boot 项目通过继承 spring-boot-starter-parent 来获得一些合理的默认配置，它主要提供了以下特性：<br>默认 JDK 版本（Java 8）<br>默认字符集（UTF-8）<br>依赖管理功能<br>资源过滤<br>默认插件配置<br>识别 application.properties 和 application.yml 类型的配置文件</p><p>查看 spring-boot-starter- parent 的底层代码，可以发现其有一个父级依赖 spring-boot-dependencies。<br><parent><br>    <groupId>org.springframework.boot</groupId><br>    <artifactId>spring-boot-dependencies</artifactId><br>    <version>2.4.5</version><br></parent></p><p>spring-boot-dependencies 的底层代码如下。<br><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><br>    <modelVersion>4.0.0</modelVersion><br>    <groupId>org.springframework.boot</groupId><br>    <artifactId>spring-boot-dependencies</artifactId><br>    <version>2.4.5</version><br>    <packaging>pom</packaging><br>    ….<br>    <properties><br>        &lt;activemq.version&gt;5.16.1&lt;/activemq.version&gt;<br>        &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;<br>        &lt;appengine-sdk.version&gt;1.9.88&lt;/appengine-sdk.version&gt;<br>        &lt;artemis.version&gt;2.15.0&lt;/artemis.version&gt;<br>        &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt;<br>        &lt;assertj.version&gt;3.18.1&lt;/assertj.version&gt;<br>        &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;<br>        ….<br>    </properties><br>    <dependencyManagement><br>        <dependencies><br>            <dependency><br>                <groupId>org.apache.activemq</groupId><br>                <artifactId>activemq-amqp</artifactId><br>                <version>${activemq.version}</version><br>            </dependency><br>            <dependency><br>                <groupId>org.apache.activemq</groupId><br>                <artifactId>activemq-blueprint</artifactId><br>                <version>${activemq.version}</version><br>            </dependency><br>            …<br>        </dependencies><br>    </dependencyManagement><br>    <build><br>        <pluginManagement><br>            <plugins><br>                <plugin><br>                    <groupId>org.codehaus.mojo</groupId><br>                    <artifactId>build-helper-maven-plugin</artifactId><br>                    <version>${build-helper-maven-plugin.version}</version><br>                </plugin><br>                <plugin><br>                    <groupId>org.flywaydb</groupId><br>                    <artifactId>flyway-maven-plugin</artifactId><br>                    <version>${flyway.version}</version><br>                </plugin><br>                …<br>            </plugins><br>        </pluginManagement><br>    </build><br></project></p><p>以上配置中，部分元素说明如下：</p><p>dependencyManagement ：负责管理依赖；<br>pluginManagement：负责管理插件；<br>properties：负责定义依赖或插件的版本号。</p><p>spring-boot-dependencies 通过 dependencyManagement 、pluginManagement 和 properties 等元素对一些常用技术框架的依赖或插件进行了统一版本管理，例如 Activemq、Spring、Tomcat 等</p><h2 id="常用启动器"><a href="#常用启动器" class="headerlink" title="常用启动器"></a>常用启动器</h2><ol><li>   Spring Boot application starters<br>spring-boot-starter-thymeleaf<br>使用Thymeleaf视图构建MVC Web应用程序</li></ol><p>spring-boot-starter-ws<br>使用Spring Web服务。1.4不推荐使用，推荐使用spring-boot-starter-web-services</p><p>spring-boot-starter-data-couchbase<br>Starter for using Couchbase document-oriented database and Spring Data Couchbase</p><p>spring-boot-starter-artemis<br>使用Apache Artemis启动JMS消息传递</p><p>spring-boot-starter-web-services<br>使用Spring Web服务</p><p>spring-boot-starter-mail<br>支持使用Java Mail和Spring Framework发送电子邮件</p><p>spring-boot-starter-data-redis<br>使用Redis键值数据存储与Spring Data Redis和Jedis客户端</p><p>spring-boot-starter-web<br>启动器构建web，包括RESTful，使用Spring MVC的应用程序。使用Tomcat作为默认嵌入式容器</p><p>spring-boot-starter-data-gemfire<br>Starter for using GemFire distributed data store and Spring Data GemFire</p><p>spring-boot-starter-activemq<br>使用Apache ActiveMQ启动JMS消息传递</p><p>spring-boot-starter-data-elasticsearch<br>使用Elasticsearch搜索和分析引擎和Spring Data Elasticsearch</p><p>spring-boot-starter-integration<br>Starter for using Spring Integration</p><p>spring-boot-starter-test<br>Spring Boot应用程序用于测试包括JUnit，Hamcrest和Mockito</p><p>spring-boot-starter-hornetq<br>使用HornetQ启动JMS消息传递。1.4已弃用，推荐使用spring-boot-starter-artemis</p><p>spring-boot-starter-jdbc<br>使用HikariCP连接池</p><p>spring-boot-starter-mobile<br>使用Spring Mobile构建Web应用程序的入门</p><p>spring-boot-starter-validation<br>使用Java Bean校验与Hibernate校验器</p><p>spring-boot-starter-hateoas<br>使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序的入门</p><p>spring-boot-starter-jersey<br>使用JAX-RS和Jersey构建RESTful Web应用程序的入门。 spring-boot-starter-web的替代品</p><p>spring-boot-starter-data-neo4j<br>使用Neo4j图数据库和Spring Data Neo4j</p><p>spring-boot-starter-websocket<br>使用Spring Framework的WebSocket支持构建WebSocket应用程序</p><p>spring-boot-starter-aop<br>使用Spring AOP和AspectJ进行面向方面编程</p><p>spring-boot-starter-amqp<br>使用Spring AMQP和Rabbit MQ的入门</p><p>spring-boot-starter-data-cassandra<br>使用Cassandra分布式数据库和Spring Data Cassandra</p><p>spring-boot-starter-social-facebook<br>使用Spring Social Facebook</p><p>spring-boot-starter-jta-atomikos<br>使用Atomikos进行JTA事务</p><p>spring-boot-starter-security<br>使用Spring Security</p><p>spring-boot-starter-mustache<br>使用Mustache视图构建MVC Web应用程序</p><p>spring-boot-starter-data-jpa<br>使用Spring Data JPA与Hibernate</p><p>spring-boot-starter<br>核心启动器，包括自动配置支持，日志记录和YAML</p><p>spring-boot-starter-velocity<br>使用Velocity视图构建MVC Web应用程序。1.4已弃用</p><p>spring-boot-starter-groovy-templates<br>使用Groovy模板视图构建MVC Web应用程序</p><p>spring-boot-starter-freemarker<br>使用FreeMarker视图构建MVC Web应用程序</p><p>spring-boot-starter-batch<br>使用Spring Batch</p><p>spring-boot-starter-redis<br>使用Redis键值数据存储与Spring Data Redis和Jedis客户端的入门。1.4已弃用，建议使用spring-boot-starter-data-redis</p><p>spring-boot-starter-social-linkedin<br>Stater for using Spring Social LinkedIn</p><p>spring-boot-starter-cache<br>支持使用Spring Framework的缓存</p><p>spring-boot-starter-data-solr<br>使用带有Spring Data Solr的Apache Solr搜索平台</p><p>spring-boot-starter-data-mongodb<br>使用MongoDB和Spring Data MongoDB</p><p>spring-boot-starter-jooq<br>使用jOOQ访问SQL数据库。 spring-boot-starter-data-jpa或spring-boot-starter-jdbc的替代方法</p><p>spring-boot-starter-jta-narayana<br>Spring Boot启动Narayana JTA</p><p>spring-boot-starter-cloud-connectors<br>启动者使用Spring Cloud连接器，简化了连接到云平台中的服务，如Cloud Foundry和Heroku</p><p>spring-boot-starter-jta-bitronix<br>使用Bitronix进行JTA事务</p><p>spring-boot-starter-social-twitter<br>使用Spring Social Twitter</p><p>spring-boot-starter-data-rest<br>使用Spring Data REST通过REST暴露Spring数据存储库</p><ol start="2"><li>   Spring Boot production starters<br>spring-boot-starter-actuator<br>使用Spring Boot的Actuator，提供生产就绪的功能，以帮助您监视和管理您的应用程序</li></ol><p>spring-boot-starter-remote-shell<br>使用CRaSH远程shell通过SSH监视和管理您的应用程序</p><ol start="3"><li>   Spring Boot technical starters<br>spring-boot-starter-undertow<br>使用Undertow作为嵌入式servlet容器。 spring-boot-starter-tomcat的替代方法</li></ol><p>spring-boot-starter-jetty<br>使用Jetty作为嵌入式servlet容器的。 spring-boot-starter-tomcat的替代方法</p><p>spring-boot-starter-logging<br>使用Logback进行日志记录。 默认日志启动器</p><p>spring-boot-starter-tomcat<br>使用Tomcat作为嵌入式servlet容器。 spring-boot-starter-web使用的默认servlet容器</p><p>spring-boot-starter-log4j2<br>使用Log4j2进行日志记录。 spring-boot-starter-logging的替代方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>application配置内容</title>
      <link href="/2022/04/18/Java/SpringBoot/application%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9/"/>
      <url>/2022/04/18/Java/SpringBoot/application%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringBoot 默认使用以下 2 种全局的配置文件，其文件名是固定的。<br><code>application.properties</code>或<code>application.yml</code></p><h2 id="yml介绍"><a href="#yml介绍" class="headerlink" title="yml介绍"></a>yml介绍</h2><p>application.yml 是一种使用 YAML 语言编写的文件，它与 application.properties 一样，可以在 Spring Boot 启动时被自动读取，修改 Spring Boot 自动配置的默认值。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>默认端口号为8080<br>server.port=<code>8848</code></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>logging.level.org.springframework=<code>debug</code></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>spring.datasource.url=<code>jdbc:mysql://localhost:8080/db1</code><br>spring.datasource.username=<code>root</code><br>spring.datasource.password=<code>root</code></p><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><p>SpringBoot没有整合mybatis;mybatis提供了SpringBoot的整合方式<br>mybatis.type-type-aliases-package=<code>com.dy.entity</code></p><h2 id="注入配置文件内容方式"><a href="#注入配置文件内容方式" class="headerlink" title="注入配置文件内容方式"></a>注入配置文件内容方式</h2><pre class=" language-Java"><code class="language-Java">@Value("server.port")private Integer port</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot拦截器注入方式</title>
      <link href="/2022/04/18/Java/SpringBoot/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/04/18/Java/SpringBoot/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>application.properties文件内容</p><pre class=" language-Properties"><code class="language-Properties">jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/db_testjdbc.username=rootjdbc.password=root</code></pre><p>JdbcProperties.java文件</p><pre class=" language-Java"><code class="language-Java">//  读取application.properties文件中前缀为jdbc的值按属性名赋值给当前类;需要提供get和set方法@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123;    private String url;    private String driverClassName;    private String username;    private String password;    //  省略get和set&#125;</code></pre><p>HelloController.java文件</p><pre class=" language-Java"><code class="language-Java">@RestControllerpublic class HelloController &#123;    @Autowired    private JdbcConfiguration jdbcConfiguration;    @GetMapping("hello")    public String test()&#123;           return "Hello";    &#125;&#125;</code></pre><p>Application.java启动类</p><pre class=" language-Java"><code class="language-Java">@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class,args);    &#125;&#125;</code></pre><h2 id="Autowired按照类型注入"><a href="#Autowired按照类型注入" class="headerlink" title="@Autowired按照类型注入"></a>@Autowired按照类型注入</h2><p>JdbcConfiguration.java文件</p><pre class=" language-Java"><code class="language-Java">@Configuration  //声明当前类为配置类@EnableConfigurationProperties(JdbcProperties.class)    //  读取的配置文件为JdbcProperties.classpublic class JdbcConfiguration &#123;    @Autowired    private JdbcProperties jdbcProperties;    @Bean    public DataSource dataSource() &#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(jdbcProperties.getUrl());        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());        dataSource.setUsername(jdbcProperties.getUsername());        dataSource.setPassword(jdbcProperties.getPassword());        return dataSource; //debug调试当前dataSource中有没有数据源配置    &#125;&#125;</code></pre><h2 id="按照构造方法注入"><a href="#按照构造方法注入" class="headerlink" title="按照构造方法注入"></a>按照构造方法注入</h2><p>JdbcConfiguration.java文件</p><pre class=" language-Java"><code class="language-Java">@Configuration  //声明当前类为配置类@EnableConfigurationProperties(JdbcProperties.class)    //  读取的配置文件为JdbcProperties.classpublic class JdbcConfiguration &#123;        private JdbcProperties jdbcProperties;    public JdbcConfiguration(JdbcProperties jdbcProperties) &#123;        this.jdbcProperties = jdbcProperties;    &#125;    @Bean    public DataSource dataSource() &#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(jdbcProperties.getUrl());        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());        dataSource.setUsername(jdbcProperties.getUsername());        dataSource.setPassword(jdbcProperties.getPassword());        return dataSource;  //debug调试当前dataSource中有没有数据源配置    &#125;&#125;</code></pre><h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><pre class=" language-Java"><code class="language-Java">@Configuration  //声明当前类为配置类@EnableConfigurationProperties(JdbcProperties.class)    //  读取的配置文件为JdbcProperties.classpublic class JdbcConfiguration &#123;    @Bean    public DataSource dataSource(JdbcProperties jdbcProperties) &#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(jdbcProperties.getUrl());        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());        dataSource.setUsername(jdbcProperties.getUsername());        dataSource.setPassword(jdbcProperties.getPassword());        return dataSource;//debug调试当前dataSource中有没有数据源配置    &#125;&#125;</code></pre><h2 id="按照ConfigurationProperties注入"><a href="#按照ConfigurationProperties注入" class="headerlink" title="按照ConfigurationProperties注入"></a>按照ConfigurationProperties注入</h2><pre class=" language-Java"><code class="language-Java"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot拦截器</title>
      <link href="/2022/04/18/Java/SpringBoot/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/04/18/Java/SpringBoot/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><p>通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置</p><p>定义拦截器</p><pre class=" language-Java"><code class="language-Java">/** * 定义一个拦截器 * * @author zrh * @date 2022/4/18 * @apiNote */@Componentpublic class MyInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println("preHandle method is running!");        //  返回true表示放行;返回false表示拦截        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println("postHandle method is running!");    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println("afterCompletion method is running!");    &#125;&#125;</code></pre><p>定义配置类</p><pre class=" language-Java"><code class="language-Java">/** * * 定义配置类，注册拦截器 * @author zrh * @date 2022/4/18 * @apiNote */@Configurationpublic class WebConfiguration implements WebMvcConfigurer &#123;    //让Spring注入自定义的拦截类    @Autowired    private HandlerInterceptor myInterceptor;    /**     * 重写接口中的addInterceptors方法，添加自定义的拦截器类     * @param registry     */    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //  addPathPatterns表示拦截的资源路径        registry.addInterceptor(myInterceptor).addPathPatterns("/**");    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot访问静态资源</title>
      <link href="/2022/04/18/Java/SpringBoot/%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
      <url>/2022/04/18/Java/SpringBoot/%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>SprintBoot没有WEB-INFO或WEB-ROOT目录,<br>SprintBoot的静态资源默认访问resource下的<code>static</code>目录<br>所以静态资源存在resource下的static目录中才可访问</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot注解</title>
      <link href="/2022/04/18/Java/SpringBoot/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/04/18/Java/SpringBoot/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>开启自动化配置</p><h2 id="ConfigurationProperties-prefiex-”jdbc”"><a href="#ConfigurationProperties-prefiex-”jdbc”" class="headerlink" title="@ConfigurationProperties(prefiex=”jdbc”)"></a>@ConfigurationProperties(prefiex=”jdbc”)</h2><p>加载默认的配置文件  application.properties<br>读取其中前缀为jdbc的属性;并按照属性名进行赋值</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">jdbc.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">jdbc.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/db_test</span><span class="token attr-name">jdbc.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">jdbc.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span></code></pre><pre class=" language-Java"><code class="language-Java">@ConfigurationProperties(prefix = "jdbc")public class JdbcConfiguration &#123;    private String url;    private String driverClassName;    private String username;    private String password;    // ... 略    // getters 和 setters&#125;</code></pre><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>用来声明当前类是SpringBoot应用的配置类，项目中只能有一个。一般无需自己添加</p><h2 id="组合注解"><a href="#组合注解" class="headerlink" title="组合注解"></a>组合注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>相当于SpringBoot中的@EnableAutoConfiguration和Spring中的@ComponentScan</p><h2 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot简介</title>
      <link href="/2022/04/18/Java/SpringBoot/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/18/Java/SpringBoot/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了简化 Spring 应用的搭建和开发过程，Spring Boot在 Spring 的基础上诞生<br>Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。</p><p>Spring Boot 提供了大量开箱即用（out-of-the-box）的依赖模块，例如 spring-boot-starter-redis、spring-boot-starter-data-mongodb 和 spring-boot-starter-data-elasticsearch 等。这些依赖模块为 Spring Boot 应用提供了大量的自动配置，使得 Spring Boot 应用只需要非常少量的配置甚至零配置，便可以运行起来，让开发人员从 Spring 的“配置地狱”中解放出来，有更多的精力专注于业务逻辑的开发。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>独立运行的 Spring 项目<br>Spring Boot 可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令“ java–jar xx.jar” 即可运行。</li><li>内嵌 Servlet 容器<br>Spring Boot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertow 等），应用无需打成 WAR 包 。</li><li>提供 starter 简化 Maven 配置<br>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</li><li>提供了大量的自动配置<br>Spring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</li><li>自带应用监控<br>Spring Boot 可以对正在运行的项目提供监控。</li><li>无代码生成和 xml 配置<br>Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。</li></ol><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>约定大于配置,省略ssm中繁杂的配置信息<br>只需配置application.properties或application.yml</p><h2 id="搭建-Spring-Boot-项目"><a href="#搭建-Spring-Boot-项目" class="headerlink" title="搭建 Spring Boot 项目"></a>搭建 Spring Boot 项目</h2><ol><li>新建 Maven 项目</li><li>在该 Maven 项目的 pom.xml 中添加以下配置，导入 Spring Boot 相关的依赖<br>``` xml<parent><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-parent</artifactId><version>2.4.5</version></parent></li></ol><dependencies>  <dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-web</artifactId>  </dependency>  <dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-test</artifactId>    <scope>test</scope>  </dependency></dependencies>```3. 在 xxx.xxx.xxx 包下，创建一个名为 helloWorldApplication 主程序，用来启动 Spring Boot 应用，代码如下``` Java@SpringBootApplicationpublic class helloWorldApplication {    public static void main(String[] args) {        SpringApplication.run(helloWorldApplication.class, args);    }}```4. 启动测试run运行helloWorldApplication的main方法即可控制台输出`Completed initialization in .. ms`即为搭建成功<h2 id="快速创建-Spring-Boot-项目"><a href="#快速创建-Spring-Boot-项目" class="headerlink" title="快速创建 Spring Boot 项目"></a>快速创建 Spring Boot 项目</h2><ol><li> New Project</li><li>在新建工程界面左侧，选择 Spring Initializr，选择项目的 SDK 为 1.8，选择 starter service URL 为 <a href="http://start.spring.io(默认),最后点击下方的/">http://start.spring.io（默认），最后点击下方的</a> Next 按钮</li><li>IDEA 会连接网络，并根据 starter service URL 查询 Spring Boot 的当前可用版本和组件列表</li><li>在 Spring Initializr Project Settings 中，输入项目的 GroupId、ArtifactId 等内容，注意 Type 为 Maven，packaging 为 jar，Java version 切换为 8（默认为 11），最后点击下方的 Next 按钮</li><li>在 dependencise 界面中，选择 Spring Boot 的版本及所依赖的 Spring Boot 组件（例如 Spring Boot 的版本为 2.4.5， Spring Boot 组件为 Web），然后点击下方的 Next 按钮</li><li>根据需要修改项目名称及项目存储位置等信息，最后点击 Finish 按钮，完成 Spring Boot 项目的创建</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架面试题</title>
      <link href="/2022/04/18/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/18/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC和SpringBoot的区别"><a href="#SpringMVC和SpringBoot的区别" class="headerlink" title="SpringMVC和SpringBoot的区别"></a>SpringMVC和SpringBoot的区别</h2><p>SpringBoot包含了Spring和SpringMVC;是它们两个的升级版</p><h2 id="SpringBoot的核心注解"><a href="#SpringBoot的核心注解" class="headerlink" title="SpringBoot的核心注解"></a>SpringBoot的核心注解</h2><p>@EnableAutoConfiguration<br>开启自动化配置<br>@SpringBootConfiguration<br>用来声明当前类是SpringBoot应用的配置类，项目中只能有一个<br>@SpringBootApplication<br>相当于SpringBoot中的@EnableAutoConfiguration和Spring中的@ComponentScan</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/18/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/18/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2022/04/14/Java/SSM/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/04/14/Java/SSM/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>日期时间类型转换<br>@DateTimeFormat(pattern = “yyyy-MM-dd”)<br>包:<code>org.springframework.format.annotation.DateTimeFormat;</code><br>作用:接收pattern格式的字符串<code>&lt;input type=&quot;date&quot;&gt;</code>转为date类型的数据<br>@JsonFormat(pattern = “yyyy-MM-dd”)<br>包:<code>com.fasterxml.jackson.annotation.JsonFormat;</code><br>作用:将date类型的数据转为pattern格式的字符串返回前端<br>例:</p><pre class=" language-Java"><code class="language-Java">public class Book &#123;    private Integer id;    private Integer categoryId;    private String name;    private Double price;    private Category category;    @DateTimeFormat(pattern = "yyyy-MM-dd")    @JsonFormat(pattern = "yyyy-MM-dd")    private Date updateDate;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/Tomcat/"/>
      <url>/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/Tomcat/</url>
      
        <content type="html"><![CDATA[<p>17.2安装tomcat服务器<br>17.2.1拖拽apache-tomcat-7.0.47.tar.gz文件到linux目录下</p><p>17.2.2解压文件<br>输入命令：[root@localhost ~]# tar -zvxf apache-tomcat-7.0.47.tar.gz</p><p>17.2.3启动tomcat<br>[root@localhost apache-tomcat-7.0.47]# ./bin/startup.sh<br>17.2.4查看tomcat启动日志<br>[root@localhost apache-tomcat-7.0.47]# tail -f logs/catalina.out</p><p>18.防火墙<br>因为linux系统默认的对外开发的端口号是22,  tomcat的端口号是8080,所以不能访问</p><p>1.关闭防火墙<br>[root@localhost ~]# service iptables stop;<br>下次重启linux系统后,防火墙又会自动开启.<br>[root@localhost ~]# chkconfig iptables –list<br>关闭所有的端口<br>[root@localhost ~]# chkconfig iptables off</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/Java/"/>
      <url>/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/Java/</url>
      
        <content type="html"><![CDATA[<p>17.1安装java环境JDK</p><p>17.1.1上传JDK压缩包</p><p>17.1.2创建java目录<br>[root@localhost /]# mkdir /usr/java</p><p>17.1.3解压文件到新建的java目录<br>[root@localhost /]# tar -xzvf jdk-7u55-linux-i586.tar.gz -C /usr/java/</p><p>17.1.4配置环境变量<br>[root@localhost /]# vim /etc/profile</p><p>编辑文件里的使用命令：<br>1）输入环境变量 JAVA_HOME=/usr/java/jdk1.7.0_55/</p><p>3）添加命令 export  PATH=$JAVA_HOME/bin:$PATH</p><p>4）保存文件   :wq!</p><p>5）重新加载 文件  source  /etc/profile</p><p>6）验证是否安装成功   java -version</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/MySQL/"/>
      <url>/2022/04/14/%E7%B3%BB%E7%BB%9F/Linux/MySQL/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件架构简介</title>
      <link href="/2022/04/14/Java/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/14/Java/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单一系统架构"><a href="#单一系统架构" class="headerlink" title="单一系统架构"></a>单一系统架构</h2><p>缺点:<br>  单点故障:只要一处出错,造成整个系统崩溃<br>  并发量低:同时在线人数(400-600)<br>  代码耦合度高:代码中类与类之间的依赖度太高<br>优点:<br>  维护方便</p><h3 id="在单一系统架构上做水平拆分"><a href="#在单一系统架构上做水平拆分" class="headerlink" title="在单一系统架构上做水平拆分"></a>在单一系统架构上做水平拆分</h3><p>Web框架(MVC)<br>分为web视图层,service业务层,dao数据层<br>优点:<br>  分工明确<br>缺点:<br>  与单一架构一致</p><h2 id="在单一系统架构上做垂直拆分"><a href="#在单一系统架构上做垂直拆分" class="headerlink" title="在单一系统架构上做垂直拆分"></a>在单一系统架构上做垂直拆分</h2><p>按照功能模块拆分为多个项目<br>优点:<br>  并发量高<br>  不存在单点故障<br>  代码耦合度低<br>  方便单独优化<br>  方便水平扩展<br>缺点:<br>  拆分为多个项目,维护成本增加<br>  重复功能开发</p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><h2 id="SOA架构-面向服务的架构"><a href="#SOA架构-面向服务的架构" class="headerlink" title="SOA架构 面向服务的架构"></a>SOA架构 面向服务的架构</h2><p>在分布式架构的基础上新增注册中心<br>注册中心作用:<br>  注册服务者<br>  注册消费者</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>在单独模块中再次拆分项目的方式就可以称之为微服务架构，微服务架构也是分布式架构</p><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别：</p><p>微服务的特点：</p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><h2 id="服务调用方式"><a href="#服务调用方式" class="headerlink" title="服务调用方式"></a>服务调用方式</h2><p>分为RPC和HTTP两种通讯方式</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。Rest风格通过http协议来实现</p></li></ul><h3 id="Dubbo-RPC"><a href="#Dubbo-RPC" class="headerlink" title="Dubbo RPC"></a>Dubbo RPC</h3><p>优点:快,支持大量数据的通讯<br>缺点:</p><h3 id="SpringCloud-HTTP"><a href="#SpringCloud-HTTP" class="headerlink" title="SpringCloud HTTP"></a>SpringCloud HTTP</h3><p>优点:<br>缺点:</p>]]></content>
      
      
      <categories>
          
          <category> 软件架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/04/14/Java/dubbo/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/14/Java/dubbo/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-RPC"><a href="#前言-RPC" class="headerlink" title="前言(RPC)"></a>前言(RPC)</h2><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式<br>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节</p><p>RPC基本原理<br><img src="/2022/04/14/Java/dubbo/%E7%AE%80%E4%BB%8B/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"><br>RPC通信及序列化<br><img src="/2022/04/14/Java/dubbo/%E7%AE%80%E4%BB%8B/%E9%80%9A%E4%BF%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96.png"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简介<br>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现<br>官网：<a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a><br>Dubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>服务提供者（Provider）：服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。<br>服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者<br>监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><h2 id="dubbo通信流程"><a href="#dubbo通信流程" class="headerlink" title="dubbo通信流程"></a>dubbo通信流程</h2><p><img src="/2022/04/14/Java/dubbo/%E7%AE%80%E4%BB%8B/dubbo%E9%80%9A%E4%BF%A1.png"><br>调用关系说明<br>服务容器负责启动，加载，运行服务提供者。<br>服务提供者在启动时，向注册中心注册自己提供的服务。<br>服务消费者在启动时，向注册中心订阅自己所需的服务。<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p><h2 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h2><p>dubbo官方推荐使用 zookeeper 注册中心。<br>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。<br>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/13/Java/echarts/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/13/Java/echarts/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/12/Java/MybatisPlus/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2022/04/12/Java/MybatisPlus/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/12/Java/MybatisPlus/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2022/04/12/Java/MybatisPlus/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2022/04/12/Java/MybatisPlus/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/04/12/Java/MybatisPlus/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具类</title>
      <link href="/2022/04/10/Java/Spring/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/04/10/Java/Spring/%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>求你别自己瞎写工具类了，Spring自带的这些他不香麽？<br>一行Java 2022-04-02 09:05<br>图片<br>在日常的开发过程中，我们会将一些和业务无关，但通用性又比较强的代码封装成一个工具类、来提高代码的复用性，增加业务功能的开发效率；</p><p>但其实，很多工具类，常用的框架都已经帮我们提供了，不需要自行再去封装，只是我们不知道而已；下面就一起来看看Spring给我们提供的那些优秀工具类</p><p>断言<br>断言是一个逻辑判断，用于检查不应该发生的情况<br>Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启<br>SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查<br>// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行  </p><p>// 参数 message 参数用于定制异常信息。<br>void notNull(Object object, String message)  </p><p>// 要求参数必须空（Null），否则抛出异常，不予『放行』。<br>// 和 notNull() 方法断言规则相反<br>void isNull(Object object, String message)  </p><p>// 要求参数必须为真（True），否则抛出异常，不予『放行』。<br>void isTrue(boolean expression, String message)  </p><p>// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行<br>void notEmpty(Collection collection, String message)  </p><p>// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行<br>void hasLength(String text, String message)  </p><p>// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行<br>void hasText(String text, String message)  </p><p>// 要求参数是指定类型的实例，否则抛出异常，不予放行<br>void isInstanceOf(Class type, Object obj, String message)  </p><p>// 要求参数 <code>subType</code> 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行<br>void isAssignable(Class superType, Class subType, String message)  </p><p>对象、数组、集合<br>ObjectUtils<br>获取对象的基本信息</p><p>// 获取对象的类名。参数为 null 时，返回字符串：”null”<br>String nullSafeClassName(Object obj)<br>// 参数为 null 时，返回 0<br>int nullSafeHashCode(Object object)<br>// 参数为 null 时，返回字符串：”null”<br>String nullSafeToString(boolean[] array)<br>// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0<br>String getIdentityHexString(Object obj)<br>// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：””<br>String identityToString(Object obj)<br>// 相当于 toString()方法，但参数为 null 时，返回字符串：””<br>String getDisplayString(Object obj)<br>判断工具</p><p>// 判断数组是否为空<br>boolean isEmpty(Object[] array)<br>// 判断参数对象是否是数组<br>boolean isArray(Object obj)<br>// 判断数组中是否包含指定元素<br>boolean containsElement(Object[] array, Object element)<br>// 相等，或同为 null时，返回 true<br>boolean nullSafeEquals(Object o1, Object o2)<br>/*<br>判断参数对象是否为空，判断标准为：<br>   Optional: Optional.empty()<br>      Array: length == 0<br>CharSequence: length == 0<br> Collection: Collection.isEmpty()<br>        Map: Map.isEmpty()<br>*/<br>boolean isEmpty(Object obj)<br>其他工具方法</p><p>// 向参数数组的末尾追加新元素，并返回一个新数组<br>&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)<br>// 原生基础类型数组 –&gt; 包装类数组<br>Object[] toObjectArray(Object source)<br>StringUtils<br>StringUtils<br>字符串判断工具</p><p>// 判断字符串是否为 null，或 “”。注意，包含空白符的字符串为非空<br>boolean isEmpty(Object str)<br>// 判断字符串是否是以指定内容结束。忽略大小写<br>boolean endsWithIgnoreCase(String str, String suffix)<br>// 判断字符串是否已指定内容开头。忽略大小写<br>boolean startsWithIgnoreCase(String str, String prefix)<br>// 是否包含空白符<br>boolean containsWhitespace(String str)<br>// 判断字符串非空且长度不为 0，即，Not Empty<br>boolean hasLength(CharSequence str)<br>// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank<br>boolean hasText(CharSequence str)<br>// 判断字符串指定索引处是否包含一个子串。<br>boolean substringMatch(CharSequence str, int index, CharSequence substring)<br>// 计算一个字符串中指定子串的出现次数<br>int countOccurrencesOf(String str, String sub)<br>字符串操作工具</p><p>// 查找并替换指定子串<br>String replace(String inString, String oldPattern, String newPattern)<br>// 去除尾部的特定字符<br>String trimTrailingCharacter(String str, char trailingCharacter)<br>// 去除头部的特定字符<br>String trimLeadingCharacter(String str, char leadingCharacter)<br>// 去除头部的空白符<br>String trimLeadingWhitespace(String str)<br>// 去除头部的空白符<br>String trimTrailingWhitespace(String str)<br>// 去除头部和尾部的空白符<br>String trimWhitespace(String str)<br>// 删除开头、结尾和中间的空白符<br>String trimAllWhitespace(String str)<br>// 删除指定子串<br>String delete(String inString, String pattern)<br>// 删除指定字符（可以是多个）<br>String deleteAny(String inString, String charsToDelete)<br>// 对数组的每一项执行 trim() 方法<br>String[] trimArrayElements(String[] array)<br>// 将 URL 字符串进行解码<br>String uriDecode(String source, Charset charset)<br>路径相关工具方法</p><p>// 解析路径字符串，优化其中的 “..”<br>String cleanPath(String path)<br>// 解析路径字符串，解析出文件名部分<br>String getFilename(String path)<br>// 解析路径字符串，解析出文件后缀名<br>String getFilenameExtension(String path)<br>// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..”<br>boolean pathEquals(String path1, String path2)<br>// 删除文件路径名中的后缀部分<br>String stripFilenameExtension(String path)<br>// 以 “. 作为分隔符，获取其最后一部分<br>String unqualify(String qualifiedName)<br>// 以指定字符作为分隔符，获取其最后一部分<br>String unqualify(String qualifiedName, char separator)<br>CollectionUtils<br>集合判断工具</p><p>// 判断 List/Set 是否为空<br>boolean isEmpty(Collection<?> collection)  // 判断 Map 是否为空  boolean isEmpty(Map<?,?> map)<br>// 判断 List/Set 中是否包含某个对象<br>boolean containsInstance(Collection<?> collection, Object element)  // 以迭代器的方式，判断 List/Set 中是否包含某个对象  boolean contains(Iterator<?> iterator, Object element)<br>// 判断 List/Set 是否包含某些对象中的任意一个<br>boolean containsAny(Collection<?> source, Collection<?> candidates)<br>// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素<br>boolean hasUniqueObject(Collection&lt;?&gt; collection)<br>集合操作工具</p><p>// 将 Array 中的元素都添加到 List/Set 中<br><E> void mergeArrayIntoCollection(Object array, Collection<E> collection)<br>// 将 Properties 中的键值对都添加到 Map 中<br>&lt;K,V&gt; void mergePropertiesIntoMap(Properties props, Map&lt;K,V&gt; map)<br>// 返回 List 中最后一个元素<br><T> T lastElement(List<T> list)<br>// 返回 Set 中最后一个元素<br><T> T lastElement(Set<T> set)<br>// 返回参数 candidates 中第一个存在于参数 source 中的元素<br><E> E findFirstMatch(Collection<?> source, Collection<E> candidates)  // 返回 List/Set 中指定类型的元素。  <T> T findValueOfType(Collection<?> collection, Class<T> type)<br>// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推<br>Object findValueOfType(Collection<?> collection, Class<?>[] types)<br>// 返回 List/Set 中元素的类型<br>Class<?> findCommonElementType(Collection<?> collection)<br>文件、资源、IO 流<br>FileCopyUtils<br>输入</T></T></E></E></T></T></T></T></E></E></p><p>// 从文件中读入到字节数组中<br>byte[] copyToByteArray(File in)<br>// 从输入流中读入到字节数组中<br>byte[] copyToByteArray(InputStream in)<br>// 从输入流中读入到字符串中<br>String copyToString(Reader in)<br>输出</p><p>// 从字节数组到文件<br>void copy(byte[] in, File out)<br>// 从文件到文件<br>int copy(File in, File out)<br>// 从字节数组到输出流<br>void copy(byte[] in, OutputStream out)<br>// 从输入流到输出流<br>int copy(InputStream in, OutputStream out)<br>// 从输入流到输出流<br>int copy(Reader in, Writer out)<br>// 从字符串到输出流<br>void copy(String in, Writer out)<br>ResourceUtils<br>从资源路径获取文件</p><p>// 判断字符串是否是一个合法的 URL 字符串。<br>static boolean isUrl(String resourceLocation)<br>// 获取 URL<br>static URL getURL(String resourceLocation)<br>// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）<br>static File getFile(String resourceLocation)<br>Resource</p><p>// 文件系统资源 D:...<br>FileSystemResource<br>// URL 资源，如 file://… http://…<br>UrlResource<br>// 类路径下的资源，classpth:…<br>ClassPathResource<br>// Web 容器上下文中的资源（jar 包、war 包）<br>ServletContextResource<br>// 判断资源是否存在<br>boolean exists()<br>// 从资源中获得 File 对象<br>File getFile()<br>// 从资源中获得 URI 对象<br>URI getURI()<br>// 从资源中获得 URI 对象<br>URL getURL()<br>// 获得资源的 InputStream<br>InputStream getInputStream()<br>// 获得资源的描述信息<br>String getDescription()<br>StreamUtils<br>输入</p><p>void copy(byte[] in, OutputStream out)<br>int copy(InputStream in, OutputStream out)<br>void copy(String in, Charset charset, OutputStream out)<br>long copyRange(InputStream in, OutputStream out, long start, long end)<br>输出</p><p>byte[] copyToByteArray(InputStream in)<br>String copyToString(InputStream in, Charset charset)<br>// 舍弃输入流中的内容<br>int drain(InputStream in)<br>反射、AOP<br>ReflectionUtils<br>获取方法</p><p>// 在类中查找指定方法<br>Method findMethod(Class<?> clazz, String name)   // 同上，额外提供方法参数类型作查找条件  Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)   // 获得类中所有方法，包括继承而来的  Method[] getAllDeclaredMethods(Class<?> leafClass)<br>// 在类中查找指定构造方法<br>Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)   // 是否是 equals() 方法  boolean isEqualsMethod(Method method)   // 是否是 hashCode() 方法   boolean isHashCodeMethod(Method method)   // 是否是 toString() 方法  boolean isToStringMethod(Method method)   // 是否是从 Object 类继承而来的方法  boolean isObjectMethod(Method method)   // 检查一个方法是否声明抛出指定异常  boolean declaresException(Method method, Class<?> exceptionType)<br>执行方法</T></T></p><p>// 执行方法<br>Object invokeMethod(Method method, Object target)<br>// 同上，提供方法参数<br>Object invokeMethod(Method method, Object target, Object… args)<br>// 取消 Java 权限检查。以便后续执行该私有方法<br>void makeAccessible(Method method)<br>// 取消 Java 权限检查。以便后续执行私有构造方法<br>void makeAccessible(Constructor&lt;?&gt; ctor)<br>获取字段</p><p>// 在类中查找指定属性<br>Field findField(Class<?> clazz, String name)   // 同上，多提供了属性的类型  Field findField(Class<?> clazz, String name, Class&lt;?&gt; type)<br>// 是否为一个 “public static final” 属性<br>boolean isPublicStaticFinal(Field field)<br>设置字段</p><p>// 获取 target 对象的 field 属性值<br>Object getField(Field field, Object target)<br>// 设置 target 对象的 field 属性值，值为 value<br>void setField(Field field, Object target, Object value)<br>// 同类对象属性对等赋值<br>void shallowCopyFieldState(Object src, Object dest)<br>// 取消 Java 的权限控制检查。以便后续读写该私有属性<br>void makeAccessible(Field field)<br>// 对类的每个属性执行 callback<br>void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc)   // 同上，多了个属性过滤功能。  void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc,<br>                 ReflectionUtils.FieldFilter ff)<br>// 同上，但不包括继承而来的属性<br>void doWithLocalFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)<br>AopUtils<br>判断代理类型</p><p>// 判断是不是 Spring 代理对象<br>boolean isAopProxy()<br>// 判断是不是 jdk 动态代理对象<br>isJdkDynamicProxy()<br>// 判断是不是 CGLIB 代理对象<br>boolean isCglibProxy()<br>获取被代理对象的 class</p><p>// 获取被代理的目标 class<br>Class&lt;?&gt; getTargetClass()<br>AopContext<br>获取当前对象的代理对象</p><p>Object currentProxy()<br>来源：CadeCode | juejin.cn/post/</p><p>7043403364020781064</p><p>最新2T+免费Java视频学习资料点击领取&gt;&gt;</p><p>END</p><p>精品资料，超赞福利，免费领</p><p>微信扫码/长按识别 添加【技术交流群】<br>群内每天分享精品学习资料<br>图片</p><p>图片</p><p>最近开发整理了一个用于速刷面试题的小程序《面试手册》【点击使用】；其中收录了上千道常见面试题及答案(包含基础、并发、JVM、MySQL、Redis、Spring、SpringMVC、SpringBoot、SpringCloud、消息队列等多个类型)，欢迎您的使用。</p><p>图片<br>还在 kill -9 杀进程？这才是SpringBoot优雅停机姿势！<br>判了！程序员接私活被公司开除…<br>接口回的 Long 值，竟然被”偷”了<br>生于俄罗斯的 Nginx，现宣布禁止俄罗斯贡献！呵呵…<br>答应我， 不要再用 if (obj != null) 判空了<br>程序员专属导航站（baoboxs.com）,一站式工作、学习、娱乐！<br>👇👇<br>👇点击”阅读原文”，获取更多资料（持续更新中）<br>阅读原文<br>阅读 3870</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插件</title>
      <link href="/2022/04/08/Java/MybatisPlus/%E6%8F%92%E4%BB%B6/"/>
      <url>/2022/04/08/Java/MybatisPlus/%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><p>使用插件可以为</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/04/08/Java/MybatisPlus/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/08/Java/MybatisPlus/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具<br>官网:<a href="https://baomidou.com/">https://baomidou.com/</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>Mybatis<br>Spring<br>Maven</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在 MyBatis 的基础上<code>**只做增强不做改变，为简化开发、提高效率而生**</code></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="maven的配置"><a href="#maven的配置" class="headerlink" title="maven的配置"></a>maven的配置</h3><p>pom.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- mp 依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--junit --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- log4j --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- c3p0 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.mchange<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- mysql --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.37<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- spring --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.3.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-orm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.3.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>注意: <code>Mybatis 及 Mybatis-Spring 依赖请勿加入项目配置，以免引起版本冲突！！！ Mybatis-Plus 会自动帮你维护！</code></p><h3 id="mybatis的配置"><a href="#mybatis的配置" class="headerlink" title="mybatis的配置"></a>mybatis的配置</h3><p>mybatis-config.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h3 id="log4j的配置"><a href="#log4j的配置" class="headerlink" title="log4j的配置"></a>log4j的配置</h3><p>log4j.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">log4j:</span>configuration</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>log4j</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://jakarta.apache.org/log4j/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.log4j.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Encoding<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.log4j.PatternLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ConversionPattern<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>%-5p %d&amp;#123;MM-dd HH:mm:ss,SSS&amp;#125; %m (%F:%L) \n<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.sql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debug<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.ibatis<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debug<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">log4j:</span>configuration</span><span class="token punctuation">></span></span></code></pre><h3 id="数据源的连接配置"><a href="#数据源的连接配置" class="headerlink" title="数据源的连接配置"></a>数据源的连接配置</h3><p>db.properties </p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">jdbc.driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">jdbc.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/mp</span><span class="token attr-name">jdbc.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">jdbc.password</span><span class="token punctuation">=</span><span class="token attr-value">1234</span></code></pre><h3 id="spring-的配置"><a href="#spring-的配置" class="headerlink" title="spring 的配置"></a>spring 的配置</h3><p>applicationContext.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>mybatis-spring</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://mybatis.org/schema/mybatis-spring<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsdhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 数据源 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;jdbc.driver&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;jdbc.url&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;jdbc.username&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;jdbc.password&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 事务管理器 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSourceTransactionManager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 基于注解的事务管理 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span>  <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 配置 SqlSessionFactoryBean --></span>  <span class="token comment" spellcheck="true">&lt;!-- 使用MybatisPlus只需将这里的class换为 class="com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean" 即可 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactoryBean<span class="token punctuation">"</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数据源 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>configLocation<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:mybatis-config.xml<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 别名处理 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>typeAliasesPackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.mp.beans<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 配置 mybatis 扫描 mapper 接口的路径 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.mp.mapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>基础:<br>mysql</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 创建库</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> mp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 使用库</span><span class="token keyword">USE</span> mp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 创建表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tab_employee<span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>last_name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">`</span>email<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">`</span>gender<span class="token punctuation">`</span> <span class="token keyword">TINYINT</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token keyword">TINYINT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tab_employee<span class="token punctuation">(</span>last_name<span class="token punctuation">,</span>email<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span><span class="token string">'tom@163.com'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tab_employee<span class="token punctuation">(</span>last_name<span class="token punctuation">,</span>email<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'Jerry'</span><span class="token punctuation">,</span><span class="token string">'jerry@163.com'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tab_employee<span class="token punctuation">(</span>last_name<span class="token punctuation">,</span>email<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'Black'</span><span class="token punctuation">,</span><span class="token string">'black@163.com'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> </code></pre><p>Employee.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer id <span class="token punctuation">;</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String email <span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer gender <span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age <span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>EmployeeService.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmployeeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Integer <span class="token function">insert</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer <span class="token function">deleteById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer <span class="token function">updateById</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    Employee <span class="token function">selectById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>Wrapper<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>EmployeeServiceImpl.java</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">"employeeService"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmployeeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">EmployeeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> EmployeeMapper employeeMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">insert</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> employeeMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">deleteById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> employeeMapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">updateById</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> employeeMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Employee <span class="token function">selectById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>Wrapper<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employee<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>需要xxxMapper 继承 BaseMapper<T>, BaseMapper 中提供了通用的 CRUD 方法<br>T为对应的实体类<br>例:<br>mapper</T></p><pre class=" language-Java"><code class="language-Java">public interface EmployeeMapper extends BaseMapper<Employee> &#123;&#125;</code></pre><h2 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper<T></T></h2><p>包:<code>com.baomidou.mybatisplus.mapper.BaseMapper</code><br>类型:接口<br>作用:提供了一些通用的CRUD方法<br>T : 对应的实体类</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><ol><li>Integer insert(T entity);</li><li>@TableName</li><li>全局的 MP 配置: <property name="tablePrefix" value="tbl_"></property></li><li>@TableField</li><li>全局的 MP 配置: <property name="dbColumnUnderline" value="true"></property></li><li>@TableId</li><li>全局的 MP 配置: <property name="idType" value="0"></property></li><li>支持主键自增的数据库插入数据获取主键值<br>Mybatis: 需要通过 useGeneratedKeys 以及 keyProperty 来设置<br>MP: 自动将主键值回写到实体类中</li><li>Integer insertAllColumn(T entity)<br>————————————————————————————<br>—<h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2></li><li>Integer updateById(@Param(“et”) T entity);</li><li>Integer updateAllColumnById(@Param(“et”) T entity)</li></ol><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><ol><li>Integer deleteById(Serializable id);</li><li>Integer deleteByMap(@Param(“cm”) Map&lt;String, Object&gt; columnMap);</li><li>Integer deleteBatchIds(List&lt;? extends Serializable&gt; idList);<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2></li><li>T selectById(Serializable id);</li><li>T selectOne(@Param(“ew”) T entity);</li><li>List<T> selectBatchIds(List&lt;? extends Serializable&gt; idList);</T></li><li>List<T> selectByMap(@Param(“cm”) Map&lt;String, Object&gt; columnMap);</T></li><li>List<T> selectPage(RowBounds rowBounds, @Param(“ew”) Wrapper<T> wrapper);</T></T></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP日志</title>
      <link href="/2022/04/01/Java/SSM/AOP%E6%97%A5%E5%BF%97/"/>
      <url>/2022/04/01/Java/SSM/AOP%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2022/03/29/Java/Java%20%E6%8F%92%E4%BB%B6/Spring%20Security/"/>
      <url>/2022/03/29/Java/Java%20%E6%8F%92%E4%BB%B6/Spring%20Security/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架。<br>(<a href="https://projects.spring.io/spring-security/">https://projects.spring.io/spring-security/</a>) Spring Security 为基于J2EE企业应用软件提供了全面安全服务</p><p>安全包括两个主要操作。<br>“认证”，是为用户建立一个他所声明的主体。主题一般式指用户，设备或可以在你系 统中执行动作的其他系<br>统。<br>“授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由 身份验证<br>过程建立了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Maven依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-security-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-security-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>web.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3.1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>Archetype Created Web Application<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置加载类路径的配置文件 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath*:applicationContext.xml,classpath*:spring-security.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置监听器 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置监听器，监听request域对象的创建和销毁的 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.request.RequestContextListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 委派过滤器 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>springSecurityFilterChain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.DelegatingFilterProxy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>springSecurityFilterChain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>dispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:springmvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>dispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>login.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>login.htm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>login.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>index.html&lt;/welcome-file>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>index.htm&lt;/welcome-file>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>index.jsp&lt;/welcome-file>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>default.html&lt;/welcome-file>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>default.htm&lt;/welcome-file>--></span><span class="token comment" spellcheck="true">&lt;!--        &lt;welcome-file>default.jsp&lt;/welcome-file>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre><p>spring security配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/security<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/securityhttp://www.springframework.org/schema/security/spring-security.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置不过滤的资源（静态资源及登录相关） --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/failure.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/css/**<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/img/**<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/plugins/**<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/**<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/WEB-INF/**<span class="token punctuation">"</span></span> <span class="token attr-name">security</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">auto-config</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">use-expressions</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置资源权限，表示任意资源路径都需要ROLE_USER权限 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>intercept-url</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span> <span class="token attr-name">access</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ROLE_USER,ROLE_ADMIN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 自定义登陆页面，            login-page 自定义登陆页面            authentication-failure-url 用户权限校验失败之后才会跳转到这个页面，如果数据库中没有这个用户则不会跳转到这个页面。            default-target-url 登陆成功后跳转的页面。            注：登陆页面用户名固定 username，密码password，action:login         --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>form-login</span>                <span class="token attr-name">login-page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span>                <span class="token attr-name">login-processing-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login<span class="token punctuation">"</span></span> <span class="token attr-name">username-parameter</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span>                <span class="token attr-name">password-parameter</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">authentication-failure-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/failure.jsp<span class="token punctuation">"</span></span>                <span class="token attr-name">default-target-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/pages/main.jsp<span class="token punctuation">"</span></span>        <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>form-login</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 注销，            invalidate-session 是否删除session            logout-url：注销处理链接            logout-success-url：注销成功页面            注：注销操作 只需要链接到 logout即可注销当前用户        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>logout</span> <span class="token attr-name">invalidate-session</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">logout-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/logout<span class="token punctuation">"</span></span>                         <span class="token attr-name">logout-success-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 关闭CSRF,默认是开启的 关闭跨域请求--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>csrf</span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>http</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>authentication-manager</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>authentication-provider</span> <span class="token attr-name">user-service-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 配置加密的方式 使用该方式必须对用户密码进行加密处理 --></span><span class="token comment" spellcheck="true">&lt;!--            &lt;security:password-encoder ref="passwordEncoder"/>--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>authentication-provider</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>authentication-manager</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置加密类 --></span><span class="token comment" spellcheck="true">&lt;!--    &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h2 id="Spring-Security使用数据库认证"><a href="#Spring-Security使用数据库认证" class="headerlink" title="Spring Security使用数据库认证"></a>Spring Security使用数据库认证</h2><p>使用UserDetails、UserDetailsService来完成操作<br><code>UserDetails</code>是一个接口，作用是于封装当前进行认证的用户信息，<br>可以手动对其进行实现，也可以使用Spring Security提供的实现类<code>User</code>来完成操作<br>自定义的UserService继承UserDetailsService接口</p><pre class=" language-Java"><code class="language-Java">public interface UsersService extends UserDetailsService &#123;&#125;</code></pre><p>实现类</p><pre class=" language-Java"><code class="language-Java">@Service("userService")@Transactionalpublic class UsersServiceImpl implements UsersService &#123;    @Autowired    private UsersDao usersDao;    //  该方法为UserDetailsService的方法,需实现该方法    @Override    public UserDetails loadUserByUsername(String username)  &#123;        System.out.println(username);        Users user = usersDao.findByUsername(username);        //  这里不对密码加密时需要拼接 &#123;noop&#125;        //  这是security的规定        User securityUser = new User(user.getUsername(), "&#123;noop&#125;" + user.getPassword(),                user.getStatus() == 0 ? false : true, true, true, true, getAuthority(user.getRoles()));        return securityUser;    &#125;    //  该用户的角色列表    private List<SimpleGrantedAuthority> getAuthority(List<Role> roles) &#123;        List<SimpleGrantedAuthority> authorities = new ArrayList();        for (Role role : roles) &#123;            authorities.add(new SimpleGrantedAuthority(role.getRoleName()));        &#125;        return authorities;    &#125;&#125;</code></pre><h2 id="用户密码加密处理"><a href="#用户密码加密处理" class="headerlink" title="用户密码加密处理"></a>用户密码加密处理</h2><p>spring-security.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>authentication-manager</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>authentication-provider</span> <span class="token attr-name">user-service-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>usersService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置加密的方式 使用该方式必须对用户密码进行加密处理 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>password-encoder</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>passwordEncoder<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>authentication-provider</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>authentication-manager</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置加密类 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>passwordEncoder<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>UserServiceImpl.java</p><pre class=" language-Java"><code class="language-Java">@Service("usersService")@Transactionalpublic class UsersServiceImpl implements UsersService &#123;    @Autowired    private UsersDao usersDao;    @Autowired    private BCryptPasswordEncoder bCryptPasswordEncoder;    @Override    public UserDetails loadUserByUsername(String username)  &#123;        System.out.println(username);        Users user = usersDao.findByUsername(username);        //  使用加密;这里不再需要拼接 &#123;noop&#125;        User securityUser = new User(user.getUsername(),  user.getPassword(),                user.getStatus() == 0 ? false : true, true, true, true, getAuthority(user.getRoles()));        return securityUser;    &#125;    @Override    public List<Users> findAll(Integer page, Integer pageSize) &#123;        PageHelper.startPage(page, pageSize);        return usersDao.findAll();    &#125;    //  保存时必须使用xml中配置的加密方式    @Override    public int save(Users users) &#123;        //  生成ID        users.setId(UUID.randomUUID().toString().replace("-","" ).substring(0,10));        //  bCryptPasswordEncoder.encode 密码加密        String encode = bCryptPasswordEncoder.encode(users.getPassword());        users.setPassword(bCryptPasswordEncoder.encode(users.getPassword()));        return usersDao.save(users);    &#125;&#125;</code></pre><h2 id="注解对方法级进行权限控制"><a href="#注解对方法级进行权限控制" class="headerlink" title="注解对方法级进行权限控制"></a>注解对方法级进行权限控制</h2><p>Spring Security在方法的权限控制上<br>支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要<br>单独通过global-method-security元素的对应属性进行启用<br>注解开启<br>@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承<br>WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将<br>AuthenticationManager定义为Bean。<br>spring-security.xml配置文件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>global-method-security</span> <span class="token attr-name">jsr250-annotations</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enabled<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>global-method-security</span> <span class="token attr-name">secured-annotations</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>enabled<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>global-method-security</span> <span class="token attr-name">pre-post-annotations</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>disabled<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 使用注解需要开启表达式  --></span><span class="token comment" spellcheck="true">&lt;!-- use-expressions="true"开启使用表达式  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>http</span> <span class="token attr-name">auto-config</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">use-expressions</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>intercept-url</span> <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span> <span class="token attr-name">access</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hasAnyRole(<span class="token punctuation">'</span>ROLE_USER<span class="token punctuation">'</span>,<span class="token punctuation">'</span>ROLE_ADMIN<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 定义跳转的具体的页面 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>form-login</span>                <span class="token attr-name">login-page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span>                <span class="token attr-name">login-processing-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.do<span class="token punctuation">"</span></span>                <span class="token attr-name">default-target-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/pages/main.jsp<span class="token punctuation">"</span></span>                <span class="token attr-name">authentication-failure-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/failer.jsp<span class="token punctuation">"</span></span>        <span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 关闭跨域请求 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>csrf</span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 退出 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">security:</span>logout</span> <span class="token attr-name">invalidate-session</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">logout-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/logout.do<span class="token punctuation">"</span></span> <span class="token attr-name">logout-success-url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/login.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">security:</span>http</span><span class="token punctuation">></span></span></code></pre><h3 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h3><p>@RolesAllowed表示访问对应方法时所应该具有的角色<br>示例：<br><code>@RolesAllowed(&#123;&quot;USER&quot;, &quot;ADMIN&quot;&#125;) 该方法只要具有&quot;USER&quot;, &quot;ADMIN&quot;任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN</code></p><p>@PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制<br>@DenyAll是和PermitAll相反的，表示无论什么角色都不能访问</p><h3 id="支持表达式的注解"><a href="#支持表达式的注解" class="headerlink" title="支持表达式的注解"></a>支持表达式的注解</h3><p>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问<br>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常<br>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果<br>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</p><h3 id="Secured注解"><a href="#Secured注解" class="headerlink" title="@Secured注解"></a>@Secured注解</h3><p>@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。<br>示例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Secured</span><span class="token punctuation">(</span><span class="token string">"IS_AUTHENTICATED_ANONYMOUSLY"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> Account <span class="token function">readAccount</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@Secured</span><span class="token punctuation">(</span><span class="token string">"ROLE_TELLER"</span><span class="token punctuation">)</span></code></pre><h2 id="页面端标签控制权限"><a href="#页面端标签控制权限" class="headerlink" title="页面端标签控制权限"></a>页面端标签控制权限</h2><p>在jsp页面中使用spring security提供的权限标签来进行权限控制</p><h3 id="maven导入"><a href="#maven导入" class="headerlink" title="maven导入"></a>maven导入</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-security-taglibs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>version<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="jsp导入"><a href="#jsp导入" class="headerlink" title="jsp导入"></a>jsp导入</h3><pre class=" language-jsp"><code class="language-jsp"><%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%></code></pre><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p><strong>authentication</strong><br>authentication代表的是当前认证对象，可以获取当前认证对象信息<br><code>&lt;security:authentication property=&quot;&quot; htmlEscape=&quot;&quot; scope=&quot;&quot; var=&quot;&quot;/&gt; </code><br>property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，<br>不允许直接通过方法进行调用<br>htmlEscape：表示是否需要将html进行转义。默认为true。<br>scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥<br>有的作用范围都进行进行指定<br>var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存<br>放，默认是存放在pageConext中</p><p><strong>authorize</strong><br>authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示<br><code>&lt;security:authorize access=&quot;&quot; method=&quot;&quot; url=&quot;&quot; var=&quot;&quot;&gt;&lt;/security:authorize&gt; </code><br>access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限<br>method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，<br>method的默认值为GET，可选值为http请求的7种方法<br>url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容<br>var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中</p><p><strong>accesscontrollist</strong><br>accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，<br>其中前两个是必须指定的<br><code>&lt;security:accesscontrollist hasPermission=&quot;&quot; domainObject=&quot;&quot; var=&quot;&quot;&gt;&lt;/security:accesscontrollist&gt; </code><br>hasPermission：hasPermission属性用于指定以逗号分隔的权限列表<br>domainObject：domainObject用于指定对应的域对象<br>var：var则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PageHelper</title>
      <link href="/2022/03/29/Java/Java%20%E6%8F%92%E4%BB%B6/PageHelper/"/>
      <url>/2022/03/29/Java/Java%20%E6%8F%92%E4%BB%B6/PageHelper/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PageHelper是一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、<br>oracle、mariaDB、DB2、SQLite、Hsqldb等。<br>本项目在 github 的项目地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper">https://github.com/pagehelper/Mybatis-PageHelper</a><br>本项目在 gitosc 的项目地址：<a href="http://git.oschina.net/free/Mybatis_PageHelper">http://git.oschina.net/free/Mybatis_PageHelper</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>引入分页插件有2种方式，推荐使用 Maven 方式。</p><ol><li>引入 Jar 包<br><a href="https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/">https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/</a><br><a href="http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/">http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/</a><br>由于使用了sql 解析工具，你还需要下载 jsqlparser.jar：<br><a href="http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/">http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/</a></li><li>使用 Maven<br>在 pom.xml 中添加如下依赖：<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>配置<br>新版拦截器是 <code>com.github.pagehelper.PageInterceptor</code><br><code>com.github.pagehelper.PageHelper</code> 是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法</li></ol><p>在 MyBatis 配置 xml 中配置拦截器插件</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">interceptor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.github.pagehelper.PageInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>param1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span></code></pre><p>在 Spring 配置文件中配置拦截器插件;使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 注意其他配置 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>plugins<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.github.pagehelper.PageInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!--使用下面的方式配置参数，一行配置一个 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>            params=value1          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>3.2.3 分页插件参数介绍</p><ol><li>helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置<br>helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：<br>oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver201<br>2 , derby<br>特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的<br>方式进行分页。<br>你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方<br>法。</li><li>offsetAsPageNum ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为<br>true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分<br>页。</li><li>rowBoundsWithCount ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置<br>为 true 时，使用 RowBounds 分页会进行 count 查询。</li><li>pageSizeZero ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =<br>0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</li><li>reasonable ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一<br>页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。</li><li>params ：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属<br>性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认<br>值为<br>pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero<br>。</li><li>supportMethodsArguments ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查<br>询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法<br>可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和<br>ArgumentsObjTest 。</li><li>autoRuntimeDialect ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言<br>的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。</li><li>closeConn ：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类<br>型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为<br>false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。</li><li>2.4.基本使用<br>PageHelper的基本使用有6种，大家可以查看文档，最常用的有两种</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/03/26/Java/SSM/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/03/26/Java/SSM/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>Spring+SPringMVC+mybatis</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类服务器</title>
      <link href="/2022/03/24/Java/SpringMVC/%E5%88%86%E7%B1%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/03/24/Java/SpringMVC/%E5%88%86%E7%B1%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="分服务器的目的"><a href="#分服务器的目的" class="headerlink" title="分服务器的目的"></a>分服务器的目的</h2><p>在实际开发中，我们会有很多处理不同功能的服务器。例如：<br>应用服务器：负责部署我们的应用<br>数据库服务器：运行我们的数据库<br>缓存和消息服务器：负责处理大并发访问的缓存和消息<br>文件服务器：负责存储用户上传文件的服务器。<br>(注意：此处说的不是服务器集群)</p><ol><li><p>准备两个 tomcat 服务器，并创建一个用于存放图片的 web 工程</p></li><li><p>应用服务器 添加 jar 包<br>pom.xml<br>``` xml</p> <properties>     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>     <maven.compiler.source>1.8</maven.compiler.source>     <maven.compiler.target>1.8</maven.compiler.target>     <spring.version>5.0.2.RELEASE</spring.version> </properties> <dependencies>     <dependency>         <groupId>org.springframework</groupId>         <artifactId>spring-context</artifactId>         <version>${spring.version}</version>     </dependency><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-web&lt;/artifactId&gt;     &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;     &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;</code></pre></dependencies></li></ol><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;        &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;        &lt;version&gt;1.19.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><pre><code>3. 应用服务器 编写控制器实现上传图片``` Java@Controller(&quot;fileUploadController2&quot;)public class FileUploadController2 &#123;  public static final String FILESERVERURL =  &quot;http://localhost:9090/day06_spring_image/uploads/&quot;;  /**  * 文件上传，保存文件到不同服务器  */  @RequestMapping(&quot;/fileUpload2&quot;)  public String testResponseJson(String picname,MultipartFile uploadFile) throws Exception&#123;    //定义文件名    String fileName = &quot;&quot;;    //1.获取原始文件名    String uploadFileName = uploadFile.getOriginalFilename();    //2.截取文件扩展名    String extendName =     uploadFileName.substring(uploadFileName.lastIndexOf(&quot;.&quot;)+1,     uploadFileName.length());    //3.把文件加上随机数，防止文件重复    String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();    //4.判断是否输入了文件名    if(!StringUtils.isEmpty(picname)) &#123;    fileName = uuid+&quot;_&quot;+picname+&quot;.&quot;+extendName;    &#125;else &#123;    fileName = uuid+&quot;_&quot;+uploadFileName;    &#125;    System.out.println(fileName);    //5.创建 sun 公司提供的 jersey 包中的 Client 对象    Client client = Client.create();    //6.指定上传文件的地址，该地址是 web 路径    WebResource resource = client.resource(FILESERVERURL+fileName);    //7.实现上传    String result = resource.put(String.class,uploadFile.getBytes());    System.out.println(result);    return &quot;success&quot;;  &#125;&#125;</code></pre><p>前端页面</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fileUpload2<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>名称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>picname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>图片：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uploadFile<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>上传<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><p>配置解析器</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置文件上传解析器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipartResolver<span class="token punctuation">"</span></span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.multipart.commons.CommonsMultipartResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 设置上传文件的最大尺寸为 5MB --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxUploadSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>5242880<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2022/03/24/Java/SpringMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2022/03/24/Java/SpringMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前端请求基本要素"><a href="#前端请求基本要素" class="headerlink" title="前端请求基本要素"></a>前端请求基本要素</h2><p>enctype 取值必须是：multipart/form-data<br>method 属性取值必须是 Post</p><h2 id="依赖jar包"><a href="#依赖jar包" class="headerlink" title="依赖jar包"></a>依赖jar包</h2><p>jar 包：<br>Commons-fileupload 和 commons-io</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><h3 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/fileUpload<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>名称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>picname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>图片：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uploadFile<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>上传<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre class=" language-Java"><code class="language-Java">@Controller("fileUploadController")public class FileUploadController &#123;  @RequestMapping("/fileUpload")  public String testResponseJson(String picname,MultipartFile     uploadFile,HttpServletRequest request) throws Exception&#123;    //定义文件名    String fileName = "";    //1.获取原始文件名    String uploadFileName = uploadFile.getOriginalFilename();    //2.截取文件扩展名    String extendName =     uploadFileName.substring(uploadFileName.lastIndexOf(".")+1,     uploadFileName.length());    //3.把文件加上随机数，防止文件重复    String uuid = UUID.randomUUID().toString().replace("-", "").toUpperCase();    //4.判断是否输入了文件名    if(!StringUtils.isEmpty(picname)) &#123;      fileName = uuid+"_"+picname+"."+extendName;    &#125;else &#123;      fileName = uuid+"_"+uploadFileName;    &#125;    System.out.println(fileName);    //2.获取文件路径    ServletContext context = request.getServletContext();    String basePath = context.getRealPath("/uploads");    //3.解决同一文件夹中文件过多问题    String datePath = new SimpleDateFormat("yyyy-MM-dd").format(new Date());    //4.判断路径是否存在    File file = new File(basePath+"/"+datePath);    if(!file.exists()) &#123;      file.mkdirs();    &#125;    //5.使用 MulitpartFile 接口中方法，把上传的文件写到指定位置    uploadFile.transferTo(new File(file,fileName));    return "success";  &#125;&#125;</code></pre><h3 id="配置文件解析器"><a href="#配置文件解析器" class="headerlink" title="配置文件解析器"></a>配置文件解析器</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置文件上传解析器 --></span><span class="token comment" spellcheck="true">&lt;!-- id 的值是固定的--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipartResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.multipart.commons.CommonsMultipartResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 设置上传文件的最大尺寸为 5MB 5242880 = 1024*1024*5--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxUploadSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>5242880<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应数据</title>
      <link href="/2022/03/24/Java/SpringMVC/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/03/24/Java/SpringMVC/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><pre class=" language-Java"><code class="language-Java">//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp@RequestMapping("/testReturnString")public String testReturnString() &#123;System.out.println("AccountController 的 testReturnString 方法执行了。。。。");return "success";&#125;</code></pre><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在昨天的学习中，我们知道 Servlet 原始 API 可以作为控制器中方法的参数：</p><pre class=" language-Java"><code class="language-Java">@RequestMapping("/testReturnVoid")public void testReturnVoid(HttpServletRequest request,HttpServletResponse response) throws Exception &#123;&#125;</code></pre><p>在 controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果：</p><ol><li>使用 request 转发页面，如下：<pre class=" language-Java"><code class="language-Java">request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);</code></pre></li><li>通过 response 页面重定向：<pre class=" language-Java"><code class="language-Java">response.sendRedirect("testRetrunString")</code></pre></li><li>通过 response 指定响应结果，例如响应 json 数据：<pre class=" language-Java"><code class="language-Java">response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("json 串");</code></pre><h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象可以用作控制器方法的返回值。<br>该对象中有两个方法：<br>示例代码：<br>/**</li></ol><ul><li>返回 ModeAndView</li><li>@return</li><li>/<br>@RequestMapping(“/testReturnModelAndView”)<br>public ModelAndView testReturnModelAndView() {<br>ModelAndView mv = new ModelAndView();<br>mv.addObject(“username”, “张三”);<br>mv.setViewName(“success”);<br>return mv;<br>}<br>响应的 jsp 代码：<br>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>pageEncoding=”UTF-8”%&gt;<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>执行成功</title></head><body>执行成功！${requestScope.username}</body></html>输出结果：注意：我们在页面上上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。</li></ul><p>1.2转发和重定向<br>1.2.1 forward 转发<br>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：<br>/**</p><ul><li>转发</li><li>@return</li><li>/<br>@RequestMapping(“/testForward”)<br>public String testForward() {<br>System.out.println(“AccountController 的 testForward 方法执行了。。。。”);<br>return “forward:/WEB-INF/pages/success.jsp”;<br>}<br>需要注意的是，如果用了 formward：则路径必须写成实际视图 url，不能写逻辑视图。<br>它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求<br>转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</li></ul><p>1.2.2 Redirect 重定向<br>contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect:<br>/**</p><ul><li>重定向</li><li>@return</li><li>/<br>@RequestMapping(“/testRedirect”)<br>public String testRedirect() {<br>System.out.println(“AccountController 的 testRedirect 方法执行了。。。。”);<br>return “redirect:testReturnModelAndView”;<br>}<br>它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不<br>能写在 WEB-INF 目录中，否则无法找到。</li></ul><h2 id="ResponseBody-响应-json-数据"><a href="#ResponseBody-响应-json-数据" class="headerlink" title="@ResponseBody 响应 json 数据"></a>@ResponseBody 响应 json 数据</h2><p>作用：<br>用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端<br>注意：<br><code>Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入jackson 的包。jackson2.7.0 以下的版本用不了</code></p><p>jsp 中的代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#testJson"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        type<span class="token punctuation">:</span><span class="token string">"post"</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span><span class="token string">"$&amp;#123;pageContext.request.contextPath&amp;#125;/testResponseJson"</span><span class="token punctuation">,</span>        contentType<span class="token punctuation">:</span><span class="token string">"application/json;charset=utf-8"</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span><span class="token string">'&amp;#123;"id":1,"name":"test","money":999.0&amp;#125;'</span><span class="token punctuation">,</span>        dataType<span class="token punctuation">:</span><span class="token string">"json"</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>控制器中的代码：</p><pre class=" language-Java"><code class="language-Java">@Controller("jsonController")public class JsonController &#123;    /**    * 测试响应 json 数据    */  @RequestMapping("/testResponseJson")  public @ResponseBody Account testResponseJson(@RequestBody Account account) &#123;    System.out.println("异步请求："+account);    return account;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST(restful) 风格请求配置</title>
      <link href="/2022/03/23/Java/SpringMVC/REST%20%E9%A3%8E%E6%A0%BC%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/03/23/Java/SpringMVC/REST%20%E9%A3%8E%E6%A0%BC%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>REST（英文：Representational State Transfer，简称 REST）<br>REST 并没有一个明确的标准，而像是一种设计的风格</p><h2 id="restful-的优点"><a href="#restful-的优点" class="headerlink" title="restful 的优点"></a>restful 的优点</h2><p>结构清晰、符合标准、易于理解、扩展方便</p><h2 id="restful-的特性："><a href="#restful-的特性：" class="headerlink" title="restful 的特性："></a>restful 的特性：</h2><p>资源（Resources）：一个 URI（统一资源定位符）指向一个资源<br>表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）<br>状态转化（State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。<br>HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，<br>必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以<br>就是 “表现层状态转化”。具体说，就是 </p><p>HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT、DELETE<br>分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</p><p>restful 的示例：<br>/account/1 HTTP GET ： 得到 id = 1 的 account<br>/account/1 HTTP DELETE： 删除 id = 1 的 account<br>/account/1 HTTP PUT： 更新 id = 1 的 account</p><h2 id="PathVaribale注解"><a href="#PathVaribale注解" class="headerlink" title="@PathVaribale注解"></a>@PathVaribale注解</h2><p>作用：<br>  用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。<br>  url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。<br>属性：<br>  value：用于指定 url 中占位符名称。<br>  required：是否必须提供占位符。<br>范围:<br>  方法参数<br>例:<br>Java代码</p><pre class=" language-Java"><code class="language-Java">控制器代码：  /**  * PathVariable 注解  * @param user  * @return  */  @RequestMapping("/usePathVariable/&#123;id&#125;")  public String usePathVariable(@PathVariable("id") Integer id)&#123;    System.out.println(id);    return "success";   &#125;</code></pre><p>jsp 代码：</p><pre class=" language-jsp"><code class="language-jsp"><!-- PathVariable 注解 --> <a href="springmvc/usePathVariable/100">pathVariable 注解</a></code></pre><pre class=" language-Java"><code class="language-Java">控制器中示例代码： /*** post 请求：保存*/@RequestMapping(value="/testRestPOST",method=RequestMethod.POST)public String testRestfulURLPOST(User user)&#123;  System.out.println("rest post"+user);  return "success"; &#125;/*** put 请求：更新*/@RequestMapping(value="/testRestPUT/&#123;id&#125;",method=RequestMethod.PUT)public String testRestfulURLPUT(@PathVariable("id")Integer id,User user)&#123;  System.out.println("rest put "+id+","+user);  return "success"; &#125;/*** post 请求：删除*/@RequestMapping(value="/testRestDELETE/&#123;id&#125;",method=RequestMethod.DELETE)public String testRestfulURLDELETE(@PathVariable("id")Integer id)&#123;  System.out.println("rest delete "+id);  return "success";&#125;/*** post 请求：查询*/@RequestMapping(value="/testRestGET/&#123;id&#125;",method=RequestMethod.GET)public String testRestfulURLGET(@PathVariable("id")Integer id)&#123;  System.out.println("rest get "+id);  return "success"; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求参数的绑定</title>
      <link href="/2022/03/23/Java/SpringMVC/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/03/23/Java/SpringMVC/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h2><p>基本类型参数：<br>  包括基本类型和 String 类型<br>POJO 类型参数：<br>  包括实体类，以及关联的实体类<br>数组和集合类型参数：<br>  包括 List 结构和 Map 结构的集合（包括数组）<br>SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。</p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><p>基本类型或者 String 类型：<br>要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)<br>POJO 类型，或者它的关联对象：<br>要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。<br>如果是集合类型,有两种方式：<br>第一种：<br>  要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。<br>  给 List 集合中的元素赋值，使用下标。<br>  给 Map 集合中的元素赋值，使用键值对。<br>第二种：<br>  接收的请求参数是 json 格式数据。需要借助一个注解实现。<br>注意:<br>它还可以实现一些数据类型自动转换。内置转换器全都在：<br>org.springframework.core.convert.support 包下</p><h2 id="请求参数乱码问题"><a href="#请求参数乱码问题" class="headerlink" title="请求参数乱码问题"></a>请求参数乱码问题</h2><p>post 请求方式：</p><ol><li>在 web.xml 中配置过滤器<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置 springMVC 编码过滤器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 设置过滤器中的属性值 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 启动过滤器 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 过滤所有请求 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre></li><li>在 springmvc 的配置文件中配置静态资源不过滤<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/css/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/css/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/images/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/images/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/scripts/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/javascript/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre>get 请求方式：<br>修改 tomcat 的 server.xml配置文件<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8080<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span> <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>改为：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8080<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span> <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span><span class="token attr-name">useBodyEncodingForURI</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>ajax 请求仍然乱码，把：useBodyEncodingForURI="true"改为 URIEncoding="UTF-8"即可</code></pre></li></ol><h2 id="使用-ServletAPI-对象作为方法参数"><a href="#使用-ServletAPI-对象作为方法参数" class="headerlink" title="使用 ServletAPI 对象作为方法参数"></a>使用 ServletAPI 对象作为方法参数</h2><p>SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：<br>HttpServletRequest<br>HttpServletResponse<br>HttpSession<br>java.security.Principal<br>Locale<br>InputStream<br>OutputStream<br>Reader<br>Writer<br>上述对象，直接写在控制层的方法参数中使用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换器</title>
      <link href="/2022/03/23/Java/SpringMVC/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2022/03/23/Java/SpringMVC/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串转date类型注意"><a href="#字符串转date类型注意" class="headerlink" title="字符串转date类型注意"></a>字符串转date类型注意</h2><p>2021/12/12格式的可以自动转换;不需要自定义类型转换器<br>2021-12-12格式的不会自动转换;需要自定义类型转换器</p><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><p>SpringMVC提供<code>Converter&lt;S,T&gt;接口</code>;<br>包:<code>org.springframework.core.convert.converter.Converter</code><br>说明:该接口有两个泛型,S:表示接受的类型，T：表示目标的类型<br>使用:</p><ol><li>定义类实现Converter接口,实现convert方法<br>``` Java<br>import org.springframework.core.convert.converter.Converter;<br>import java.util.Date;<br>import java.text.DateFormat;<br>import java.text.ParseException;<br>import java.text.SimpleDateFormat;</li></ol><p>public class StringToDateConverter implements Converter&lt;String, Date&gt; {<br>    @Override<br>    public Date convert(String s) {<br>        DateFormat dateFormat = new SimpleDateFormat(“yyyy-MM-dd”);<br>        Date parse = null;<br>        try {<br>            parse = dateFormat.parse(s);<br>        } catch (ParseException e) {<br>            e.printStackTrace();<br>            throw new RuntimeException(“日期格式错误!”);<br>        }<br>        return parse;<br>    }<br>}</p><pre><code>2. 在 spring 配置文件中配置类型转换器  spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去  ``` xml  &lt;!-- 配置类型转换器工厂 --&gt;   &lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;  &lt;!-- 给工厂注入一个新的类型转换器 --&gt;     &lt;property name=&quot;converters&quot;&gt;       &lt;array&gt;        &lt;!-- 配置自定义类型转换器 --&gt;         &lt;bean class=&quot;com.itheima.web.converter.StringToDateConverter&quot;&gt;&lt;/bean&gt;      &lt;/array&gt;    &lt;/property&gt;  &lt;/bean&gt;</code></pre><ol start="3"><li>spring 配置文件的 mvc:annotation-driven 标签中引用配置的类型转换服务<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 引用自定义类型转换器 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token attr-name">conversion-service</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>converterService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用注解</title>
      <link href="/2022/03/23/Java/SpringMVC/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/03/23/Java/SpringMVC/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Controller-注解："><a href="#Controller-注解：" class="headerlink" title="@Controller 注解："></a>@Controller 注解：</h2><p>作用:<br>辅助实现组件扫描，类似于 @Component 注解<br>出现位置：</p><ul><li>类上</li></ul><h2 id="RestController-注解"><a href="#RestController-注解" class="headerlink" title="@RestController 注解"></a>@RestController 注解</h2><p>作用:<br>  辅助实现组件扫描<br>  响应数据类型<br>出现位置：</p><ul><li>类上<br>组合:<br>@Controller与ResponseBody的组合<h2 id="RequestMapping-注解"><a href="#RequestMapping-注解" class="headerlink" title="RequestMapping 注解"></a>RequestMapping 注解</h2>作用：<br>用于建立请求 URL 和处理请求方法之间的对应关系<br>出现位置：</li><li>类上：<br>  请求 URL 的第一级访问目录。不写相当于应用的根目录。<br>  需要以/开头;目的是为了使 URL 可以按照模块化管理</li><li>方法上：<br>  请求 URL 的第二级访问目录<br>属性：<br>value：用于指定请求的 URL。和 path 属性的作用一样<br>method：用于指定请求的方式<br>headers：用于指定限制请求消息头的条件<br>params：用于指定限制请求参数的条件。支持简单的表达式。要求请求参数的 key 和 value 必须和<br>配置的一模一样。<br>例如：<br>params = {“accountName”}，表示请求参数必须有 accountName<br>params = {“moeny!100”}，表示请求参数中 money 不能是 100。</li></ul><p>注意：<br>以上四个属性只要出现 2 个或以上时，他们的关系是与的关系</p><h2 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h2><p>作用：<br>用于建立Get请求 URL 和处理请求方法之间的对应关系<br>出现位置：</p><ul><li>方法上：<br>  请求 URL 的第二级访问目录<br>  请求 URL 的第一级访问目录。不写相当于应用的根目录。<br>  需要以/开头;目的是为了使 URL 可以按照模块化管理<br>属性：<br>value：用于指定请求的 URL。和 path 属性的作用一样</li></ul><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><p>作用：<br>把请求中指定名称的参数给控制器中的形参赋值。<br>属性：<br>value：请求参数中的名称。<br>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：<br>用于获取请求体内容<br>get 请求方式不适用。（因为get没有请求体）<br>出现位置：</p><ul><li>方法参数：<br>属性：<br>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li></ul><h2 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h2><p>作用：<br>用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。<br>springmvc 支持 rest 风格 URL         的一个重要标志。<br>属性：<br>value：用于指定 url 中占位符名称。<br>required：是否必须提供占位符。</p><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p>作用：<br>用于获取请求消息头。<br>属性：<br>value：提供消息头名称<br>required：是否必须有此消息头</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>HiddentHttpMethodFilter<br>可以帮我们把请求方式转换为其他我们想要的请求方法。</p><p>CookieValue<br>作用：<br>用于把指定 cookie 名称的值传入控制器方法参数。<br>属性：<br>value：指定 cookie 的名称。<br>required：是否必须有此 cookie。<br>ModelAttribute<br>作用：<br>该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。<br>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修    饰没有返回值的方法，也可以修饰有具体返回值的方法。<br>出现在参数上，获取指定的数据给参数赋值。<br>属性：<br>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结    构的 key。<br>SessionAttribute<br>作用：<br>用于多次执行控制器方法间的参数共享。<br>属性：<br>value：用于指定存入的属性名称<br>type：用于指定存入的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2022/03/23/Java/SpringMVC/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/03/23/Java/SpringMVC/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="开发形式"><a href="#开发形式" class="headerlink" title="开发形式"></a>开发形式</h2><ul><li>形式一 C/S 架构(客户端/服务器)</li><li>形式二 B/S 架构(浏览器服务器)</li></ul><h2 id="在-B-S-架构中，系统标准的三层架构"><a href="#在-B-S-架构中，系统标准的三层架构" class="headerlink" title="在 B/S 架构中，系统标准的三层架构"></a>在 B/S 架构中，系统标准的三层架构</h2><h3 id="表现层-web层"><a href="#表现层-web层" class="headerlink" title="表现层(web层)"></a>表现层(web层)</h3><p>负责接收客户端请求，向客户端响应结果，通常使用http协议请求;接收 http 请求，完成 http 响应<br>表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示<br>表现层的设计一般使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）<br><strong>MVC 模型</strong><br>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，<br>是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：<br>Model（模型）：<br>数据模型;用于封装数据<br>View（视图）：<br>jsp 或者 html;展示数据的;视图是依据模型数据创建的<br>Controller（控制器）：<br>应用程序中处理用户交互的部分。处理程序逻辑的。</p><h3 id="业务层-service-层"><a href="#业务层-service-层" class="headerlink" title="业务层(service 层)"></a>业务层(service 层)</h3><p>负责业务逻辑处理，和开发项目的需求息息相关<br>业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（事务应该放到业务层来控制）</p><h3 id="持久层-dao-层"><a href="#持久层-dao-层" class="headerlink" title="持久层(dao 层)"></a>持久层(dao 层)</h3><p>负责数据持久化，包括数据层即数据库和数据访问层<br>持久层就是和数据库交互，对数据库表进行曾删改查的。</p><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>SpringMVC 是基于 Java 实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架<br>Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块<br>SpringMVC 为目前最主流的 MVC 框架之一<br>通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口;同时还支持<strong>RESTful</strong> 编程风格的请求</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>清晰的角色划分：</li></ol><ul><li>前端控制器（DispatcherServlet）</li><li>请求到处理器映射（HandlerMapping）</li><li>处理器适配器（HandlerAdapter）</li><li>视图解析器（ViewResolver）</li><li>处理器或页面控制器（Controller）</li><li>验证器（ Validator）</li><li>命令对象（Command 请求参数绑定到的对象就叫命令对象）</li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li></ul><ol start="2"><li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 </li><li>由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 </li><li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 </li><li>可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 </li><li>可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 </li><li>功能强大的数据验证、格式化、绑定机制。 </li><li>利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 </li><li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li><li>强大的 JSP 标签库，使 JSP 编写更容易。<br>………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配<br>置支持等等。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在web.xml的web-app中配置<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置spring mvc 核心控制器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVCDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>     org.springframework.web.servlet.DispatcherServlet <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:SpringMVC.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。 取值只能是非 0 正整数，表示启动顺序 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVCDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span></code></pre></li><li>在resources下添加SpringMVC.xml<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/mvc   http://www.springframework.org/schema/mvc/spring-mvc.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置创建 spring 容器要扫描的包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.dy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置视图解析器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/WEB-INF/pages/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre></li><li>编写controller控制器<pre class=" language-Java"><code class="language-Java">@Controller("helloController")@RequestMapping("/hello")public class HelloController &#123; @RequestMapping("/world1") public String sayHello1() &#123;     System.out.println("HelloController 的 sayHello1 方法执行了。。。。");     return "success"; &#125; @RequestMapping("/world2") public String sayHello2() &#123;     System.out.println("HelloController 的 sayHello2 方法执行了。。。。");     return "success"; &#125;&#125;</code></pre></li><li>编写jsp发送请求<pre class=" language-jsp"><code class="language-jsp"><%@ page contentType="text/html;charset=UTF-8" language="java" %><html><head>   <title>Title</title></head><body> <a href="$&#123;pageContext.request.contextPath&#125;/hello/world1">SpringMVC 入门案例</a> <br/> <a href="hello/world2">SpringMVC 入门案例</a></body></html></code></pre></li><li>使用tomcat运行程序,点击链接,查看tomcat控制台打印的信息</li></ol><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li>服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象</li><li>浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发<br>的路径是根据请求 URL，匹配@RequestMapping 中的内容。</li><li>匹配到了后，执行对应方法。该方法有一个返回值。</li><li>根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。</li><li>渲染结果视图，响应浏览器。</li></ol><h2 id="涉及的组件"><a href="#涉及的组件" class="headerlink" title="涉及的组件"></a>涉及的组件</h2><h3 id="DispatcherServlet：前端控制器"><a href="#DispatcherServlet：前端控制器" class="headerlink" title="DispatcherServlet：前端控制器"></a>DispatcherServlet：前端控制器</h3><p>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由<br>它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p><h3 id="HandlerMapping：处理器映射器"><a href="#HandlerMapping：处理器映射器" class="headerlink" title="HandlerMapping：处理器映射器"></a>HandlerMapping：处理器映射器</h3><p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的<br>映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><h3 id="Handler：处理器"><a href="#Handler：处理器" class="headerlink" title="Handler：处理器"></a>Handler：处理器</h3><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由<br>Handler 对具体的用户请求进行处理。</p><h3 id="HandlAdapter：处理器适配器"><a href="#HandlAdapter：处理器适配器" class="headerlink" title="HandlAdapter：处理器适配器"></a>HandlAdapter：处理器适配器</h3><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理<br>器进行执行。</p><h3 id="View-Resolver：视图解析器"><a href="#View-Resolver：视图解析器" class="headerlink" title="View Resolver：视图解析器"></a>View Resolver：视图解析器</h3><p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名<br>即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p><h3 id="View：视图"><a href="#View：视图" class="headerlink" title="View：视图"></a>View：视图</h3><p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView<br>等。我们最常用的视图就是 jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开<br>发具体的页面。</p><h3 id="mvc-annotation-driven说明"><a href="#mvc-annotation-driven说明" class="headerlink" title="mvc:annotation-driven说明"></a><a href="mvc:annotation-driven">mvc:annotation-driven</a>说明</h3><p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使 用 <a href="mvc:annotation-driven">mvc:annotation-driven</a> 自动加载 RequestMappingHandlerMapping （处理映射器） 和<br>RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用<br><a href="mvc:annotation-driven">mvc:annotation-driven</a>替代注解处理器和适配器的配置。<br>相当于在 xml 中配置了：</p><!-- 上面的标签相当于 如下配置--><pre class=" language-xml"><code class="language-xml">class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- HandlerAdapter --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- HadnlerExceptionResolvers --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>注意：<br>一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还<br>有具体的使用场景）。<br>明确：<br>我们只需要编写处理具体业务的控制器以及视图。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/22/Java/Spring/JDBC/"/>
      <url>/2022/03/22/Java/Spring/JDBC/</url>
      
        <content type="html"><![CDATA[<p>第1章 Spring 中的 JdbcTemplate[会用]<br>1.1JdbcTemplate 概述<br>它是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。spring 框架为我们提供了很多<br>的操作模板类。<br>操作关系型数据的：<br>JdbcTemplate<br>HibernateTemplate<br>操作 nosql 数据库的：<br>RedisTemplate<br>操作消息队列的：<br>JmsTemplate<br>我们今天的主角在 spring-jdbc-5.0.2.RELEASE.jar 中，我们在导包的时候，除了要导入这个 jar 包<br>外，还需要导入一个 spring-tx-5.0.2.RELEASE.jar（它是和事务相关的）。<br>1.2JdbcTemplate 对象的创建<br>我们可以参考它的源码，来一探究竟：<br>public JdbcTemplate() {<br>}<br>public JdbcTemplate(DataSource dataSource) {<br>setDataSource(dataSource);<br>afterPropertiesSet();<br>}<br>public JdbcTemplate(DataSource dataSource, boolean lazyInit) {<br>setDataSource(dataSource);<br>setLazyInit(lazyInit);<br>afterPropertiesSet();<br>}<br>除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可以<br>在配置文件中配置这些对象。  </p><p>1.3spring 中配置数据源<br>1.3.1 环境搭建<br>1.3.2 编写 spring 的配置文件<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans><br>1.3.3 配置数据源<br>我们之前已经接触过了两个数据源，C3P0 和 DBCP。要想使用这两数据源都需要导入对应的 jar 包。<br>1.3.3.1 配置 C3P0 数据源<br>导入<br>到工程的 lib 目录。在 spring 的配置文件中配置：<br><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br><property name="driverClass" value="com.mysql.jdbc.Driver"></property><br><property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property><br><property name="user" value="root"></property>  </bean></p><p><property name="password" value="1234"></property><br><br>1.3.3.2 配置 DBCP 数据源<br>导入<br>到工程的 lib 目录。在 spring 的配置文件中配置： </p><!-- 配置数据源 --> <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql:// /spring_day02"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean> 1.3.3.3 配置 spring 内置数据源 spring 框架也提供了一个内置数据源，我们也可以使用 spring 的内置数据源，它就在 spring-jdbc-5.0.2.REEASE.jar 包中： <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql:///spring_day02"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean> 1.3.4 将数据库连接的信息配置到属性文件中: 【定义属性文件】 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///spring_day02 jdbc.username=root jdbc.password=123 【引入外部的属性文件】 一种方式: <!-- 引入外部属性文件： --> <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">    <property name="location" value="classpath:jdbc.properties"> </property></bean> 另一种方式: <context:property-placeholder location="classpath:jdbc.properties"> 1.4JdbcTemplate 的增删改查操作 1.4.1 前期准备 创建数据库： create database spring_day02; use spring_day02; 创建表： create table account( id int primary key auto_increment, name varchar(40), money float )character set utf8 collate utf8_general_ci; 1.4.2 在 spring 配置文件中配置 JdbcTemplate <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> <!-- 配置一个数据库的操作模板：JdbcTemplate --> <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"></property> </bean> <!-- 配置数据源 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql:///spring_day02"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean> </beans>    <p>1.4.3 最基本使用<br>public class JdbcTemplateDemo2 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>jt.execute(“insert into account(name,money)values(‘eee’,500)”);<br>}<br>}<br>1.4.4 保存操作<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//保存<br>jt.update(“insert into account(name,money)values(?,?)”,”fff”,5000);<br>}<br>}<br>1.4.5 更新操作<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//修改<br>jt.update(“update account set money = money-? where id = ?”,300,6);<br>}<br>}  </p><p>1.4.6 删除操作<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//删除<br>jt.update(“delete from account where id = ?”,6);<br>}<br>}<br>1.4.7 查询所有操作<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//查询所有<br>List<Account> accounts = jt.query(“select * from account where money &gt; ? “,<br>new AccountRowMapper(), 500);<br>for(Account o : accounts){<br>System.out.println(o);<br>}<br>}<br>}<br>public class AccountRowMapper implements RowMapper<Account>{<br>@Override<br>public Account mapRow(ResultSet rs, int rowNum) throws SQLException {<br>Account account = new Account();<br>account.setId(rs.getInt(“id”));<br>account.setName(rs.getString(“name”));<br>account.setMoney(rs.getFloat(“money”));<br>return account;<br>}  </Account></Account></p><p>}<br>1.4.8 查询一个操作<br>使用 RowMapper 的方式：常用的方式<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//查询一个<br>List<Account> as = jt.query(“select * from account where id = ? “,<br>new AccountRowMapper(), 55);<br>System.out.println(as.isEmpty()?”没有结果”:as.get(0));<br>}<br>}<br>使用 ResultSetExtractor 的方式:不常用的方式<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象<br>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//查询一个<br>Account account = jt.query(“select * from account where id = ?”,<br>new AccountResultSetExtractor(),3);<br>System.out.println(account);<br>}<br>}<br>1.4.9 查询返回一行一列操作<br>public class JdbcTemplateDemo3 {<br>public static void main(String[] args) {<br>//1.获取 Spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 id 获取 bean 对象  </Account></p><p>JdbcTemplate jt = (JdbcTemplate) ac.getBean(“jdbcTemplate”);<br>//3.执行操作<br>//查询返回一行一列：使用聚合函数，在不使用 group by 字句时，都是返回一行一列。最长用的<br>就是分页中获取总记录条数<br>Integer total = jt.queryForObject(“select count(<em>) from account where money &gt; ?<br>“,Integer.class,500);<br>System.out.println(total);<br>}<br>}<br>1.5在 dao 中使用 JdbcTemplate<br>1.5.1 准备实体类<br>/</em>* </p><ul><li>账户的实体 </li><li>/<br>public class Account implements Serializable {<br>private Integer id;<br>private String name;<br>private Float money;<br>public Integer getId() {<br>return id;<br>}<br>public void setId(Integer id) {<br>this.id = id;<br>}<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name = name;<br>}<br>public Float getMoney() {<br>return money;<br>}<br>public void setMoney(Float money) {<br>this.money = money;<br>}<br>@Override<br>public String toString() {<br>return “Account [id=” + id + “, name=” + name + “, money=” + money + “]”;  </li></ul><p>}<br>}<br>1.5.2 第一种方式：在 dao 中定义 JdbcTemplate<br>/** </p><ul><li>账户的接口 </li><li>/<br>public interface IAccountDao {<br>/** </li><li>根据 id 查询账户信息 </li><li>@param id </li><li>@return </li><li>/<br>Account findAccountById(Integer id);<br>/** </li><li>根据名称查询账户信息 </li><li>@return </li><li>/<br>Account findAccountByName(String name);<br>/** </li><li>更新账户信息 </li><li>@param account </li><li>/<br>void updateAccount(Account account);<br>}<br>/** </li><li>账户的持久层实现类 </li><li>此版本的 dao，需要给 dao 注入 JdbcTemplate </li><li>/<br>public class AccountDaoImpl implements IAccountDao {<br>private JdbcTemplate jdbcTemplate;<br>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {<br>this.jdbcTemplate = jdbcTemplate;<br>}<br>@Override<br>public Account findAccountById(Integer id) {  </li></ul><p>List<Account> list = jdbcTemplate.query(“select * from account where id = ?<br>“,new AccountRowMapper(),id);<br>return list.isEmpty()?null:list.get(0);<br>}<br>@Override<br>public Account findAccountByName(String name) {<br>List<Account> list = jdbcTemplate.query(“select * from account where name<br>= ? “,new AccountRowMapper(),name);<br>if(list.isEmpty()){<br>return null;<br>}<br>if(list.size()&gt;1){<br>throw new RuntimeException(“结果集不唯一，不是只有一个账户对象”);<br>}<br>return list.get(0);<br>}<br>@Override<br>public void updateAccount(Account account) {<br>jdbcTemplate.update(“update account set money = ? where id = ?<br>“,account.getMoney(),account.getId());<br>}<br>}<br>配置文件<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> </beans></Account></Account></p><!-- 配置一个 dao --> <bean id="accountDao" class="com.doyens.dao.impl.AccountDaoImpl"> <!-- 注入 jdbcTemplate --> <property name="jdbcTemplate" ref="jdbcTemplate"></property> </bean> <!-- 配置一个数据库的操作模板：JdbcTemplate --> <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"></property> </bean>    <!-- 配置数据源 --> <p><bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"><br><property name="driverClassName" value="com.mysql.jdbc.Driver"></property><br><property name="url" value="jdbc:mysql:///spring_day04"></property><br><property name="username" value="root"></property><br><property name="password" value="1234"></property><br></bean><br><br>思考：<br>此种方式有什么问题吗?<br>答案：<br>有个小问题。就是我们的 dao 有很多时，每个 dao 都有一些重复性的代码。下面就是重复代码：<br>private JdbcTemplate jdbcTemplate;<br>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {<br>this.jdbcTemplate = jdbcTemplate;<br>}<br>能不能把它抽取出来呢？<br>请看下一小节。<br>1.5.3 第二种方式：让 dao 继承 JdbcDaoSupport<br>JdbcDaoSupport 是 spring 框架为我们提供的一个类，该类中定义了一个 JdbcTemplate 对象，我们可以<br>直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下：<br>public abstract class JdbcDaoSupport extends DaoSupport {<br>//定义对象<br>private JdbcTemplate jdbcTemplate;<br>//set 方法注入数据源，判断是否注入了，注入了就创建 JdbcTemplate<br>public final void setDataSource(DataSource dataSource) {<br>if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource())<br>{<br>//如果提供了数据源就创建 JdbcTemplate<br>this.jdbcTemplate = createJdbcTemplate(dataSource);<br>initTemplateConfig();<br>}<br>}<br>//使用数据源创建 JdcbTemplate<br>protected JdbcTemplate createJdbcTemplate(DataSource dataSource) {<br>return new JdbcTemplate(dataSource);<br>}<br>//当然，我们也可以通过注入 JdbcTemplate 对象<br>public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  </p><p>this.jdbcTemplate = jdbcTemplate;<br>initTemplateConfig();<br>}<br>//使用 getJdbcTmeplate 方法获取操作模板对象<br>public final JdbcTemplate getJdbcTemplate() {<br>return this.jdbcTemplate;<br>}<br>/** </p><ul><li>账户的接口 </li><li>/<br>public interface IAccountDao {<br>/** </li><li>根据 id 查询账户信息 </li><li>@param id </li><li>@return </li><li>/<br>Account findAccountById(Integer id);<br>/** </li><li>根据名称查询账户信息 </li><li>@return </li><li>/<br>Account findAccountByName(String name);<br>/** </li><li>更新账户信息 </li><li>@param account </li><li>/<br>void updateAccount(Account account);<br>}<br>/** </li><li>账户的持久层实现类 </li><li>此版本 dao，只需要给它的父类注入一个数据源 </li><li>/<br>public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao {<br>@Override<br>public Account findAccountById(Integer id) {<br>//getJdbcTemplate()方法是从父类上继承下来的。<br>List<Account> list = getJdbcTemplate().query(“select * from account where<br>id = ? “,new AccountRowMapper(),id);  </Account></li></ul><p>return list.isEmpty()?null:list.get(0);<br>}<br>@Override<br>public Account findAccountByName(String name) {<br>//getJdbcTemplate()方法是从父类上继承下来的。<br>List<Account> list = getJdbcTemplate().query(“select * from account where<br>name = ? “,new AccountRowMapper(),name);<br>if(list.isEmpty()){<br>return null;<br>}<br>if(list.size()&gt;1){<br>throw new RuntimeException(“结果集不唯一，不是只有一个账户对象”);<br>}<br>return list.get(0);<br>}<br>@Override<br>public void updateAccount(Account account) {<br>//getJdbcTemplate()方法是从父类上继承下来的。<br>getJdbcTemplate().update(“update account set money = ? where id = ?<br>“,account.getMoney(),account.getId());<br>}<br>}<br>配置文件：<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> </beans></Account></p><!-- 配置 dao2 --> <bean id="accountDao2" class="com.doyens.dao.impl.AccountDaoImpl2"> <!-- 注入 dataSource --> <property name="dataSource" ref="dataSource"></property> </bean> <!-- 配置数据源 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql:///spring_day04"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean>     思考： 两版 Dao 有什么区别呢？ 答案： 第一种在 Dao 类中定义 JdbcTemplate 的方式，适用于所有配置方式（xml 和注解都可以）。 第二种让 Dao 继承 JdbcDaoSupport 的方式，只能用于基于 XML 的方式，注解用不了。 </context:property-placeholder>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bean实例</title>
      <link href="/2022/03/22/Java/Spring/Bean/"/>
      <url>/2022/03/22/Java/Spring/Bean/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 容器管理的Java对象称为bean对象</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>singleton: </p><ul><li>单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。<br>prototype: </li><li>每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例<br>request: </li><li>对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。<br>session：</li><li>该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。<br>global session: </li><li>每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。</li></ul><p><strong>使用</strong><br>Spring默认使用singleton作用域<br>prototype作用域的Bean的创建、销毁代价比较大;而singleton作用域的Bean实例一旦创建，就可以重复使用;因此，<strong>应该尽量避免将Bean设置成prototype作用域</strong></p><h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h2><p>Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean</p><p><strong>方式一</strong><br>通过<beans>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用<br><strong>方式二</strong><br>通过对<bean>元素的autowire属性指定，该属性只对该Bean起作用</bean></beans></p><p><strong>autowire和default-autowire可以接受如下值</strong>：<br>no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。<br>byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。<br>byType: 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用。<br>constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。<br>autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。<br>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--通过设置可以将Bean排除在自动装配之外--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">autowire-candidate</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">default-autowire-candidates</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*abc<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h2 id="bean-的作用范围和生命周期"><a href="#bean-的作用范围和生命周期" class="headerlink" title="bean 的作用范围和生命周期"></a>bean 的作用范围和生命周期</h2><p><strong>单例对象：scope=”singleton”</strong><br>一个应用只有一个对象的实例。它的作用范围就是整个引用<br>生命周期： </p><ul><li>对象出生：当应用加载，创建容器时，对象就被创建了 </li><li>对象活着：只要容器在，对象一直活着</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了</li></ul><p><strong>多例对象：scope=”prototype”</strong><br>每次访问对象时，都会重新创建对象实例<br>生命周期： </p><ul><li>对象出生：当使用对象时，创建新的对象实例</li><li>对象活着：只要对象在使用中，就一直活着</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。GC垃圾回收机制 <pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.dao.impl.AccountDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> </code></pre></li></ul><h2 id="实例化-Bean-的三种方式"><a href="#实例化-Bean-的三种方式" class="headerlink" title="实例化 Bean 的三种方式"></a>实例化 Bean 的三种方式</h2><ul><li>使用默认无参构造函数 </li></ul><p><strong>根据默认无参构造函数来创建类对象;如果 bean 中没有默认无参构造函数，将会创建失败</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><ul><li><p>使用静态工厂的方法创建对象<br>使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 </p><pre class=" language-Java"><code class="language-Java">public class StaticFactory &#123; public static IAccountService createAccountService()&#123;   return new AccountServiceImpl(); &#125; &#125; </code></pre><p>id 属性：指定 bean 的 id，用于从容器中获取<br>class 属性：指定静态工厂的全限定类名<br>factory-method 属性：指定生产对象的静态方法 </p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.factory.StaticFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createAccountService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li><li><p>使用实例工厂的方法创建对象<br>此工厂创建对象，必须先有工厂实例对象，再调用方法 </p><pre class=" language-Java"><code class="language-Java">public class InstanceFactory &#123; public IAccountService createAccountService()&#123;   return new AccountServiceImpl(); &#125; &#125;</code></pre><p>先将工厂的创建交给 spring 来管理;然后让使用工厂的 bean 来调用方法<br>factory-bean 属性：用于指定实例工厂 bean 的 id。<br>factory-method 属性：用于指定实例工厂中创建对象的方法。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instancFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.factory.InstanceFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instancFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createAccountService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2022/03/22/Java/Spring/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/03/22/Java/Spring/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="基于xml配置"><a href="#基于xml配置" class="headerlink" title="基于xml配置"></a>基于xml配置</h2><h2 id="基于注解配置"><a href="#基于注解配置" class="headerlink" title="基于注解配置"></a>基于注解配置</h2><p>第2章 Spring 中的事务控制<br>2.1Spring 事务控制我们要明确的<br>第一：JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计业务层的事务处理解决方案。<br>第二：spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在<br>spring-tx-5.0.2.RELEASE.jar 中。<br>第三：spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。<br>2.2Spring 中事务控制的 API 介绍<br>2.2.1 PlatformTransactionManager<br>此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法，如下图：<br>我们在开发中都是使用它的实现类，如下图：  </p><p>真正管理事务的对象<br>org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 Spring<br>JDBC 或 iBatis 进行持久化数据时使用<br>org.springframework.orm.hibernate5.HibernateTransactionManager<br>使用<br>Hibernate 版本进行持久化数据时使用<br>2.2.2 TransactionDefinition<br>它是事务的定义信息对象，里面有如下方法：  </p><p>2.2.2.1 事务的隔离级别 </p><p>2.2.2.2 事务的传播行为<br>REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）<br>SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）<br>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常<br>REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。<br>NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>NEVER:以非事务方式运行，如果当前存在事务，抛出异常<br>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。<br>2.2.2.3 超时时间<br>默认值是-1，没有超时限制。如果有，以秒为单位进行设置。<br>2.2.2.4 是否是只读事务<br>建议查询时设置为只读。<br>2.2.3 TransactionStatus<br>此接口提供的是事务具体的运行状态，方法介绍如下图： </p><p>2.3基于 XML 的声明式事务控制（配置方式）重点<br>2.3.1 环境搭建<br>2.3.1.1 第一步：拷贝必要的 jar 包到工程的 lib 目录 </p><p>2.3.1.2 第二步：创建 spring 的配置文件并导入约束<br>此处需要导入 aop 和 tx 两个名称空间<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"><br></beans><br>2.3.1.3 第三步：准备数据库表和实体类<br>创建数据库：<br>create database spring_day04;<br>use spring_day04;<br>创建表：<br>create table account(<br>id int primary key auto_increment,<br>name varchar(40),<br>money float<br>)character set utf8 collate utf8_general_ci;<br>/** </p><ul><li>账户的实体 </li><li>/<br>public class Account implements Serializable {<br>private Integer id;<br>private String name;<br>private Float money;<br>public Integer getId() {<br>return id;<br>}<br>public void setId(Integer id) {<br>this.id = id;<br>}<br>public String getName() {  </li></ul><p>return name;<br>}<br>public void setName(String name) {<br>this.name = name;<br>}<br>public Float getMoney() {<br>return money;<br>}<br>public void setMoney(Float money) {<br>this.money = money;<br>}<br>@Override<br>public String toString() {<br>return “Account [id=” + id + “, name=” + name + “, money=” + money + “]”;<br>}<br>}<br>2.3.1.4 第四步：编写业务层接口和实现类<br>/** </p><ul><li>账户的业务层接口 </li><li>/<br>public interface IAccountService {<br>/** </li><li>根据 id 查询账户信息 </li><li>@param id </li><li>@return </li><li>/<br>Account findAccountById(Integer id);//查<br>/** </li><li>转账 </li><li>@param sourceName<br>转出账户名称 </li><li>@param targeName<br>转入账户名称 </li><li>@param money<br>转账金额 </li><li>/<br>void transfer(String sourceName,String targeName,Float money);//增删改<br>}<br>/** </li><li>账户的业务层实现类 </li><li>/<br>public class AccountServiceImpl implements IAccountService {  </li></ul><p>private IAccountDao accountDao;<br>public void setAccountDao(IAccountDao accountDao) {<br>this.accountDao = accountDao;<br>}<br>@Override<br>public Account findAccountById(Integer id) {<br>return accountDao.findAccountById(id);<br>}<br>@Override<br>public void transfer(String sourceName, String targeName, Float money) {<br>//1.根据名称查询两个账户<br>Account source = accountDao.findAccountByName(sourceName);<br>Account target = accountDao.findAccountByName(targeName);<br>//2.修改两个账户的金额<br>source.setMoney(source.getMoney()-money);//转出账户减钱<br>target.setMoney(target.getMoney()+money);//转入账户加钱<br>//3.更新两个账户<br>accountDao.updateAccount(source);<br>int i=1/0;<br>accountDao.updateAccount(target);<br>}<br>}<br>2.3.1.5 第五步：编写 Dao 接口和实现类<br>/** </p><ul><li>账户的持久层接口 </li><li>/<br>public interface IAccountDao {<br>/** </li><li>根据 id 查询账户信息 </li><li>@param id </li><li>@return </li><li>/<br>Account findAccountById(Integer id);<br>/** </li><li>根据名称查询账户信息 </li><li>@return  </li><li>/<br>Account findAccountByName(String name);<br>/** </li><li>更新账户信息 </li><li>@param account </li><li>/<br>void updateAccount(Account account);<br>}<br>/** </li><li>账户的持久层实现类 </li><li>此版本 dao，只需要给它的父类注入一个数据源 </li><li>/<br>public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {<br>@Override<br>public Account findAccountById(Integer id) {<br>List<Account> list = getJdbcTemplate().query(“select * from account where<br>id = ? “,new AccountRowMapper(),id);<br>return list.isEmpty()?null:list.get(0);<br>}<br>@Override<br>public Account findAccountByName(String name) {<br>List<Account> list = getJdbcTemplate().query(“select * from account where<br>name = ? “,new AccountRowMapper(),name);<br>if(list.isEmpty()){<br>return null;<br>}<br>if(list.size()&gt;1){<br>throw new RuntimeException(“结果集不唯一，不是只有一个账户对象”);<br>}<br>return list.get(0);<br>}<br>@Override<br>public void updateAccount(Account account) {<br>getJdbcTemplate().update(“update account set money = ? where id = ?<br>“,account.getMoney(),account.getId());<br>}<br>}<br>/** </Account></Account></li><li>账户的封装类 RowMapper 的实现类  </li><li>/<br>public class AccountRowMapper implements RowMapper<Account>{<br>@Override<br>public Account mapRow(ResultSet rs, int rowNum) throws SQLException {<br>Account account = new Account();<br>account.setId(rs.getInt(“id”));<br>account.setName(rs.getString(“name”));<br>account.setMoney(rs.getFloat(“money”));<br>return account;<br>}<br>} </Account></li></ul><p>2.3.1.6 第六步：在配置文件中配置业务层和持久层对 </p><!-- 配置 service --> <bean id="accountService" class="com.doyens.service.impl.AccountServiceImpl"> <property name="accountDao" ref="accountDao"></property> </bean> <!-- 配置 dao --> <bean id="accountDao" class="com.doyens.dao.impl.AccountDaoImpl"> <!-- 注入 dataSource --> <property name="dataSource" ref="dataSource"></property> </bean> <!-- 配置数据源 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql:///spring_day04"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean> 2.3.2 配置步骤 2.3.2.1 第一步：配置事务管理器 <!-- 配置一个事务管理器 --> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">    <!-- 注入 DataSource --> <p><property name="dataSource" ref="dataSource"></property><br></p></bean><br>2.3.2.2 第二步：配置事务的通知引用事务管理器 <p></p><!-- 事务的配置 --> <p>&lt;tx:advice id=”txAdvice” transaction-manager=”transactionManager”&gt;<br><br>2.3.2.3 第三步：配置事务的属性 </p><!--在 tx:advice 标签内部 配置事务的属性 --> <p><a href="tx:attributes">tx:attributes</a> </p><!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。 没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回 滚。没有默认值，任何异常都回滚。 --> <p>&lt;tx:method name=”*” read-only=”false” propagation=”REQUIRED”/&gt;<br>&lt;tx:method name=”find*” read-only=”true” propagation=”SUPPORTS”/&gt;<br><br>2.3.2.4 第四步：配置 AOP 切入点表达式 </p><!-- 配置 aop --> <p><a href="aop:config">aop:config</a> </p><!-- 配置切入点表达式 --> <p>&lt;aop:pointcut<br>expression=”execution(* com.doyens.service.impl.*.*(..))”<br>id=”pt1”/&gt;<br><br>2.3.2.5 第五步：配置切入点表达式和事务通知的对应关系 </p><!-- 在 aop:config 标签内部：建立事务的通知和切入点表达式的关系 --> <p>&lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”pt1”/&gt;  </p><p>2.4基于注解的配置方式<br>2.4.1 环境搭建<br>2.4.1.1 第一步：拷贝必备的 jar 包到工程的 lib 目录<br>2.4.1.2 第二步：创建 spring 的配置文件导入约束并配置扫描的包<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> </beans></p><!-- 配置 spring 创建容器时要扫描的包 --> <p>&lt;context:component-scan base-package=”com.doyens”&gt; </p><!-- 配置 JdbcTemplate-->  <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"></property> </bean> <!-- 配置 spring 提供的内置数据源 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.jdbc.Driver"></property> <property name="url" value="jdbc:mysql://localhost:3306/spring_day02"></property> <property name="username" value="root"></property> <property name="password" value="1234"></property> </bean>  2.4.1.3 第三步：创建数据库表和实体类 和基于 xml 的配置相同。略 2.4.1.4 第四步：创建业务层接口和实现类并使用注解让 spring 管理 /** * 账户的业务层实现类 */ @Service("accountService") public class AccountServiceImpl implements IAccountService { @Autowired private IAccountDao accountDao; //其余代码和基于 XML 的配置相同 } 2.4.1.5 第五步：创建 Dao 接口和实现类并使用注解让 spring 管理 /** * 账户的持久层实现类 */ @Repository("accountDao") public class AccountDaoImpl implements IAccountDao { @Autowired    <p>private JdbcTemplate jdbcTemplate;<br>//其余代码和基于 XML 的配置相同<br>}<br>2.4.2 配置步骤<br>2.4.2.1 第一步：配置事务管理器并注入数据源 </p><!-- 配置事务管理器 --> <p><bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br><property name="dataSource" ref="dataSource"></property><br></bean><br>2.4.2.2 第二步：在业务层使用@Transactional 注解<br>@Service(“accountService”)<br>@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)<br>public class AccountServiceImpl implements IAccountService {<br>@Autowired<br>private IAccountDao accountDao;<br>@Override<br>public Account findAccountById(Integer id) {<br>return accountDao.findAccountById(id);<br>}<br>@Override<br>@Transactional(readOnly=false,propagation=Propagation.REQUIRED)<br>public void transfer(String sourceName, String targeName, Float money) {<br>//1.根据名称查询两个账户<br>Account source = accountDao.findAccountByName(sourceName);<br>Account target = accountDao.findAccountByName(targeName);<br>//2.修改两个账户的金额<br>source.setMoney(source.getMoney()-money);//转出账户减钱<br>target.setMoney(target.getMoney()+money);//转入账户加钱<br>//3.更新两个账户<br>accountDao.updateAccount(source);<br>//int i=1/0;<br>accountDao.updateAccount(target);  </p><p>}<br>}<br>该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。<br>出现接口上，表示该接口的所有实现类都有事务支持。<br>出现在类上，表示类中所有方法有事务支持<br>出现在方法上，表示方法有事务支持。<br>以上三个位置的优先级：方法&gt;类&gt;接口<br>2.4.2.3 第三步：在配置文件中开启 spring 对注解事务的支持 </p><!-- 开启 spring 对注解事务的支持 --> <p>&lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt;<br>2.4.3 不使用 xml 的配置方式<br>@Configuration<br>@EnableTransactionManagement<br>public class SpringTxConfiguration {<br>//里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。<br>}<br>第3章 Spring5 的新特性[了解]<br>3.1与 JDK 相关的升级<br>3.1.1 jdk 版本要求：<br>spring5.0 在 2017 年 9 月发布了它的 GA（通用）版本。该版本是基于 jdk8 编写的，所以 jdk8 以下版本将无法使用。同时，可以兼容 jdk9 版本。<br>tomcat 版本要求 8.5 及以上。<br>注：<br>我们使用 jdk8 构建工程，可以降版编译。但是不能使用 jdk8 以下版本构建工程。<br>由于 jdk 和 tomcat 版本的更新，我们的 IDE 也需要同时更新。(目前使用的 eclipse 4.7.2)<br>3.1.2 利用 jdk8 版本更新的内容<br>第一：基于 JDK8 的反射增强<br>请看下面的代码：  </p><p>/** </p><ul><li></li><li>@author  德源教育 </li><li>@Company <a href="http://doyens-edu.com/">http://doyens-edu.com/</a> </li><li>@Version 1.0 </li><li>/<br>public class Test {<br>//循环次数定义：10 亿次<br>private static final int loopCnt = 1000 * 1000 * 1000;<br>public static void main(String[] args) throws Exception {<br>//输出 jdk 的版本<br>System.out.println(“java.version=” + System.getProperty(“java.version”));<br>t1();<br>t2();<br>t3();<br>}<br>// 每次重新生成对象<br>public static void t1() {<br>long s = System.currentTimeMillis();<br>for (int i = 0; i &lt; loopCnt; i++) {<br>Person p = new Person();<br>p.setAge(31);<br>}<br>long e = System.currentTimeMillis();<br>System.out.println(“循环 10 亿次创建对象的时间：” + (e - s));<br>}<br>// 同一个对象<br>public static void t2() {<br>long s = System.currentTimeMillis();<br>Person p = new Person();<br>for (int i = 0; i &lt; loopCnt; i++) {<br>p.setAge(32);<br>}<br>long e = System.currentTimeMillis();<br>System.out.println(“循环 10 亿次给同一对象赋值的时间： “ + (e - s));<br>}<br>//使用反射创建对象<br>public static void t3() throws Exception {<br>long s = System.currentTimeMillis();  </li></ul><p>Class<Person> c = Person.class;<br>Person p = c.newInstance();<br>Method m = c.getMethod(“setAge”, Integer.class);<br>for (int i = 0; i &lt; loopCnt; i++) {<br>m.invoke(p, 33);<br>}<br>long e = System.currentTimeMillis();<br>System.out.println(“循环 10 亿次反射创建对象的时间：” + (e - s));<br>}<br>static class Person {<br>private int age = 20;<br>public int getAge() {<br>return age;<br>}<br>public void setAge(Integer age) {<br>this.age = age;<br>}<br>}<br>}<br>jdk1.8 版本（就是 JDK8）运行时间如下： </Person></p><p>当切换到 jdk1.7 版本之后，运行时间如下： </p><p>有此我们可以看出，在反射创建对象上，jdk8 确实做了加强。<br>第二：@NonNull 注解和@Nullable 注解的使用<br>用 @Nullable 和 @NotNull 注解来显示表明可为空的参数和以及返回值。这样就够在编译的时候处<br>理空值而不是在运行时抛出 NullPointerExceptions。<br>第三：日志记录方面<br>Spring Framework 5.0 带来了 Commons Logging 桥接模块的封装, 它被叫做 spring-jcl 而<br>不是标准的 Commons Logging。当然，无需任何额外的桥接，新版本也会对 Log4j 2.x, SLF4J, JUL<br>( java.util.logging) 进行自动检测。  </p><p>3.2核心容器的更新<br>Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中<br>添加，以简化添加候选组件标识的步骤。<br>应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是<br>自包含的，JPA 实体和 Spring 组件是已被标记的。<br>从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。<br>加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。<br>加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数,<br>不过对于组件扫描而言，启动时间则会有明显的增长。<br>这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20<br>或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮<br>助你每天过的更加高效。<br>你可以在 Spring 的 Jira 上了解更多关于组件索引的相关信息。<br>3.3JetBrains Kotlin 语言支持<br>Kolin概述：是一种支持函数式编程编程风格的面向对象语言。Kotlin 运行在 JVM 之上，但运行环境并不<br>限于 JVM。<br>Kolin 的示例代码：<br>{<br>(“/movie” and accept(TEXT_HTML)).nest {<br>GET(“/“, movieHandler::findAllView)<br>GET(“/{card}”, movieHandler::findOneView)<br>}<br>(“/api/movie” and accept(APPLICATION_JSON)).nest {<br>GET(“/“, movieApiHandler::findAll)<br>GET(“/{id}”, movieApiHandler::findOne)<br>}<br>}<br>Kolin 注册 bean 对象到 spring 容器：<br>val context = GenericApplicationContext {<br>registerBean()<br>registerBean { Cinema(it.getBean()) }<br>}  </p><p>3.4响应式编程风格<br>此次 Spring 发行版本的一个激动人心的特性就是新的响应式堆栈 WEB 框架。这个堆栈完全的响应式且非<br>阻塞，适合于事件循环风格的处理，可以进行少量线程的扩展。<br>Reactive Streams 是来自于 Netflix, Pivotal, Typesafe, Red Hat, Oracle, Twitter 以及<br>Spray.io 的工程师特地开发的一个 API。它为响应式编程实现的实现提供一个公共的 API，好实现<br>Hibernate 的 JPA。这里 JPA 就是这个 API, 而 Hibernate 就是实现。<br>Reactive Streams API 是 Java 9 的官方版本的一部分。在 Java 8 中, 你会需要专门引入依赖来使<br>用 Reactive Streams API。<br>Spring Framework 5.0 对于流式处理的支持依赖于 Project Reactor 来构建, 其专门实现了<br>Reactive Streams API。<br>Spring Framework 5.0 拥有一个新的 spring-webflux 模块，支持响应式 HTTP 和 WebSocket 客<br>户端。Spring Framework 5.0 还提供了对于运行于服务器之上，包含了 REST, HTML, 以及 WebSocket 风<br>格交互的响应式网页应用程序的支持。<br>在 spring-webflux 中包含了两种独立的服务端编程模型：<br>基于注解：使用到了@Controller 以及 Spring MVC 的其它一些注解；<br>使用 Java 8 lambda 表达式的函数式风格的路由和处理。<br>有 了 Spring Webflux, 你现在可以创建出 WebClient, 它是响应式且非阻塞的，可以作为<br>RestTemplate 的一个替代方案。<br>这里有一个使用 Spring 5.0 的 REST 端点的 WebClient 实现：<br>WebClient webClient = WebClient.create();<br>Mono person = webClient.get()<br>.uri(“<a href="http://localhost:8080/movie/42&quot;">http://localhost:8080/movie/42&quot;</a>)<br>.accept(MediaType.APPLICATION_JSON)<br>.exchange()<br>.then(response -&gt; response.bodyToMono(Movie.class));<br>3.5Junit5 支持<br>完全支持 JUnit 5 Jupiter，所以可以使用 JUnit 5 来编写测试以及扩展。此外还提供了一个编程以及<br>扩展模型，Jupiter 子项目提供了一个测试引擎来在 Spring 上运行基于 Jupiter 的测试。<br>另外，Spring Framework 5 还提供了在 Spring TestContext Framework 中进行并行测试的扩展。<br>针对响应式编程模型， spring-test 现在还引入了支持 Spring WebFlux 的 WebTestClient 集成测<br>试的支持，类似于 MockMvc，并不需要一个运行着的服务端。使用一个模拟的请求或者响应， WebTestClient<br>就可以直接绑定到 WebFlux 服务端设施。<br>你可以在这里找到这个激动人心的 TestContext 框架所带来的增强功能的完整列表。<br>当然， Spring Framework 5.0 仍然支持我们的老朋友 JUnit! 在我写这篇文章的时候， JUnit 5 还<br>只是发展到了 GA 版本。对于 JUnit4， Spring Framework 在未来还是要支持一段时间的。<br>3.6依赖类库的更新<br>终止支持的类库  </p><p>Portlet.<br>Velocity.<br>JasperReports.<br>XMLBeans.<br>JDO.<br>Guava.<br>支持的类库<br>Jackson 2.6+<br>EhCache 2.10+ / 3.0 GA<br>Hibernate 5.0+<br>JDBC 4.0+<br>XmlUnit 2.x+<br>OkHttp 3.x+<br>Netty 4.1+</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP(面向切面)</title>
      <link href="/2022/03/21/Java/Spring/AOP/"/>
      <url>/2022/03/21/Java/Spring/AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>在程序运行期间，不修改源码对已有方法进行增强</p><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><p>减少重复代码<br>提高开发效率<br>维护方便</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>使用动态代理技术 </p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>Joinpoint：连接点<br>含义:指那些被拦截到的点。在 spring 中,这些点指的是方法（被增强的方法）</li><li>Pointcut：切入点。<br>含义:切入点是指我们要对哪些 Joinpoint 进行拦截的定义（业务层没有被增强的方法）</li><li>Advice：通知。<br>含义:拦截到 Joinpoint 之后要做的事情<br>通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 </li><li>Introduction(引介):<br>引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</li><li>Target(目标对象):<br>代理的目标对象。 </li><li>Weaving(织入):<br>是指把增强应用到目标对象来创建新的代理对象的过程。<br>spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 </li><li>Proxy（代理对象）:<br>一个类被 AOP 织入增强后，就产生一个结果代理对象</li><li>Aspect(切面):<br>是切入点和通知（引介）的结合</li></ul><h2 id="基于xml的aop配置"><a href="#基于xml的aop配置" class="headerlink" title="基于xml的aop配置"></a>基于xml的aop配置</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logger<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token comment" spellcheck="true">&lt;!--配置通知的类型，建立通知方法和切入点方法的关联--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>printLog<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(public void cn.dy.service.impl.AccountServiceImpl.addAccount())<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>before</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span></code></pre><p>切入点表达式：<br>      关键字：execution(表达式)<br>    表达式：<br>       访问修饰符 返回值类型 包名.包名…类名.方法名(参数列表)<br>    例子：<br>       public void cn.dy.service.impl.AccountServiceImpl.addAccount()<br>全通配的写法：</p><ul><li><em>..</em>.*(..)<br>匹配任意返回值类型，类型包下的任意类的任意方法<br>访问权限修饰符可以省略<br>void cn.dy.service.impl.AccountServiceImpl.addAccount()<br>返回值可以使用通配符，表示任意类型的返回值</li><li>cn.dy.service.impl.AccountServiceImpl.addAccount()<br>包名可以使用通配符，表示任意包.（有几级，就得几个*）</li><li><em>.</em>.<em>.</em>.AccountServiceImpl.addAccount()<br>包名可以使用..表示当前包和子类</li><li>*..AccountServiceImpl.addAccount()<br>类名和方法名也可以使用通配符</li><li><em>..</em>.<em>()<br>参数列表也可以直接写成参数类型<br>基本类型：   int<br>字符串：     java.lang.String<br>类型可以使用通配符</em>表示任意类型<br>类型使用..表示有无参数都可<br>实际开发中切入点表达式的通常写法：<br>切到业务层实现类下的所有方法</li><li>cn.dy.service.impl.<em>.</em>(..)</li></ul><h2 id="Advice-通知类型："><a href="#Advice-通知类型：" class="headerlink" title="Advice 通知类型："></a>Advice 通知类型：</h2><p>前置通知：<code>aop:before</code><br>后置通知：<code>aop:after-returning</code><br>异常通知：<code>aop:after-throwing</code><br>最终通知：<code>aop:after</code></p><p>环绕通知：<code>aop:around</code><br><strong>注意:通常情况下，环绕通知都是独立使用的</strong></p><h2 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h2><p>注解类型的通知类型会出现顺序错误的情况</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于注解配置</title>
      <link href="/2022/03/19/Java/Spring/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/03/19/Java/Spring/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解配置和 xml 配置实现的功能都一样<br>都是要降低程序间的耦合。只是配置的形式不一样<br>两种配置方式都需要掌握</p><h2 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h2><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>作用： 资源让 spring 来管理。相当于在 xml 中配置一个 bean<br>属性：<br>  value：指定 bean 的 id。如果不指定 value ，默认 bean 的 id 是当前类的类名。首字母小写。 </p><h3 id="Controller-Service-Repository"><a href="#Controller-Service-Repository" class="headerlink" title="@Controller @Service @Repository"></a>@Controller @Service @Repository</h3><p>这三个注解是针对@Component的衍生注解，作用及属性都是一样的<br><strong>提供了更加明确的语义化</strong><br>@Controller：用于表现层的注解。<br>@Service：用于业务层的注解。<br>@Repository：用于持久层的注解。<br>属性：<br>  value：指定 bean 的 id。如果不指定 value ，默认 bean 的 id 是当前类的类名。首字母小写</p><h2 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h2><p>相当于：<property name ref value> </property></p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>作用：<br>自动按照类型注入。当使用注解注入属性时，set 方法可以省略。它只能注入其他 bean 类型。当有多个<br>类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到<br>就报错;如果IOC容器中有多个类型匹配时，报错<br>出现位置：<br>可以是成员变量，也可以是方法上。<br>细节：<br>在使用注解输入时，set方法可以省略。</p><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>作用：<br>在自动按照类型注入的基础之上，再按照 Bean 的 id 注入<br><strong>给字段注入时，必须和 @Autowire 一起使用；给方法参数注入时，可以独立使用</strong><br>属性：<br>value：指定 bean 的 id。 </p><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>作用：<br>直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。<br>属性：<br>name：指定 bean 的 id。 </p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>作用：<br>注入基本数据类型和 String 类型数据的<br>属性：<br>value：用于指定值 </p><h2 id="用于改变作用范围的："><a href="#用于改变作用范围的：" class="headerlink" title="用于改变作用范围的："></a>用于改变作用范围的：</h2><p>相当于：<bean id class scope> </bean></p><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>作用：<br>指定 bean 的作用范围。<br>属性：<br>value：指定范围的值<br>取值：singleton prototype request session globalsession </p><h2 id="和生命周期相关的：-了解"><a href="#和生命周期相关的：-了解" class="headerlink" title="和生命周期相关的：(了解)"></a>和生命周期相关的：(了解)</h2><p>相当于：<bean id class init-method destroy-method></bean></p><h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>作用：<br>用于指定初始化方法。 </p><h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h3><p>作用：<br>用于指定销毁方法。 </p><h2 id="Spring-注解和-XML-的选择问题"><a href="#Spring-注解和-XML-的选择问题" class="headerlink" title="Spring 注解和 XML 的选择问题"></a>Spring 注解和 XML 的选择问题</h2><p>注解的优势：<br>配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。<br>XML 的优势：<br>修改时，不用改源码。不涉及重新编译和部署。<br>Spring 管理 Bean 方式的比较</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>作用：<br>用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用<br>AnnotationApplicationContext(有@Configuration 注解的类.class)。<br>属性：<br>value:用于指定配置类的字节码<br>示例代码： </p><pre class=" language-Java"><code class="language-Java">@Configuration public class SpringConfiguration &#123; &#125; </code></pre><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>作用：<br>用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：<br>&lt;context:component-scan base-package=”com.doyens”/&gt;是一样的。<br>属性：<br>basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。<br>示例代码： </p><pre class=" language-Java"><code class="language-Java">@Configuration @ComponentScan("com.doyens") public class SpringConfiguration &#123; &#125; </code></pre><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>作用：<br>该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。<br>属性：<br>name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。<br>示例代码：</p><pre class=" language-Java"><code class="language-Java">public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser("root"); ds.setPassword("root"); ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setJdbcUrl("jdbc:mysql:///spring_day02"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name="dbAssit") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSource); &#125; &#125; </code></pre><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p>作用：<br>用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到<br>properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。<br>属性：<br>value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:<br>示例代码：<br>配置： </p><pre class=" language-Java"><code class="language-Java">public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; </code></pre><p>jdbc.properties 文件：<br>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/db3  </p><p>jdbc.username=root<br>jdbc.password=root </p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>作用：<br>建立配置类之间的联系<br>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问<br>题。<br>属性：<br>value[]：用于指定其他配置类的字节码。<br>示例代码： </p><pre class=" language-Java"><code class="language-Java">@Configuration @ComponentScan(basePackages = "com.doyens.spring") @Import(&#123; JdbcConfig.class&#125;) public class SpringConfiguration &#123; &#125; @Configuration @PropertySource("classpath:jdbc.properties") public class JdbcConfig&#123; &#125; </code></pre><p>通过注解获取容器：<br>ApplicationContext ac =<br>new AnnotationConfigApplicationContext(SpringConfiguration.class); </p><h2 id="Spring-整合-Junit-掌握"><a href="#Spring-整合-Junit-掌握" class="headerlink" title="Spring 整合 Junit[掌握]"></a>Spring 整合 Junit[掌握]</h2><p>配置步骤 </p><ul><li>拷贝整合 junit 的必备 jar 包到 lib 目录<br>此处需要注意的是，导入 jar 包时，需要导入一个 spring 中 aop 的 jar 包。  </li><li>使用@RunWith 注解替换原有运行器 <pre class=" language-Java"><code class="language-Java">@RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest &#123; &#125; </code></pre></li><li>使用@ContextConfiguration 指定 spring 配置文件的位置 <pre class=" language-Java"><code class="language-Java">@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;) public class AccountServiceTest &#123; &#125; </code></pre></li></ul><p><strong>@ContextConfiguration 注解：</strong><br>locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明<br>classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。 </p><ul><li>使用@Autowired 给测试类中的变量注入数据 <pre class=" language-Java"><code class="language-Java">@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;) public class AccountServiceTest &#123; @Autowired private IAccountService as ; &#125; </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于xml配置</title>
      <link href="/2022/03/19/Java/Spring/%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/03/19/Java/Spring/%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>xml 配置和注解配置 实现的功能都一样<br>都是要降低程序间的耦合。只是配置的形式不一样<br>两种配置方式都需要掌握</p><h2 id="spring-的xml配置"><a href="#spring-的xml配置" class="headerlink" title="spring 的xml配置"></a>spring 的xml配置</h2><h2 id="xml版本号及编码格式"><a href="#xml版本号及编码格式" class="headerlink" title="xml版本号及编码格式"></a>xml版本号及编码格式</h2><p><strong>必须</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span></code></pre><h2 id="beans-spring配置根元素标签"><a href="#beans-spring配置根元素标签" class="headerlink" title="beans spring配置根元素标签"></a>beans spring配置根元素标签</h2><p><strong>必须</strong>,配置约束信息</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h2 id="context-component-scan-包扫描"><a href="#context-component-scan-包扫描" class="headerlink" title="context:component-scan 包扫描"></a>context:component-scan 包扫描</h2><p>作用:<br>  spring容器扫描该配置下的类,添加到spring容器中;多个bean时使用此标签<br><strong>beans标签的子标签</strong><br>属性<br>  base-package spring容器扫描的包路径;spring容器会将该路径下的bean添加到容器中</p><p>使用:<br>多个路径时,使用 <code>,</code>分隔</p><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.dy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span></code></pre><h2 id="bean-spring配置bean对象标签"><a href="#bean-spring配置bean对象标签" class="headerlink" title="bean  spring配置bean对象标签"></a>bean  spring配置bean对象标签</h2><p>bean 标签：<strong>beans标签的子标签</strong><br>作用：<br>用于配置bean对象，并且存入 ioc 容器之中;<br><strong>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功</strong><br>属性：<br>id：给对象在容器中提供一个唯一标识。用于获取对象。<br>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。<br>scope：指定对象的作用范围。 </p><ul><li>singleton :默认值，单例的. </li><li>prototype :多例的. </li><li>request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. </li><li>session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. </li><li>global session<br>WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么<br>globalSession: 相当于 session.<br>init-method：指定类中的初始化方法名称。<br>destroy-method：指定类中销毁方法名称。 </li></ul><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>标签位置：bean标签的内部<br>属性：<br>name：用于指定给构造方法中指定名称的参数赋值。<br>value：用于提供基本类型和String类型的数据<br>ref：用于指定其他bean的数据类型。指的是spring的IOC核心容器中出现过        的bean对象。<br>优势：<br>创建对象时没有明确限制，可以直接使用默认构造方法。<br>弊端：<br>如果某个成员必须有值，获取对象时有可能set方法没有执行。</p><p>使用</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre><h2 id="constructor-arg"><a href="#constructor-arg" class="headerlink" title="constructor-arg"></a>constructor-arg</h2><p>使用</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ds<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC</title>
      <link href="/2022/03/19/Java/Spring/IOC/"/>
      <url>/2022/03/19/Java/Spring/IOC/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring使用”依赖注入”的方式来管理Bean之间的依赖关系<br>依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起<br><strong>控制反转（Inverse of Control，IoC）,依赖注入（Dependency Injection）</strong>:<br>以配置文件来管理Java实例的协作关系<br>依赖注入，控制反转，其含义完全相同<br>使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。<br>从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入<br>Spring框架，就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质</p><h2 id="依赖注入IOC"><a href="#依赖注入IOC" class="headerlink" title="依赖注入IOC"></a>依赖注入IOC</h2><ul><li>设值注入<br>成员变量的setter方法来注入被依赖对象<br>这种注入方式简单、直观，因而在Spring的依赖注入里大量使用</li><li>构造注入<br>构造器来设置依赖关系的方式，被称为构造注入<br>驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，利用构造器参数对成员变量执行初始化——这就是构造注入的本质</li></ul><h2 id="两种注入方式的对比"><a href="#两种注入方式的对比" class="headerlink" title="两种注入方式的对比"></a>两种注入方式的对比</h2><ul><li>设值注入有如下优点：<br>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。<br>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。<br>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。</li><li>构造注入优势如下：<br>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。<br>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。<br>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</li></ul><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><strong>建议采用设值注入为主，构造注入为辅的注入策略。</strong><br><strong>对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</strong></p><h2 id="创建Bean的3种方式"><a href="#创建Bean的3种方式" class="headerlink" title="创建Bean的3种方式"></a>创建Bean的3种方式</h2><p>使用构造器创建Bean实例<br>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。<br>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。<br>使用静态工厂方法创建Bean<br>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。<br>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用&lt;constructor-arg…/&gt;元素指定静态工厂方法的参数。<br>调用实例工厂方法创建Bean<br>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的&lt;bean…/&gt;元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。<br>采用实例工厂方法创建Bean的&lt;bean…/&gt;元素时需要指定如下两个属性：<br>factory-bean: 该属性的值为工厂Bean的id。<br>factory-method: 该属性指定实例工厂的工厂方法。<br>若调用实例工厂方法时需要传入参数，则使用&lt;constructor-arg…/&gt;元素确定参数值。<br>协调作用域不同步的Bean<br>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。<br>解决不同步的方法有两种：<br>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。<br>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。<br>建议采用第二种方法，使用方法注入。为了使用lookup方法注入，大致需要如下两步：<br>将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。<br>在&lt;bean…/&gt;元素中添加&lt;lookup-method…/&gt;子元素让Spring为调用者Bean的实现类实现指定的抽象方法。<br>注意：<br>Spring会采用运行时动态增强的方式来实现&lt;lookup-method…/&gt;元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。<br>两种后处理器<br>Spring提供了两种常用的后处理器：<br>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。<br>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。<br>Bean后处理器<br>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。<br>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id<br>Object postProcessAfterinitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id<br>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：</p><p>注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。<br>BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(“bp”);<br>beanFactory.addBeanPostProcessor(bp);<br>Person p = (Person)beanFactory.getBean(“person”);<br>容器后处理器<br>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。<br>类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。<br>Spring的”零配置”支持<br>搜索Bean类<br>Spring提供如下几个Annotation来标注Spring Bean：<br>@Component: 标注一个普通的Spring Bean类<br>@Controller: 标注一个控制器组件类<br>@Service: 标注一个业务逻辑组件类<br>@Repository: 标注一个DAO组件类<br>在Spring配置文件中做如下配置，指定自动扫描的包：<br>&lt;context:component-scan base-package=”edu.shu.spring.domain”/&gt;<br>使用@Resource配置依赖<br>@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与&lt;property…/&gt;元素的ref属性有相同的效果。<br>@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。<br>使用@PostConstruct和@PreDestroy定制生命周期行为<br>@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。<br>Spring4.0增强的自动装配和精确装配<br>Spring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。<br>Spring的AOP<br>为什么需要AOP<br>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。<br>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。<br>使用AspectJ实现AOP<br>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。<br>AOP实现可分为两类：<br>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。<br>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。<br>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。<br>AOP的基本概念<br>关于面向切面编程的一些术语：<br>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。<br>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。<br>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型<br>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</p><p>Spring的AOP支持<br>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用@AspectJ支持，Spring需要添加三个库：<br>aspectjweaver.jar<br>aspectjrt.jar<br>aopalliance.jar<br>并在Spring配置文件中做如下配置：</p><!--启动@AspectJ支持--><p><a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></p><!--指定自动搜索Bean组件、自动搜索切面类--><p>&lt;context:component-scan base-package=”edu.shu.sprint.service”&gt;<br>    &lt;context:include-filter type=”annotation” expression=”org.aspectj.lang.annotation.Aspect”/&gt;<br></p><h2 id="spring-的依赖注入"><a href="#spring-的依赖注入" class="headerlink" title="spring 的依赖注入"></a>spring 的依赖注入</h2><p>依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。<br>我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况<br>ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。<br>那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 </p><h2 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h2><p>顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置<br>的方式，让 spring 框架来为我们注入。具体代码如下：<br>/**<br>*/<br>public class AccountServiceImpl implements IAccountService {<br>private String name;<br>private Integer age;<br>private Date birthday;<br>public AccountServiceImpl(String name, Integer age, Date birthday) {<br>this.name = name;<br>this.age = age;<br>this.birthday = birthday;<br>}<br>@Override<br>public void saveAccount() {<br>System.out.println(name+”,”+age+”,”+birthday);<br>}<br>} </p><!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型name:指定参数在构造函数中的名称 用这个找给谁赋值 =======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean --> <bean id="accountService" class="com.doyens.service.impl.AccountServiceImpl"> <constructor-arg name="name" value="张三"></constructor-arg> <constructor-arg name="age" value="18"></constructor-arg> <constructor-arg name="birthday" ref="now"></constructor-arg> </bean> <bean id="now" class="java.util.Date"></bean><h2 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h2><p>顾名思义，就是在类中提供需要注入成员的 set 方法。具体代码如下：<br>/** */<br>public class AccountServiceImpl implements IAccountService {<br>private String name;<br>private Integer age;<br>private Date birthday;<br>public void setName(String name) {<br>this.name = name;<br>}<br>public void setAge(Integer age) {<br>this.age = age;<br>}<br>public void setBirthday(Date birthday) {<br>this.birthday = birthday;<br>}<br>@Override<br>public void saveAccount() {<br>System.out.println(name+”,”+age+”,”+birthday);<br>}<br>} </p><!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式 涉及的标签： property属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。 --> <bean id="accountService" class="com.doyens.service.impl.AccountServiceImpl"> <property name="name" value="test"></property> <property name="age" value="21"></property> <property name="birthday" ref="now"></property> </bean> <bean id="now" class="java.util.Date"></bean> <h2 id="使用-p-名称空间注入数据（本"><a href="#使用-p-名称空间注入数据（本" class="headerlink" title="使用 p 名称空间注入数据（本"></a>使用 p 名称空间注入数据（本</h2><p>此种方式是通过在 xml 中导入 p 名称空间，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的<br>set 方法实现注入功能。<br>Java 类代码：<br>/** </p><ul><li>使用 p 名称空间注入，本质还是调用类中的 set 方法 </li><li>/<br>public class AccountServiceImpl4 implements IAccountService {<br>private String name;<br>private Integer age;<br>private Date birthday;<br>public void setName(String name) {<br>this.name = name;<br>}<br>public void setAge(Integer age) {<br>this.age = age;<br>}<br>public void setBirthday(Date birthday) {<br>this.birthday = birthday;<br>}<br>@Override<br>public void saveAccount() {<br>System.out.println(name+”,”+age+”,”+birthday);<br>}<br>}<br>配置文件代码：<br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br><bean id="accountService" class="com.doyens.service.impl.AccountServiceImpl4" p:name="test" p:age="21" p:birthday-ref="now"> </bean></beans> </li></ul><h2 id="注入集合属性"><a href="#注入集合属性" class="headerlink" title="注入集合属性"></a>注入集合属性</h2><p>给类中的集合成员传值，用的也是set方法注入的方式<br>我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： </p><pre class=" language-Java"><code class="language-Java">public class AccountServiceImpl implements IAccountService &#123;   private String[] myStrs;   private List<String> myList;   private Set<String> mySet;   private Map<String,String> myMap;   private Properties myProps;   public void setMyStrs(String[] myStrs) &#123;     this.myStrs = myStrs;   &#125;   public void setMyList(List<String> myList) &#123;     this.myList = myList;   &#125;   public void setMySet(Set<String> mySet) &#123;     this.mySet = mySet;   &#125;   public void setMyMap(Map<String, String> myMap) &#123;     this.myMap = myMap;   &#125;   public void setMyProps(Properties myProps) &#123;     this.myProps = myProps;   &#125;   @Override   public void saveAccount() &#123;     System.out.println(Arrays.toString(myStrs));     System.out.println(myList);     System.out.println(mySet);     System.out.println(myMap);    System.out.println(myProps);   &#125; &#125; </code></pre><p>注入集合数据<br>List 结构的<br>  array,list,set<br>Map 结构的<br>  map,entry,props,prop </p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.doyens.service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --></span>   <span class="token comment" spellcheck="true">&lt;!-- 给数组注入数据 --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myStrs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>AAA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>BBB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>CCC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- 注入 list 集合数据 --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myList<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>AAA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>BBB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>CCC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- 注入 set 集合数据 --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mySet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>AAA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>BBB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>CCC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- 注入 Map 数据 --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>aaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>bbb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- 注入 properties 数据 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myProps<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testA<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aaa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>testB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>bbb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring简介</title>
      <link href="/2022/03/17/Java/Spring/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/03/17/Java/Spring/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 是一款 Java SE/EE 轻量级开源框架<br>Spring 由“Spring 之父”Rod Johnson 提出并创立<br>目的是用于简化 Java 企业级应用的开发难度和开发周期<br><strong>Spring 框架不局限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益</strong><br>官网：<a href="https://spring.io/">https://spring.io/</a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>方便解耦，简化开发<br>Spring 就是一个大工厂，可以将对象的创建和依赖关系的维护交给 Spring 管理。</li><li>方便集成各种优秀框架<br>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis 等）的直接支持。</li><li>降低 Java EE API 的使用难度<br>Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。</li><li>方便程序的测试<br>Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。</li><li>AOP 编程的支持<br>Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。</li><li>声明式事务的支持<br>只需要通过配置就可以完成对事务的管理，而无须手动编程</li></ol><h2 id="Spring的核心机制"><a href="#Spring的核心机制" class="headerlink" title="Spring的核心机制"></a>Spring的核心机制</h2><p><strong>管理Bean</strong><br>程序通过Spring容器来访问容器中的Bean<br><code>ApplicationContext</code>是Spring容器最常用的接口，该接口有如下两个实现类：<br><code>ClassPathXmlApplicationContext</code>: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。<br><code>FileSystemXmlApplicationContext</code>: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</p><pre class=" language-Java"><code class="language-Java">public class BeanTest&#123;    public static void main(String args[]) throws Exception&#123;        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");        Person p = ctx.getBean("person", Person.class);        p.say();    &#125;&#125;</code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><strong>接口</strong><br>BeanFactory Spring容器顶层接口<br>ApplicationContext  BeanFactory的子接口<br>区别：<br>创建对象的时机不一样。<br>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象<br>BeanFactory：使用的时候创建对象<br><strong>ApplicationContext 接口的实现类</strong><br>基于xml的实现类<br>ClassPathXmlApplicationContext  从类的根路径下加载配置文件(xml)<strong>推荐</strong><br>FileSystemXmlApplicationContext 从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置<br>基于注解的实现类<br>AnnotationConfigApplicationContext  使用注解配置容器对象，使用此类创建 spring 容器。用来读取注解</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>Spring 容器管理的Java对象称为bean对象<br>创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质。</p><h2 id="Spring框架的组成结构-体系结构"><a href="#Spring框架的组成结构-体系结构" class="headerlink" title="Spring框架的组成结构(体系结构)"></a>Spring框架的组成结构(体系结构)</h2><p>表现层（web）、业务逻辑层（service）、持久层（dao）。<br><img src="/2022/03/17/Java/Spring/%E7%AE%80%E4%BB%8B/spring%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"></p><h2 id="接口-类-结构"><a href="#接口-类-结构" class="headerlink" title="接口(类)结构"></a>接口(类)结构</h2><p><img src="/2022/03/17/Java/Spring/%E7%AE%80%E4%BB%8B/spring%E6%8E%A5%E5%8F%A3(%E7%B1%BB)%E7%BB%93%E6%9E%84.png"></p><h2 id="Spring框架的核心功能有两个："><a href="#Spring框架的核心功能有两个：" class="headerlink" title="Spring框架的核心功能有两个："></a>Spring框架的核心功能有两个：</h2><p>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean<br>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系<br>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用<br>依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。<br><strong>控制反转（Inverse of Control，IoC）,依赖注入（Dependency Injection）</strong>:<br>以配置文件来管理Java实例的协作关系<br>依赖注入，控制反转，其含义完全相同<br>使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。<br>从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入</p><p><strong>AOP（面向切面）</strong></p><h2 id="spring-的使用"><a href="#spring-的使用" class="headerlink" title="spring 的使用"></a>spring 的使用</h2><ul><li><p>普通项目</p><ol><li>使用jar包</li></ol></li><li><p>maven项目</p><ol><li>pom.xml<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li>让 spring 管理资源，使用基于xml或基于注解的方式</li><li>创建spring容器,从spring容器中获取需要的bean对象</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis键(key)</title>
      <link href="/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%94%AE(key)/"/>
      <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%94%AE(key)/</url>
      
        <content type="html"><![CDATA[<p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><code>del key名称</code>存在时删除key</p><p><code>exists key名称</code>检查 key 是否存在<br><code>expire key seconds</code>给 key 设置过期时间，seconds为秒值<br><code>expireat key timestamp</code>给 key 设置过期时间，timestamp为UNIX时间戳<br><code>pexpire key milliseconds</code>给 key 设置过期时间,milliseconds为毫秒值</p><p>7    PEXPIREAT key milliseconds-timestamp<br>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计<br>8    KEYS pattern<br>查找所有符合给定模式( pattern)的 key 。<br>9    MOVE key db<br>将当前数据库的 key 移动到给定的数据库 db 当中。<br>10    PERSIST key<br>移除 key 的过期时间，key 将持久保持。<br>11    PTTL key<br>以毫秒为单位返回 key 的剩余的过期时间。<br>12    TTL key<br>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。<br>13    RANDOMKEY<br>从当前数据库中随机返回一个 key 。<br>14    RENAME key newkey<br>修改 key 的名称<br>15    RENAMENX key newkey<br>仅当 newkey 不存在时，将 key 改名为 newkey 。<br>16    SCAN cursor [MATCH pattern] [COUNT count]<br>迭代数据库中的数据库键。<br>17    TYPE key<br>返回 key 所储存的值的类型。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据类型</title>
      <link href="/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
      <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</url>
      
        <content type="html"><![CDATA[<p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h2><ul><li><code>SET key value</code>   设置 key 的值</li><li><code>GET key</code>         获取 key 的值</li><li><code>DEL key</code>         删除 key 的值</li><li><code>GETSET key value</code>将 key 的值设为 value ，并返回旧的value</li></ul><h2 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h2><ul><li><code>hset key field1 value1 field2 value2 ...</code>  存储</li><li><code>hget key field1 field2 ...</code>        获取</li><li><code>hget all key</code>          获取全部</li><li><code>hdel key field</code>        删除<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2></li><li>存储<ul><li><code>lpush key value</code>   将元素加到列表左边</li><li><code>rpush key value</code>   将元素加到列表右边</li></ul></li><li>获取<ul><li><code>lrange key start end</code>  范围获取   0，-1</li></ul></li><li>删除<ul><li><code>lpop key</code>    删除最左边的元素</li><li><code>rpop key</code>  删除最右边的元素<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2></li></ul></li><li><code>sadd key value</code>存储</li><li><code>smembers key</code>获取</li><li><code>srem key value</code>删除<h2 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合 sorted set"></a>有序集合 sorted set</h2></li><li><code>zadd key score value</code>存储</li><li><code>zrange key start end  0 -1</code>获取</li><li><code>zrem key value</code>删除</li></ul><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><ul><li><code>keys *</code>  ： 查询所有的键</li><li><code>type key</code> ：获取键对应值的类型。</li><li><code>del key</code>：  删除指定的key value</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库简介</title>
      <link href="/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据库主要是两种，即关系型数据库和非关系型数据库</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>关系型数据库RDBMS(存在表的概念,表与表之间可以存在联系)<br>关系型数据库模型是把复杂的数据结构归结为简单的表格形式<br>关系型数据库管理系统（RDBMS）用来存储和管理大数据量 所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ol><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ol><h3 id="常见的关系型数据库"><a href="#常见的关系型数据库" class="headerlink" title="常见的关系型数据库"></a>常见的关系型数据库</h3><p>Oracle<br>MySQL<br>Sql server<br>DB2</p><h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>关系数据库管理系统(Relational Database Management System)<br>RDBMS术语：<br>数据库: 数据库是一些关联表的集合。<br>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格<br>列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据<br>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据<br>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性<br>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据<br>外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引<br>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。<br>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>(需要尽量减少访问频率)<br>最好使用批量插入(批量插入速度可以快很多)</p><h2 id="非关系型数据库-没有表的概念-数据相互之间没有任何关系或联系"><a href="#非关系型数据库-没有表的概念-数据相互之间没有任何关系或联系" class="headerlink" title="非关系型数据库(没有表的概念,数据相互之间没有任何关系或联系)"></a>非关系型数据库(没有表的概念,数据相互之间没有任何关系或联系)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>非关系型数据库也称为NoSQL数据库，NOSQL的本意是“Not OlnlySQL”指的是非关系型数据库，NoSQL的产生并不是要否定关系型数据库，而是作为传统关系型数据库的一个有效补充<br>NOSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充 </li><li>NOSQL为了高性能、高并发而生，忽略影响高性能，高并发的功能 </li><li>NOSQL典型产品memcached （纯内存），redis（持久化缓存），mongodb（文档的数据库）</li></ol><h3 id="常见的非关系型数据库"><a href="#常见的非关系型数据库" class="headerlink" title="常见的非关系型数据库"></a>常见的非关系型数据库</h3><p>Redis<br>MongoDB</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis是用C语言开发的,开源的高性能非关系型(NOSQL)数据库<br>属于键值对（key-value）类型数据库</p><h2 id="数据类型-数据结构"><a href="#数据类型-数据结构" class="headerlink" title="数据类型(数据结构)"></a>数据类型(数据结构)</h2><p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>性能极高<br>丰富的数据类型<br>原子性 – 所有操作都是原子性的，要么成功执行要么失败完全不执行。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来<br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>   缓存（数据查询、短连接、新闻内容、商品内容等等）</li><li>   聊天室的在线好友列表</li><li>   任务队列。（秒杀、抢购、12306等等）</li><li>   应用排行榜</li><li>   网站访问统计</li><li>   数据过期处理（可以精确到毫秒)</li><li>   分布式集群架构中的session分离</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><code>del key名称</code>删除key</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>原理：当执行某些操作时，redis会将存储的数据写入到文件中。    当下次再次打开redis的时候，它会读取这个文件中的信息</p><p>redis是一款内存数据库，当redis服务器重启，或者电脑重启，数据会丢失;可以选择将redis的数据保持在硬盘上的文件中</p><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>ROB：默认方式，不需要进行配置，默认就是这种机制。</p><ul><li>在一定的间隔事件中，检测key的变化，然后持久化存储。<br>after 900 sec (15 min) if at least 1 key changed<br>after 300 sec (5 min) if at least 10 keys changed<br>after 60 sec if at least 10000 keys changed<br>save 900 1<br>save 300 10<br>save 60 10000</li></ul><p>AOF：日志记录的方式。可以记录每一次命令的操作，可以每一次命令操作后，        持久化数据。<br>appendonly yes<br>appendfsync always    每一次操作都会持久化。<br>appendfsync everysec     每隔一秒进行一次持久化。（默认的）<br>appendfsync no        不进行持久化。</p><p>rdb和aof的区别？（面试题）<br>rdb：自己设置有多少个key发生变化，持久化到硬盘一次。<br>aof：通过设置，每秒或每一次操作持久化一次。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断言</title>
      <link href="/2022/02/24/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%96%AD%E8%A8%80/"/>
      <url>/2022/02/24/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h2><p>断言实际上是一种测试机制，它可以规定某个参数或者属性必须要满足某个条件，否则会抛出一个异常，并且程序会中止</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 在Java中，<code>assert</code>关键字，表示断言<br> 在Java中，assert关键字是从<code>JAVA SE 1.4</code> 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，<code>Java在执行的时候默认是不启动断言检查的</code>（这个时候，所有的断言语句都 将忽略！），如果要开启断言检查，则需要用开关-enableassertions或-ea来开启　　</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>断言只用于开发测试阶段确定程序的内部错误<br>断言默认是禁用的，需要手动开启。禁用断言的情况下，类加载器会跳过断言代码<br>断言检测失败的时候，会抛出AssertionError异常，程序中止<br>断言可以局部开启的，如：父类禁止断言，而子类开启断言，所以一般说“断言不具有继承性”。<br>断言只适用复杂的调式过程。<br><strong><code>断言一般用于程序执行结构的判断，不能让断言处理业务流程</code></strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>断言是通过关键字 assert实现的，这个关键字有两种形式<br>assert 条件 和 assert 条件:表达式<br>这两种形式都会对条件进行检测，如果结果为false，则抛出一个<code>AssertionError</code>异常。<br>在assert 条件:表达式 这种形式中，表达式会被传入AssertionError的构造器，并将表达式转换成一个消息字符串。<br>如果条件的检测结果为true，则程序正常运行<br><strong>AssertionError是继承自Error，而不是Exception，所以catch用Exception是不能捕捉AssertionError信息的</strong></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">//  判断断言是否开启public static void main(String args[]) &#123;    boolean isOpen = false;    // 如果开启了断言，会将isOpen的值改为true    assert isOpen = true;    // 打印是否开启了断言，如果为false，则没有启用断言    System.out.println(isOpen);&#125;//  断言的使用方法一public static void useAssertExt1() &#123;    boolean isOk = 4 > 2;    assert isOk;    System.out.println("程序正常");    boolean isOk1 = 1 > 2;    assert isOk1;    System.out.println("程序正常");&#125;//  执行的结果://    1打印程序正常//    2抛出AssertionError </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/21/Java/Java%20%E5%8D%9A%E5%AE%A2/spring%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/02/21/Java/Java%20%E5%8D%9A%E5%AE%A2/spring%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>别瞎写工具类了，Spring自带的这些他不香麽？<br>点击关注 👉 Java技术迷 2022-02-15 13:26<br>点击关注公众号，Java干货及时送达图片</p><p>粉丝福利：小编会从今天留言的小伙伴中随机抽赠送8.88元现金红包。娱乐抽奖，大家随缘积极参与啦，给生活一点小幸运~感谢大家的支持图片</p><p>作者：CadeCode</p><p>来源：juejin.cn/post/7043403364020781064</p><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>断言是一个逻辑判断，用于检查不应该发生的情况</p><p>Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启</p><p>SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</p><p>// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行<br>// 参数 message 参数用于定制异常信息。<br>void notNull(Object object, String message)<br>// 要求参数必须空（Null），否则抛出异常，不予『放行』。<br>// 和 notNull() 方法断言规则相反<br>void isNull(Object object, String message)<br>// 要求参数必须为真（True），否则抛出异常，不予『放行』。<br>void isTrue(boolean expression, String message)<br>// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行<br>void notEmpty(Collection collection, String message)<br>// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行<br>void hasLength(String text, String message)<br>// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行<br>void hasText(String text, String message)<br>// 要求参数是指定类型的实例，否则抛出异常，不予放行<br>void isInstanceOf(Class type, Object obj, String message)<br>// 要求参数 <code>subType</code> 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行<br>void isAssignable(Class superType, Class subType, String message)</p><h1 id="对象、数组、集合"><a href="#对象、数组、集合" class="headerlink" title="对象、数组、集合"></a>对象、数组、集合</h1><p>ObjectUtils</p><p>1.获取对象的基本信息</p><p>// 获取对象的类名。参数为 null 时，返回字符串：”null”<br>String nullSafeClassName(Object obj)<br>// 参数为 null 时，返回 0<br>int nullSafeHashCode(Object object)<br>// 参数为 null 时，返回字符串：”null”<br>String nullSafeToString(boolean[] array)<br>// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0<br>String getIdentityHexString(Object obj)<br>// 获取对象的类名和 HashCode。参数为 null 时，返回字符串：””<br>String identityToString(Object obj)<br>// 相当于 toString()方法，但参数为 null 时，返回字符串：””<br>String getDisplayString(Object obj)</p><p>2.判断工具</p><p>// 判断数组是否为空<br>boolean isEmpty(Object[] array)<br>// 判断参数对象是否是数组<br>boolean isArray(Object obj)<br>// 判断数组中是否包含指定元素<br>boolean containsElement(Object[] array, Object element)<br>// 相等，或同为 null时，返回 true<br>boolean nullSafeEquals(Object o1, Object o2)<br>/*<br>判断参数对象是否为空，判断标准为：<br>    Optional: Optional.empty()<br>       Array: length == 0<br>CharSequence: length == 0<br>  Collection: Collection.isEmpty()<br>         Map: Map.isEmpty()<br> */<br>boolean isEmpty(Object obj)</p><p>3.其他工具方法</p><p>// 向参数数组的末尾追加新元素，并返回一个新数组<br>&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)<br>// 原生基础类型数组 –&gt; 包装类数组<br>Object[] toObjectArray(Object source)</p><p>StringUtils</p><p>1.字符串判断工具</p><p>// 判断字符串是否为 null，或 “”。注意，包含空白符的字符串为非空<br>boolean isEmpty(Object str)<br>// 判断字符串是否是以指定内容结束。忽略大小写<br>boolean endsWithIgnoreCase(String str, String suffix)<br>// 判断字符串是否已指定内容开头。忽略大小写<br>boolean startsWithIgnoreCase(String str, String prefix)<br>// 是否包含空白符<br>boolean containsWhitespace(String str)<br>// 判断字符串非空且长度不为 0，即，Not Empty<br>boolean hasLength(CharSequence str)<br>// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank<br>boolean hasText(CharSequence str)<br>// 判断字符串指定索引处是否包含一个子串。<br>boolean substringMatch(CharSequence str, int index, CharSequence substring)<br>// 计算一个字符串中指定子串的出现次数<br>int countOccurrencesOf(String str, String sub)</p><p>2.字符串操作工具</p><p>// 查找并替换指定子串<br>String replace(String inString, String oldPattern, String newPattern)<br>// 去除尾部的特定字符<br>String trimTrailingCharacter(String str, char trailingCharacter)<br>// 去除头部的特定字符<br>String trimLeadingCharacter(String str, char leadingCharacter)<br>// 去除头部的空白符<br>String trimLeadingWhitespace(String str)<br>// 去除头部的空白符<br>String trimTrailingWhitespace(String str)<br>// 去除头部和尾部的空白符<br>String trimWhitespace(String str)<br>// 删除开头、结尾和中间的空白符<br>String trimAllWhitespace(String str)<br>// 删除指定子串<br>String delete(String inString, String pattern)<br>// 删除指定字符（可以是多个）<br>String deleteAny(String inString, String charsToDelete)<br>// 对数组的每一项执行 trim() 方法<br>String[] trimArrayElements(String[] array)<br>// 将 URL 字符串进行解码<br>String uriDecode(String source, Charset charset)</p><p>3.路径相关工具方法</p><p>// 解析路径字符串，优化其中的 “..”<br>String cleanPath(String path)<br>// 解析路径字符串，解析出文件名部分<br>String getFilename(String path)<br>// 解析路径字符串，解析出文件后缀名<br>String getFilenameExtension(String path)<br>// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..”<br>boolean pathEquals(String path1, String path2)<br>// 删除文件路径名中的后缀部分<br>String stripFilenameExtension(String path)<br>// 以 “. 作为分隔符，获取其最后一部分<br>String unqualify(String qualifiedName)<br>// 以指定字符作为分隔符，获取其最后一部分<br>String unqualify(String qualifiedName, char separator)</p><p>CollectionUtils</p><p>1.集合判断工具</p><p>// 判断 List/Set 是否为空<br>boolean isEmpty(Collection<?> collection)// 判断 Map 是否为空boolean isEmpty(Map<?,?> map)<br>// 判断 List/Set 中是否包含某个对象<br>boolean containsInstance(Collection<?> collection, Object element)// 以迭代器的方式，判断 List/Set 中是否包含某个对象boolean contains(Iterator<?> iterator, Object element)<br>// 判断 List/Set 是否包含某些对象中的任意一个<br>boolean containsAny(Collection<?> source, Collection<?> candidates)<br>// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素<br>boolean hasUniqueObject(Collection&lt;?&gt; collection)</p><p>2.集合操作工具</p><p>// 将 Array 中的元素都添加到 List/Set 中<br><E> void mergeArrayIntoCollection(Object array, Collection<E> collection)<br>// 将 Properties 中的键值对都添加到 Map 中<br>&lt;K,V&gt; void mergePropertiesIntoMap(Properties props, Map&lt;K,V&gt; map)<br>// 返回 List 中最后一个元素<br><T> T lastElement(List<T> list)<br>// 返回 Set 中最后一个元素<br><T> T lastElement(Set<T> set)<br>// 返回参数 candidates 中第一个存在于参数 source 中的元素<br><E> E findFirstMatch(Collection<?> source, Collection<E> candidates)// 返回 List/Set 中指定类型的元素。<T> T findValueOfType(Collection<?> collection, Class<T> type)<br>// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推<br>Object findValueOfType(Collection<?> collection, Class<?>[] types)<br>// 返回 List/Set 中元素的类型<br>Class<?> findCommonElementType(Collection<?> collection)</T></T></E></E></T></T></T></T></E></E></p><h1 id="文件、资源、IO-流"><a href="#文件、资源、IO-流" class="headerlink" title="文件、资源、IO 流"></a>文件、资源、IO 流</h1><p>FileCopyUtils</p><p>1.输入</p><p>// 从文件中读入到字节数组中<br>byte[] copyToByteArray(File in)<br>// 从输入流中读入到字节数组中<br>byte[] copyToByteArray(InputStream in)<br>// 从输入流中读入到字符串中<br>String copyToString(Reader in)</p><p>2.输出</p><p>// 从字节数组到文件<br>void copy(byte[] in, File out)<br>// 从文件到文件<br>int copy(File in, File out)<br>// 从字节数组到输出流<br>void copy(byte[] in, OutputStream out)<br>// 从输入流到输出流<br>int copy(InputStream in, OutputStream out)<br>// 从输入流到输出流<br>int copy(Reader in, Writer out)<br>// 从字符串到输出流<br>void copy(String in, Writer out)</p><p>ResourceUtils</p><p>1.从资源路径获取文件</p><p>// 判断字符串是否是一个合法的 URL 字符串。<br>static boolean isUrl(String resourceLocation)<br>// 获取 URL<br>static URL getURL(String resourceLocation)<br>// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）<br>static FilegetFile(String resourceLocation)</p><p>2.Resource</p><p>// 文件系统资源 D:...<br>FileSystemResource<br>// URL 资源，如 file://… http://…<br>UrlResource<br>// 类路径下的资源，classpth:…<br>ClassPathResource<br>// Web 容器上下文中的资源（jar 包、war 包）<br>ServletContextResource</p><p>// 判断资源是否存在<br>boolean exists()<br>// 从资源中获得 File 对象<br>File getFile()<br>// 从资源中获得 URI 对象<br>URI getURI()<br>// 从资源中获得 URI 对象<br>URL getURL()<br>// 获得资源的 InputStream<br>InputStream getInputStream()<br>// 获得资源的描述信息<br>String getDescription()</p><p>StreamUtils</p><p>1.输入</p><p>void copy(byte[] in, OutputStream out)<br>int copy(InputStream in, OutputStream out)<br>void copy(String in, Charset charset, OutputStream out)<br>long copyRange(InputStream in, OutputStream out, long start, long end)</p><p>2.输出</p><p>byte[] copyToByteArray(InputStream in)<br>String copyToString(InputStream in, Charset charset)<br>// 舍弃输入流中的内容<br>int drain(InputStream in)</p><h1 id="反射、AOP"><a href="#反射、AOP" class="headerlink" title="反射、AOP"></a>反射、AOP</h1><p>ReflectionUtils</p><p>1.获取方法</p><p>// 在类中查找指定方法<br>Method findMethod(Class<?> clazz, String name) // 同上，额外提供方法参数类型作查找条件Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) // 获得类中所有方法，包括继承而来的Method[] getAllDeclaredMethods(Class<?> leafClass)<br>// 在类中查找指定构造方法<br>Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) // 是否是 equals() 方法boolean isEqualsMethod(Method method) // 是否是 hashCode() 方法 boolean isHashCodeMethod(Method method) // 是否是 toString() 方法boolean isToStringMethod(Method method) // 是否是从 Object 类继承而来的方法boolean isObjectMethod(Method method) // 检查一个方法是否声明抛出指定异常boolean declaresException(Method method, Class<?> exceptionType)</T></T></p><p>2.执行方法</p><p>// 执行方法<br>Object invokeMethod(Method method, Object target)<br>// 同上，提供方法参数<br>Object invokeMethod(Method method, Object target, Object… args)<br>// 取消 Java 权限检查。以便后续执行该私有方法<br>void makeAccessible(Method method)<br>// 取消 Java 权限检查。以便后续执行私有构造方法<br>void makeAccessible(Constructor&lt;?&gt; ctor)</p><p>3.获取字段</p><p>// 在类中查找指定属性<br>Field findField(Class<?> clazz, String name) // 同上，多提供了属性的类型Field findField(Class<?> clazz, String name, Class&lt;?&gt; type)<br>// 是否为一个 “public static final” 属性<br>boolean isPublicStaticFinal(Field field)</p><p>4.设置字段</p><p>// 获取 target 对象的 field 属性值<br>Object getField(Field field, Object target)<br>// 设置 target 对象的 field 属性值，值为 value<br>void setField(Field field, Object target, Object value)<br>// 同类对象属性对等赋值<br>void shallowCopyFieldState(Object src, Object dest)<br>// 取消 Java 的权限控制检查。以便后续读写该私有属性<br>void makeAccessible(Field field)<br>// 对类的每个属性执行 callback<br>void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) // 同上，多了个属性过滤功能。void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc,<br>                  ReflectionUtils.FieldFilter ff)<br>// 同上，但不包括继承而来的属性<br>void doWithLocalFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</p><p>AopUtils</p><p>1.判断代理类型</p><p>// 判断是不是 Spring 代理对象<br>boolean isAopProxy()<br>// 判断是不是 jdk 动态代理对象<br>isJdkDynamicProxy()<br>// 判断是不是 CGLIB 代理对象<br>boolean isCglibProxy()</p><p>2.获取被代理对象的 class</p><p>// 获取被代理的目标 class<br>Class&lt;?&gt; getTargetClass()</p><p>AopContext</p><p>1.获取当前对象的代理对象</p><p>Object currentProxy()</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注解使用</title>
      <link href="/2022/02/11/Java/Mybatis/11.%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/11/Java/Mybatis/11.%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>配置SqlMapConfig.xml<br>``` xml<configuration> <properties resource="jdbcConfig.properties"> <mappers>     <package name="cn.dy.mapper"> </package></mappers></properties></configuration></li></ol><pre><code>2. 在XxxMapper接口上添加正确的注解## 增注解:`@Insert`使用方式:方法上**添加数据**``` Javapublic interface AccountMapper &#123;    /**     * 添加账户     * @param account     * @return     */    @Insert(&quot;insert into account (UID,money) values (#&#123;uId&#125;,#&#123;money&#125;)&quot;)    void save(Account account);&#125;</code></pre><p><strong>添加数据,并将自增的主键使用反射设置到当前对象中</strong><br>方式一</p><pre class=" language-Java"><code class="language-Java">// mapper接口public interface AccountMapper &#123;    /**     * 添加账户     * @param account     * @return     */    @Insert("insert into account (UID,money) values (#&#123;uId&#125;,#&#123;money&#125;)")    @Options(useGeneratedKeys=true,keyColumn = "id",keyProperty = "id")    void save(Account account);&#125;</code></pre><p>方式二</p><pre class=" language-Java"><code class="language-Java">// mapper接口public interface AccountMapper &#123;    /**     * 添加账户     * @param account     * @return     */    @Insert("insert into account (UID,money) values (#&#123;uId&#125;,#&#123;money&#125;)")    @SelectKey(before = false,keyColumn = "id",keyProperty = "id",            statement = "select last_insert_id()",resultType = Integer.class)    void save(Account account);&#125;测试类``` Javapublic class TestAccount &#123;    private InputStream inputStream;    private SqlSession sqlSession;    private AccountMapper accountMapper;    private SqlSessionFactory sqlSessionFactory;    @Before    public void init() &#123;        try &#123;            inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);        //  这里的事务默认不开启        sqlSession = sqlSessionFactory.openSession();        accountMapper = sqlSession.getMapper(AccountMapper.class);    &#125;    @After    public void destory() &#123;        //  这里提交事务        sqlSession.commit();        try &#123;            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        sqlSession.close();    &#125;    @Test    public void testSave()&#123;        Account account = new Account(null,45,9999.0);        //  自增后的主键会设置到当前对象中        accountMapper.save(account);        System.out.println(account);    &#125;&#125;</code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>注解:<code>@Delete</code><br>使用方式:方法上</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;    /**     * 删除账户     * @param id     * @return     */    @Delete("DELETE from account WHERE id = #&#123;id&#125;")    //  返回值为执行结果:影响的行数    int removeById(int id);&#125;</code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>注解:<code>@Update</code><br>使用方式:方法上</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;  /**    * 根据id修改用户信息    * @param account    * @return    */  @Update("UPDATE  account SET  UID=#&#123;uId&#125;,money=#&#123;money&#125; WHERE id = #&#123;id&#125;")  int editorById(Account account);&#125;</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>注解:<code>@Select</code><br>使用方式:方法上<br><strong>普通查询+起别名</strong></p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;    /**     * 根据id查询账户信息     *     * @param id     * @return     */    @Select(&#123;"SELECT id,UID uId,money FROM account"&#125;)    Account findById(int id);&#125;</code></pre><p><strong>查询个数</strong></p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;    /**     * 查询个数     * @return     */    @Select("select count(1) from user")     Integer findCount();&#125;</code></pre><h2 id="结果集-需与Select一起使用"><a href="#结果集-需与Select一起使用" class="headerlink" title="结果集(需与Select一起使用)"></a>结果集(需与Select一起使用)</h2><p>注解:<code>@Results</code><br>使用方式:<strong>方法上</strong><br><strong>结果集映射查询</strong><br>属性:</p><ul><li><p>id  当前结果集起个别名,可复用 <strong>(注意:此id值不可重复)</strong></p></li><li><p>value 结果集字段映射</p><ul><li>结果集字段映射使用<code>@Result</code>注解<ul><li>column的值为数据库列名</li><li>property的值为实体类中的属性名</li><li><code>id=true</code>表示该字段为主键,不写默认的值为false<br>``` Java<br>public interface AccountMapper {<br>/**</li></ul></li></ul><ul><li>根据id查询账户信息</li><li></li><li>@param id</li><li>@return</li><li>/</li></ul><p>@Select({“SELECT id,UID,money FROM account”})<br>@Results(id = “accountMap”, value = {</p><pre><code>    @Result(column = &quot;id&quot;, property = &quot;id&quot;, id = true),    @Result(column = &quot;UID&quot;, property = &quot;uId&quot;),    @Result(column = &quot;money&quot;, property = &quot;money&quot;)</code></pre><p>})<br>Account findById(int id);<br>}<br>```</p></li></ul><h2 id="使用结果集"><a href="#使用结果集" class="headerlink" title="使用结果集"></a>使用结果集</h2><p>注解:<code>@ResultMap</code></p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;  /**    * 查询所有账户信息    *    * @return    */  @Select("select id,UID uId,money from account")  //  注意:使用ResultMap时,名为accountMap的结果集必须存在  @ResultMap("accountMap")  List<Account> findAll();&#125;</code></pre><h2 id="传参-暂未使用"><a href="#传参-暂未使用" class="headerlink" title="传参(暂未使用)"></a>传参(暂未使用)</h2><p>注解:<code>@Param</code><br>使用方式:<strong>在方法参数前使用</strong><br>例:</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;    /**     * 根据id查询账户信息     *     * @param id     * @return     */    @Select(&#123;"SELECT id,UID,money FROM account WHERE id = #&#123;id&#125;"&#125;)    // 在方法参数前使用    Account findById(@Param("id") int id);&#125;</code></pre><h2 id="延迟加载-懒加载-按需加载"><a href="#延迟加载-懒加载-按需加载" class="headerlink" title="延迟加载(懒加载,按需加载)"></a>延迟加载(懒加载,按需加载)</h2><p>需在SqlMapConfig中开启配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcConfig.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--    配置项--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--开启懒加载(延迟加载)--></span>        <span class="token comment" spellcheck="true">&lt;!-- 将延迟加载 lazyLoadingEnable 的开关设置成 teue--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将积极加载修改为消极加载，将 aggressiveLazyLoading 改为 false--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aggressiveLazyLoading<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定对象的哪些方法触发一次延迟加载;默认值:equals,clone,hashCode,toString--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadTriggerMethods<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>equals,clone,hashCode<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><p><strong>pojo类</strong><br>Account.java</p><pre class=" language-Java"><code class="language-Java">public class Account implements Serializable &#123;    private Integer id;    private Integer uId;    private double money;    private  User user;&#125;</code></pre><p>User.java</p><pre class=" language-Java"><code class="language-Java">public class User implements Serializable &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    List<Account> accounts;&#125;</code></pre><p><strong>一对多或多对多</strong><br>UserMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface UserMapper &#123;  /**    * 查询所有用户信息    * @return    */  @Select("select * from user")  @Results(id = "userAccount",value = &#123;          @Result(id = true,property = "id",column = "id"),          @Result(property = "username",column = "username"),          @Result(property = "sex",column = "sex"),          @Result(property = "address",column = "address"),          //  配置延迟加载项:            //  property延迟加载的对象属性名            //  column传递给延迟加载对象的参数            //  many延迟加载的类型为集合时使用              //  select延迟加载对象的坐标:包名.类名.方法名              //  fetchType延迟加载的时机:LAZY懒加载          @Result(property = "accounts",column = "id",many = @Many(                  select = "cn.dy.mapper.AccountMapper.findById",fetchType = FetchType.LAZY          ))  &#125;)  List<User> findAll();&#125;</code></pre><p>AccountMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;    /**     * 根据id查询账户信息     * @param id     * @return     */    @Select("SELECT * FROM account")    Account findById(int id);&#125;</code></pre><p>测试类TestUser.java</p><pre class=" language-Java"><code class="language-Java">public class TestUser &#123;    private InputStream inputStream;    private SqlSession sqlSession;    private UserMapper userMapper;    private SqlSessionFactory sqlSessionFactory;    @Before    public void init() &#123;        try &#123;            inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);        //  这里的事务默认不开启        sqlSession = sqlSessionFactory.openSession();        userMapper = sqlSession.getMapper(UserMapper.class);    &#125;    @After    public void destory() &#123;        //  这里提交事务        sqlSession.commit();        try &#123;            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        sqlSession.close();    &#125;    @Test    public void testFindAll()&#123;        List<User> users = userMapper.findAll();        for (User user : users) &#123;            System.out.println(user);            System.out.println(user.getAccounts());//  调用此方法时启用延迟加载            System.out.println("-------------------------------------------------");        &#125;    &#125;&#125;</code></pre><p><strong>多对一或一对一</strong><br>AccountMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;  /**    * 查询所有账户信息    * @return    */  @Select("select * from account")  @Results(id = "accountUser",value = &#123;          @Result(id = true,property = "id",column = "id"),          @Result(property = "uId",column = "UID"),          @Result(property = "money",column = "money"),          //  配置延迟加载项:            //  property延迟加载的对象属性名            //  column传递给延迟加载对象的参数            //  one延迟加载的类型为对象时使用              //  select延迟加载对象的坐标:包名.类名.方法名              //  fetchType延迟加载的时机:LAZY懒加载          @Result(property = "user",column = "id",one = @One(                  select = "cn.dy.mapper.UserMapper.findById",fetchType = FetchType.LAZY          ))  &#125;)  List<Account> findAll();&#125;</code></pre><p>UserMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface UserMapper &#123;    /**     * 根据id查询用户信息     * @param id     * @return     */    @Select("SELECT * FROM user WHERE id=#&#123;id&#125;")    User findById(int id);&#125;</code></pre><p>测试类TestAccount.java</p><pre class=" language-Java"><code class="language-Java">public class TestAccount &#123;    private InputStream inputStream;    private SqlSession sqlSession;    private AccountMapper accountMapper;    private SqlSessionFactory sqlSessionFactory;    @Before    public void init() &#123;        try &#123;            inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);        //  这里的事务默认不开启        sqlSession = sqlSessionFactory.openSession();        accountMapper = sqlSession.getMapper(AccountMapper.class);    &#125;    @After    public void destory() &#123;        //  这里提交事务        sqlSession.commit();        try &#123;            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        sqlSession.close();    &#125;    //  查询所有账户信息    @Test    public  void testFindAll()&#123;        List<Account> accounts = accountMapper.findAll();        for (Account account : accounts) &#123;            System.out.println(account);            System.out.println(account.getUser());//  调用此方法时启用延迟加载            System.out.println("--------------------------------------------");        &#125;    &#125;&#125;</code></pre><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>需要先在SqlMapConfig.xml中配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcConfig.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--    配置项--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--开启全局二级缓存--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><p>注解:<code>@CacheNamespace(blocking = true)</code><br>使用:在mapper接口类上添加注解</p><pre class=" language-Java"><code class="language-Java">//  开启注解支持二级缓存@CacheNamespace(blocking = true)public interface UserMapper &#123;    /**     * 查询全部     * @return     */    @Select("select * from user")    @Results(id = "userMapper",value = &#123;            @Result(id = true,property = "userId",column = "id"),            @Result(property = "userName",column = "username"),            @Result(property = "userSex",column = "sex"),            @Result(property = "userAddress",column = "address")    &#125;)    public List<User> findAll();    /**     * 查询个数     * @return     */    @Select("select count(1) from user")    public Integer findCount();    /**     * 通过名字模糊查询     * @param name     * @return     */    @Select("select * from user where username like #&#123;userName&#125;")    @ResultMap("userMapper")//    @Select("select * from user where username like '%$&#123;value&#125;%'")    public List<User> findByName(String name);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多参数传递</title>
      <link href="/2022/02/11/Java/Mybatis/12.%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
      <url>/2022/02/11/Java/Mybatis/12.%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>使用arg0，arg1或使用param1，param2接收（arg索引从0开始，param索引从1开始）<br>多个参数封装成对象<br>多个参数封装成Map集合<br>使用@param绑定参数</p><h2 id="使用arg或param"><a href="#使用arg或param" class="headerlink" title="使用arg或param"></a>使用arg或param</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.dao.CustomerDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAllPageSql<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.entity.Customer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        SELECT * FROM t_customer LIMIT #<span class="token entity" title="&#123;">&amp;#123;</span>param1<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>param2<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><p>或</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.dao.CustomerDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAllPageSql<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.entity.Customer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        SELECT * FROM t_customer LIMIT #<span class="token entity" title="&#123;">&amp;#123;</span>arg0<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>arg1<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h2 id="封装成对象"><a href="#封装成对象" class="headerlink" title="封装成对象"></a>封装成对象</h2><p>Page.java</p><pre class=" language-Java"><code class="language-Java">public class Page &#123;    private Integer pageNo;    private Integer pageSize;    //getter,setter略&#125;</code></pre><p>Dao持久层传参</p><pre class=" language-Java"><code class="language-Java">public interface CustomerDao &#123;     List<Customer> findAllPageClass(Page page);&#125;   </code></pre><p>mapper.xml映射文件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.dao.CustomerDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAllPageClass<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.entity.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.vue.util.Page<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       SELECT * FROM t_customer LIMIT #<span class="token entity" title="&#123;">&amp;#123;</span>pageNo<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>pageSize<span class="token entity" title="&#125;">&amp;#125;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h2 id="使用-Param注解绑定参数"><a href="#使用-Param注解绑定参数" class="headerlink" title="使用@Param注解绑定参数"></a>使用@Param注解绑定参数</h2><p>Dao持久层接口</p><pre class=" language-Java"><code class="language-Java">/**  * 分页查询全部  * @param index  * @param pageTotal  * @return  */List<Route> findAll(@Param("index") int index,@Param("pageTotal")  int pageTotal,@Param("cid") int cid);</code></pre><p>mapper.xml映射文件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.travel.dao.RouteDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>routeAll<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        SELECT rid, rname, price, routeIntroduce, rflag, rdate, isThemeTour, count,   cid,rimage,   sid, sourceId        FROM tab_route    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>route<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>routeAll<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>            cid = #<span class="token entity" title="&#123;">&amp;#123;</span>cid<span class="token entity" title="&#125;">&amp;#125;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>        limit #<span class="token entity" title="&#123;">&amp;#123;</span>index<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>pageTotal<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h2 id="补充-：-与-区别"><a href="#补充-：-与-区别" class="headerlink" title="补充 ：#{}与${}区别"></a>补充 ：#{}与${}区别</h2><p>#{} 在SQL动态解析之后，编译将#{}替换为占位符？去替换参数，可以防止sql注入；<br>#{} 只是表示占位，与参数的名字无关，如果只有一个参数会自动对应，下面会介绍多个参数的问题；<br>${} 是进行字符串拼接，直接取出参数值，放到sql语句中；<br>使用注意点，当表名作为变量时，必须使用${}获取参数作为表名进行查询，否则会出现语法错误；<br>总结：<br>    sql语句动态生成的时候，使用${}<br>    sql语句中某个参数进行占位的时候用#{}</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2022/02/11/Java/Mybatis/5.SQL/"/>
      <url>/2022/02/11/Java/Mybatis/5.SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="动态SQL概述"><a href="#动态SQL概述" class="headerlink" title="动态SQL概述"></a>动态SQL概述</h2><p>根据实体类的不同取值，使用不同的 SQL 语句来进行查询;在多条件组合查询中经常使用</p><h2 id="动态-SQL-标签"><a href="#动态-SQL-标签" class="headerlink" title="动态 SQL 标签"></a>动态 SQL <if>标签</if></h2><p>根据实体类的不同取值，使用不同的 SQL 语句来进行查询<br>某个属性符合某个条件时,再进行该属性的条件查询</p><pre class=" language-XML"><code class="language-XML"><select id="findQuery" parameterType="User" resultType="User">  SELECT id, username, birthday, sex, address FROM user  <where>    <if test=" sex!=null and sex != ''  ">        AND sex = #&#123;sex&#125;    </if>    <if test="username!=null and username != ''">        AND username like #&#123;username&#125;    </if>    <if test="address!=null and address != ''">        AND address like #&#123;address&#125;    </if>    <if test="birthday!=null and birthday != ''">        AND birthday = #&#123;birthday&#125;    </if>  </where></select></code></pre><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><p>从多个条件中选择一个使用。MyBatis 提供了 choose 元素，类似于 Java 中的 switch 语句<br>其中一个<code>when</code>符合条件则使用该when内的sql查询,都不符合则使用<code>otherwise</code>内的sql查询</p><pre class=" language-XML"><code class="language-XML"><select id="findActiveBlogLike" resultType="Blog">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <choose>    <when test="title != null">      AND title like #&#123;title&#125;    </when>    <when test="author != null and author.name != null">      AND author_name like #&#123;author.name&#125;    </when>    <otherwise>      AND featured = 1    </otherwise>  </choose></select></code></pre><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。<br>而且，若子句的开头为 “AND” 或 “OR”，where 元素会将它们去除</p><pre class=" language-XML"><code class="language-XML"><select id="findUserById" resultType="cn.dy.pojo.User" parameterType="java.lang.Integer">  SELECT username,birthday,sex,address FROM user  <where>id = #&#123;id&#125;</where></select></code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>动态更新语句的类似解决方案叫做 set<br>set 元素可以用于动态包含需要更新的列，忽略其它不更新的列</p><pre class=" language-XML"><code class="language-XML"><update id="updateAuthorIfNecessary">  update Author    <set>      <if test="username != null">username=#&#123;username&#125;,</if>      <if test="password != null">password=#&#123;password&#125;,</if>      <if test="email != null">email=#&#123;email&#125;,</if>      <if test="bio != null">bio=#&#123;bio&#125;</if>    </set>  where id=#&#123;id&#125;</update></code></pre><p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）</p><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>自定义 trim 元素来定制 where 元素的功能。<br><strong>where 元素等价的自定义 trim 元素</strong></p><pre class=" language-XML"><code class="language-XML"><trim prefix="WHERE" prefixOverrides="AND |OR ">  ...</trim></code></pre><p>prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）<br>上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容</p><p><strong>set 元素等价的自定义 trim 元素</strong></p><pre class=" language-XML"><code class="language-XML"><trim prefix="SET" suffixOverrides=",">  ...</trim></code></pre><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>用于遍历集合(List,Map,Set)等<br>允许指定开头与结尾的字符串以及集合项迭代之间的分隔符<br>属性<br><code>collection</code>:代表要遍历的集合元素类型<br><code>open</code>:forEach遍历之前添加的内容<br><code>close</code>:forEach遍历之后添加的内容<br><code>index</code>:List时代表索引,Map时,代表键<br><code>item</code>:List时代表遍历集合的每个元素，Map时,代表值<br><code>sperator</code>:迭代项之间的分隔符<br>例:</p><pre class=" language-XML"><code class="language-XML"><select id="findByIds" resultType="User" parameterType="java.lang.Integer">  SELECT id, username, birthday, sex, address FROM user  <where>    id IN    <foreach collection="list" open="(" close=")" item="id" separator=",">      #&#123;id&#125;    </foreach>  </where></select></code></pre><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>定义公用代码片段<br>例:</p><pre class=" language-XML"><code class="language-XML"><!-- 定义代码片段 --><sql id="userAll">SELECT id, username, birthday, sex, address FROM user</sql><!-- 使用代码片段 --><select id="findAll" resultType="cn.dy.pojo.User">  <include refid="userAll"></include></select></code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接池</title>
      <link href="/2022/02/11/Java/Mybatis/7.%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2022/02/11/Java/Mybatis/7.%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>mybatise连接池有3种配置</p><p>配置核心配置文件中的datasources标签，在type属性中有3个取值：</p><p><code>Pooled</code>：采用的是传统的DataSource规范中的连接池，mybatis有针对该接口的实现<br><code>Unpooled</code>：采用的是传统的DataSource规范中接口实现，没有使用连接池<br><code>jndi</code>：采用jndi的技术实现。根据服务器的不同，拿到的数据源不同</p><p>Pooled：我们发现它会先看没有空闲连接：</p><ul><li>有：    直接从空闲连接中获取第一个来使用</li><li>没有：<ul><li>判断你的活动连接数是否小于设置的最大的连接数：</li><li>小于：  创建了一个新的连接来使用</li><li>不小于： 获取出最老的一个连接，进行设置，使用</li></ul></li></ul><ul><li>日志输出：pooled存在获取连接和归还连接的操作</li></ul><p>unpooled：通它虽然实现了DataSource接口，但其实就是普通的jdbc使用四大参数获取了连接，并没有使用连接池</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2022/02/11/Java/Mybatis/10.%E7%BC%93%E5%AD%98/"/>
      <url>/2022/02/11/Java/Mybatis/10.%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>缓存:存在于内存中的临时数据</p><h2 id="使用缓存的优势"><a href="#使用缓存的优势" class="headerlink" title="使用缓存的优势"></a>使用缓存的优势</h2><p>减少和数据库的交互次数，提高程序执行效率</p><h2 id="缓存的使用条件"><a href="#缓存的使用条件" class="headerlink" title="缓存的使用条件"></a>缓存的使用条件</h2><ul><li>适用于缓存：<ul><li>经常查询并且不经常改变</li><li>数据的正确与否与最终的结果影响不大的数据</li></ul></li><li>不适用于缓存：<ul><li>经常改变的数据</li><li>数据的正确与否与最终的结果影响大的数据</li><li>例如：商品库存，银行汇率，股市牌价</li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一级缓存(本地缓存)<br>二级缓存</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>mybatis中存入SqlSession的缓存,默认开启<br>当执行查询后，查询的结果会同时存入SqlSession提供的一块区域中该区域的结构是一个map<br>当再次查询相同的数据，mybatis会先从sqlSession中去看是否有，有的话，直接使用</p><h3 id="一级缓存失效时机"><a href="#一级缓存失效时机" class="headerlink" title="一级缓存失效时机"></a>一级缓存失效时机</h3><p>SqlSession对象消失时<br>手动去调用SqlSession的clearCache时<br>查询后,调用增删改方法时</p><h3 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h3><p>a、MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</p><p>b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</p><p>c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</p><p>d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>mybatis中SqlSessionFactory对象中的缓存。由同一个factory对象创建的SqlSession共享其缓存<br>可以提高对数据库查询的效率，以提高应用的性能</p><h3 id="使用及要求"><a href="#使用及要求" class="headerlink" title="使用及要求"></a>使用及要求</h3><p>二级缓存默认是不开启的</p><ul><li>实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的,也就是要求pojo(实体类)实现Serializable接口</li><li>局部开启:在映射XML文件配置添加<code>&lt;cache/&gt;</code>;在查询的sql标签添加属性:<code>useCache=&quot;true&quot;</code></li><li>全局开启:在SqlMapConfig中添加<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code>;在映射XML文件配置添加<code>&lt;cache/&gt;</code>;在查询的sql标签添加属性:<code>useCache=&quot;true&quot;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis快速入门</title>
      <link href="/2022/02/11/Java/Mybatis/1.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/11/Java/Mybatis/1.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>mybatis 是持久层框架，支持自定义 SQL、存储过程以及高级映射<br>通过 XML 或注解来配置和映射原始类型、接口和 Java POJO（实体类）为数据库中的记录<br>官网:<a href="https://mybatis.net.cn/">https://mybatis.net.cn/</a></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>采用 ORM 思想解决实体和数据库映射的问题<br>ORM：    对象关系映射。数据库的一条数据对应java中的一个对象</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>普通Java项目</p><ul><li>需要导入<code>mybatis-x.x.x.jar</code>包</li></ul><p>maven项目</p><ol><li>导入依赖</li><li>创建实体类，dao接口(名称建议改为mapper)</li><li>创建mybatis主配置文件SqlMapConfig.xml</li><li>创建映射的配置文件UserDao.xml</li></ol><h2 id="maven项目目录结构"><a href="#maven项目目录结构" class="headerlink" title="maven项目目录结构"></a>maven项目目录结构</h2><ul><li>项目名称<ul><li>src     源代码<ul><li>main  主代码<ul><li>java  Java代码<ul><li>cn<ul><li>dy<ul><li>pojo    实体类</li><li>mapper  持久层接口</li></ul></li></ul></li></ul></li><li>resources 资源目录<ul><li>SqlMapConfig.xml  Mybatis核心配置文件</li><li>log4j.properties  log4j日志配置文件</li><li>cn<ul><li>dy<ul><li>mapper  持久层映射目录(此目录结构必须和Java中的结构保持一致)</li></ul></li></ul></li></ul></li></ul></li><li>test  测试代码</li></ul></li><li>target  构建目录</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在mybatis中持久层操作接口名称和映射文件名称也叫做Mapper<br><strong><code>mybatis的映射文件位置必须和mapper(dao)接口的包位置相同</code></strong><br><strong>maven编译时会将映射文件和编译后的mapper(dao)接口放在同一目录下</strong></p><h2 id="SqlMapConfig-xml核心文件"><a href="#SqlMapConfig-xml核心文件" class="headerlink" title="SqlMapConfig.xml核心文件"></a>SqlMapConfig.xml核心文件</h2><pre class=" language-XML"><code class="language-XML"><!-- mybatis配置的dtd约束 --><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"><!--配置--><configuration>    <!--配置mybatis环境 这里默认使用MySQL配置-->    <environments default="mysql">        <!--配置MySQL环境-->        <environment id="mysql">            <!-- MySQL事务 -->            <transactionManager type="JDBC"></transactionManager>            <!--数据源(连接池) POOLED为mybatis的数据源-->            <dataSource type="POOLED">                <property name="driver" value="com.mysql.jdbc.Driver"/>                <property name="url" value="jdbc:mysql:///mybatis"/>                <property name="username" value="root"/>                <property name="password" value="root"/>            </dataSource>        </environment>    </environments><!--配置映射文件-->    <mappers>      <!-- resource指向mapper的xml映射文件 -->        <mapper resource="cn/dy/mapper/UserMapper.xml"></mapper>    </mappers></configuration></code></pre><h2 id="mapper的xml映射文件"><a href="#mapper的xml映射文件" class="headerlink" title="mapper的xml映射文件"></a>mapper的xml映射文件</h2><pre class=" language-XML"><code class="language-XML"><!-- mybatis中mapper的dtd约束 --><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><!-- namespace属性必须是接口的全限定接口名 --><mapper namespace="cn.dy.mapper.UserMapper">    <!-- id属性值必须和接口中的方法名相同 -->    <!-- resultType属性值必须是pojo的全限定接口名 -->    <!-- parameterType属性值必须是方法参数的全限定接口名 -->    <!-- sql中的参数以 #&#123;pojo中的属性名&#125; 的形式传递-->    <select id="findUserById" resultType="cn.dy.pojo.User" parameterType="java.lang.Integer">        SELECT username,birthday,sex,address FROM user WHERE id = #&#123;id&#125;    </select>    <!-- 这里在添加后返回主键id -->    <!-- keyColumn为数据库中的列名 -->    <!-- keyProperty为pojo中的属性名 -->    <!-- order 取值:AFTER,BEFORE;AFTER:添加后返回,BEFORE:添加前返回(有可能导致id错误) -->    <insert id="addUser" parameterType="cn.dy.pojo.User">        INSERT INTO user (username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)        <selectKey resultType="java.lang.Integer" keyColumn="id" keyProperty="id" order="AFTER">            select last_insert_id()        </selectKey>    </insert></mapper></code></pre><h2 id="mybatis构建流程"><a href="#mybatis构建流程" class="headerlink" title="mybatis构建流程"></a>mybatis构建流程</h2><ol><li><p>使用mybatis提供的Resources工具类读取  核心配置文件(SqlMapConfig.xml)<br><code>InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</code></p></li><li><p>创建SqlSessionFactoryBuilder构建者对象(SqlSessionFactoryBuilder采用构建者模式)<br><code>SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</code></p></li><li><p>使用SqlSessionFactoryBuilder对象去构建SqlSessionFactory工厂对象(SqlSessionFactory采用工厂模式)<br><code>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</code></p></li><li><p>使用SqlSessionFactory工厂对象去创建SqlSession对象 (openSession默认不开启事务)<br><code>SqlSession sqlSession = sqlSessionFactory.openSession();</code></p></li><li><p>使用SqlSession对象去创建代理对象<br><code>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</code></p></li><li><p>使用代理对象去调用方法</p><pre class=" language-Java"><code class="language-Java">User user = new User(null, "张三", Date.valueOf("2012-12-11"), "男", "南京");userMapper.addUser(user);</code></pre></li><li><p>释放资源</p><pre class=" language-Java"><code class="language-Java">//  这里提交事务sqlSession.commit();try &#123;   inputStream.close();&#125; catch (IOException e) &#123;   e.printStackTrace();&#125;sqlSession.close();</code></pre></li></ol><h2 id="与-value-的区别"><a href="#与-value-的区别" class="headerlink" title="#{}与${value}的区别"></a>#{}与${value}的区别</h2><p>#{}使用…对象,使用占位符的方式,可以避免sql注入问题<br>${}使用…对象,会引发sql注入问题</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2022/02/11/Java/Mybatis/6.%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/02/11/Java/Mybatis/6.%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>SqlSession对象的<code>commit</code>方法</p><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>SqlSession对象的<code>rollback</code>方法</p><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>SqlSessionFactory中的openSession()方法可以设置事务的自动提交方式<br><code>openSession(true)</code>为开启自动提交<br><code>openSession(false)</code>为关闭自动提交<br>openSession()默认为false,为关闭自动提交</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java junit单元测试</title>
      <link href="/2022/02/11/Java/Java%20%E6%B5%8B%E8%AF%95/Java%20junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/02/11/Java/Java%20%E6%B5%8B%E8%AF%95/Java%20junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>黑盒测试：不需要写代码，输入值，看程序是否能够输出期望的值<code>(关注结果)</code></li><li>白盒测试：需要写代码;关注程序具体的执行流程<code>(关注过程)</code></li><li><strong>这里关注白盒测试…</strong></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>junit-版本号&nbsp;&nbsp;&nbsp;jar包</li><li>hamcrest-core-版本号&nbsp;&nbsp;&nbsp;jar包<code>(这里是junit jar包的依赖)</code></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以让任意方法都能运行</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>导入junit的jar包</li><li>创建测试类</li><li>给测试方法加上<code>@Test</code>注解</li><li>运行方法</li></ol><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>方法名：test测试的方法名        testAdd()  </li><li>返回值：void</li><li>参数列表：空参</li></ul><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>一般情况下，测试方法中不会看输出，只会看运行后的颜色<br>使用<code>Assert.assertEquals(期望的结果,运算的结果)</code>来判断结果的颜色</p><ul><li>红色：<code>失败</code></li><li>绿色：<code>成功</code></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>@Before:<br>如果在测试类中一个方法加上此注解，那么该方法会在测试方法运行前运行。<br>（一般会用于在测试类中加载一些初始化资源）<br>@After:<br>如果在测试类中一个方法加上此注解，那么该方法会在测试方法运行后运行。<br>（一般会用于释放资源）</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需要测试的类</p><pre class=" language-Java"><code class="language-Java">public class Result &#123;    /**     * 加     */    public int sum(int a,int b)&#123;        return a + b;    &#125;    /**     * 减     */    public int minus(int a,int b)&#123;        return a - b;    &#125;&#125;</code></pre><p>测试类</p><pre class=" language-Java"><code class="language-Java">public class Test2 &#123;    @Before    public void testBefore()&#123;        System.out.println("初始化资源....");    &#125;    @After    public void testAfter()&#123;        System.out.println("释放资源......");    &#125;    @Test    public void testSum()&#123;        Result result = new Result();        int i = result.sum(3,2)        Assert.assertEquals(5,i);    &#125;    @Test    public void testMinus()&#123;        Result result = new Result();        int i = result.minus(3,5)        Assert.assertEquals(-2,i);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒加载(延迟加载)</title>
      <link href="/2022/02/11/Java/Mybatis/9.%E6%87%92%E5%8A%A0%E8%BD%BD(%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD)/"/>
      <url>/2022/02/11/Java/Mybatis/9.%E6%87%92%E5%8A%A0%E8%BD%BD(%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD)/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>延迟加载：在真正使用数据的时候才发起查询，不用的时候不查询关联的数据，延迟加载又叫按需查询（懒加载）<br>立即加载(积极加载)：不管用不用，只要一调用方法，马上发起查询</p><h2 id="使用及案例"><a href="#使用及案例" class="headerlink" title="使用及案例"></a>使用及案例</h2><p><strong>案例简介:</strong><br>  一个用户下有多个账户<br>  表关系:一对多<br>  需求:查询所有用户的信息;需要时,查询该用户下的账户信息<br><strong>案例分析:</strong><br>  需要两张表:user用户表,account账户表<br>  需要两个实体类(pojo)<br>  需要两个mapper接口(sql映射)<br>  需要两个mapper映射的xml<br><strong>实体类如下:</strong><br>User.java 此处省略构造及get和set</p><pre class=" language-Java"><code class="language-Java">public class User &#123;  private Integer id;  private String username;  private Date birthday;  private String sex;  private String address;  List<Account> accounts;&#125;</code></pre><p>Account.java 此处省略构造及get和set</p><pre class=" language-Java"><code class="language-Java">public class Account &#123;  private Integer id;  private Integer uId;  private double money;  private  User user;&#125;</code></pre><p><strong>mapper接口如下:</strong><br>UserMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface UserMapper &#123;  /**    * 查询所有用户信息    * @return    */  List<User> findAll();&#125;</code></pre><p>AccountMapper.java</p><pre class=" language-Java"><code class="language-Java">public interface AccountMapper &#123;  /**    * 根据id查询账户信息    * @param id    * @return    */  Account findById(int id);&#125;</code></pre><p><strong>配置SqlMapConfig.xml核心文件</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!--开启懒加载(延迟加载)--></span>        <span class="token comment" spellcheck="true">&lt;!-- 将lazyLoadingEnable设置为 teue  启用延迟加载--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 将aggressiveLazyLoading设置为 false 将积极加载修改为消极加载--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aggressiveLazyLoading<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定对象的哪些方法触发一次延迟加载;默认值:equals,clone,hashCode,toString --></span>        <span class="token comment" spellcheck="true">&lt;!-- 注意:由于默认值toString方法会触发延迟加载,而打印对象信息会触发toString();所以这里将toString 方法排除,才可看到延迟加载的效果 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadTriggerMethods<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>equals,clone,hashCode<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><p><strong>mapper映射文件</strong><br>映射文件中resultMap标签的association和collection 具备延迟加载功能<br>UserMapper.xml文件</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--属性`namespace`指向接口全限定名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.dy.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccount<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- collection 可以使用延迟加载,property为当前实体类的属性名,column为传递给延迟方法的参数,select为延迟方法的全名称(包名.类名.方法名),ofType为当前集合属性的类型(collection标签支持该属性)   --></span>        <span class="token comment" spellcheck="true">&lt;!-- association  ofType替换为javaType,javaType为当前属性的类型;其余用法相同,  javaType(association标签支持该属性) --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accounts<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.dy.mapper.AccountMapper.findById<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccount<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        SELECT id, username, birthday, sex, address        FROM user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><p>AccountMapper.xml文件</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--属性`namespace`指向接口全限定名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.dy.mapper.AccountMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 上方sql查询语句触发延迟加载时将调用下方sql并返回数据信息 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findById<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        SELECT id, money, UID FROM account        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>UID = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><p><strong>测试</strong><br>TestUser.java</p><pre class=" language-Java"><code class="language-Java">public class TestUser &#123;    private InputStream inputStream;    private SqlSession sqlSession;    private UserMapper userMapper;    private SqlSessionFactory sqlSessionFactory;    @Before    public void init() &#123;        try &#123;            inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);        //  这里的事务默认不开启        sqlSession = sqlSessionFactory.openSession();        userMapper = sqlSession.getMapper(UserMapper.class);    &#125;    @After    public void destory() &#123;        //  这里提交事务        sqlSession.commit();        try &#123;            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        sqlSession.close();    &#125;    // 查询所有的用户信息    @Test    public void testFindAll()&#123;        List<User> users = userMapper.findAll();        for (User user : users) &#123;            System.out.println(user);            // 这里调用getAccounts时会触发延迟加载,不调用时则不会触发延迟加载            System.out.println(user.getAccounts());            System.out.println("-----------------------------------------------");        &#125;    &#125;&#125;</code></pre><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在对应的四种表关系中，一对多、多对多通常情况下采用延迟加载，多对一、一对一通常情况下采用立即加载</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 操作excel</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E6%93%8D%E4%BD%9Cexcel/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E6%93%8D%E4%BD%9Cexcel/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java中用来操作Excl的方式：<code>JXL</code>和<code>POI</code><br>JXL只能对Excel进行操作,属于比较老的框架，它只支持到Excel 95-2000的版本。现在已经停止更新和维护<br>POI是apache的项目,可对微软的Word,Excel,Ppt进行操作,包括offiffiffice2003和2007,Excl2003和2007。poi现在<br>一直有更新。所以现在主流使用POI。</p><h2 id="POI的概述"><a href="#POI的概述" class="headerlink" title="POI的概述"></a>POI的概述</h2><p>Apache POI是Apache软件基金会的开源项目，由Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java语言操作Microsoft Offiffiffice的功能。</p><h2 id="POI的应用场景"><a href="#POI的应用场景" class="headerlink" title="POI的应用场景"></a>POI的应用场景</h2><ol><li>数据报表生成</li><li>数据备份</li><li>数据批量上传</li></ol><h2 id="POI的环境搭建"><a href="#POI的环境搭建" class="headerlink" title="POI的环境搭建"></a>POI的环境搭建</h2><p>maven的pom.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi-ooxml-schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><h2 id="POI结构说明"><a href="#POI结构说明" class="headerlink" title="POI结构说明"></a>POI结构说明</h2><p><strong>HSSF<strong><strong>提供读写</strong></strong>Microsoft Excel XLS****格式档案的功能。</strong></p><p><strong>XSSF<strong><strong>提供读写</strong></strong>Microsoft Excel OOXML XLSX****格式档案的功能。</strong></p><p>HWPF提供读写Microsoft Word DOC格式档案的功能。</p><p>HSLF提供读写Microsoft PowerPoint格式档案的功能。</p><p>HDGF提供读Microsoft Visio格式档案的功能。</p><p>HPBF提供读Microsoft Publisher格式档案的功能。</p><p>HSMF提供读Microsoft Outlook格式档案的功能</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p><img src="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E6%93%8D%E4%BD%9Cexcel/image-20201104223900255.png" alt="image-20201104223900255"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>创建excel</p><pre class=" language-Java"><code class="language-Java">public class PoiTest01 &#123;    //测试创建excel文件    public static void main(String[] args) throws Exception &#123;        //1.创建workbook工作簿        Workbook wb = new XSSFWorkbook();        //2.创建表单Sheet        Sheet sheet = wb.createSheet("test");        //3.文件流        FileOutputStream fos = new FileOutputStream("E:\\test.xlsx");        //4.写入文件        wb.write(fos);        fos.close();   &#125;&#125;</code></pre><p>创建单元格</p><pre class=" language-Java"><code class="language-Java">//测试创建单元格    public static void main(String[] args) throws Exception &#123;        //1.创建workbook工作簿        Workbook wb = new XSSFWorkbook();        //2.创建表单Sheet        Sheet sheet = wb.createSheet("test");        //3.创建行对象，从0开始        Row row = sheet.createRow(3);        //4.创建单元格，从0开始        Cell cell = row.createCell(0);        //5.单元格写入数据        cell.setCellValue("德源教育");        //6.文件流        FileOutputStream fos = new FileOutputStream("E:\\test.xlsx");        //7.写入文件         wb.write(fos);        fos.close();   &#125;</code></pre><h2 id="设置格式"><a href="#设置格式" class="headerlink" title="设置格式"></a>设置格式</h2><pre class=" language-Java"><code class="language-Java">//创建单元格样式对象        CellStyle cellStyle = wb.createCellStyle();        //设置边框        cellStyle.setBorderBottom(BorderStyle.DASH_DOT);//下边框        cellStyle.setBorderTop(BorderStyle.HAIR);//上边框        //设置字体        Font font = wb.createFont();//创建字体对象        font.setFontName("华文行楷");//设置字体        font.setFontHeightInPoints((short)28);//设置字号        cellStyle.setFont(font);        //设置宽高        sheet.setColumnWidth(0, 31 * 256);//设置第一列的宽度是31个字符宽度        row.setHeightInPoints(50);//设置行的高度是50个点        //设置居中显示        cellStyle.setAlignment(HorizontalAlignment.CENTER);//水平居中        cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);//垂直居中        //设置单元格样式        cell.setCellStyle(cellStyle);        //合并单元格        CellRangeAddress  region =new CellRangeAddress(0, 3, 0, 2);        sheet.addMergedRegion(region);</code></pre><p><strong>绘制图形</strong></p><pre class=" language-Java"><code class="language-Java">//绘制图形    public static void main(String[] args) throws Exception &#123;        //1.创建workbook工作簿        Workbook wb = new XSSFWorkbook();        //2.创建表单Sheet        Sheet sheet = wb.createSheet("test");        //读取图片流        FileInputStream stream=new FileInputStream("e:\\logo.jpg");        byte[] bytes= IOUtils.toByteArray(stream);        //读取图片到二进制数组        stream.read(bytes);        //向Excel添加一张图片,并返回该图片在Excel中的图片集合中的下标        int pictureIdx = wb.addPicture(bytes,Workbook.PICTURE_TYPE_JPEG);        //绘图工具类        CreationHelper helper = wb.getCreationHelper();         //创建一个绘图对象        Drawing<?> patriarch = sheet.createDrawingPatriarch();        //创建锚点,设置图片坐标        ClientAnchor anchor = helper.createClientAnchor();        anchor.setCol1(0);//从0开始        anchor.setRow1(0);//从0开始        //创建图片        Picture picture = patriarch.createPicture(anchor, pictureIdx);        picture.resize();        //6.文件流        FileOutputStream fos = new FileOutputStream("E:\\test.xlsx");        //7.写入文件        wb.write(fos);        fos.close();   &#125;</code></pre><p>加载Excel</p><pre class=" language-Java"><code class="language-Java">public class PoiTest06 &#123;    //单元格样式    public static void main(String[] args) throws Exception &#123;        //1.创建workbook工作簿        Workbook wb = new XSSFWorkbook("E:\\demo.xlsx");        //2.获取sheet 从0开始        Sheet sheet = wb.getSheetAt(0);        int totalRowNum = sheet.getLastRowNum();        Row row = null;        Cell cell = null;        //循环所有行        for (int rowNum = 3; rowNum <sheet.getLastRowNum(); rowNum++) &#123;            row = sheet.getRow(rowNum);            StringBuilder sb = new StringBuilder();            //循环每行中的所有单元格            for(int cellNum = 2; cellNum < row.getLastCellNum();cellNum++) &#123;                cell = row.getCell(cellNum);                sb.append(getValue(cell)).append("-");           &#125;            System.out.println(sb.toString());       &#125;   &#125;    //获取数据    private static Object getValue(Cell cell) &#123;        Object value = null;        switch (cell.getCellType()) &#123;            case STRING: //字符串类型                value = cell.getStringCellValue();                break;                case BOOLEAN: //boolean类型                value = cell.getBooleanCellValue();                break;            case NUMERIC: //数字类型（包含日期和普通数字）                if(DateUtil.isCellDateFormatted(cell)) &#123;                    value = cell.getDateCellValue();               &#125;else&#123;                    value = cell.getNumericCellValue();               &#125;                break;            case FORMULA: //公式类型                value = cell.getCellFormula();                break;            default:                break;       &#125;        return value;   &#125;&#125;</code></pre><h2 id="POI报表导入"><a href="#POI报表导入" class="headerlink" title="POI报表导入"></a>POI报表导入</h2><p>maven的pom.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi-ooxml-schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>html</p><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user/fileupload<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       选择要上传的文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>upload<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>上传<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><p>spring的applicationContext.xml</p><pre class=" language-xml"><code class="language-xml">      <span class="token comment" spellcheck="true">&lt;!--文件上传解析器--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipartResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.multipart.commons.CommonsMultipartResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxUploadSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10485760<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="实现Excel上传"><a href="#实现Excel上传" class="headerlink" title="实现Excel上传"></a>实现Excel上传</h2><ol><li>pojo<pre><code>//objs数据位置和excel上传位置一致。public User(Object []objs,String companyId,String companyName) &#123;       //默认手机号excel读取为字符串会存在科学记数法问题，转化处理       this.mobile = new DecimalFormat(&quot;#&quot;).format(objs[2]);       this.username = objs[1].toString();       this.createTime = new Date();       this.timeOfEntry = (Date) objs[5];       this.formOfEmployment = ((Double) objs[4]).intValue() ;       this.workNumber = new DecimalFormat(&quot;#&quot;).format(objs[3]).toString();       this.companyId = companyId;       this.companyName = companyName;  &#125;</code></pre></li><li>Controller 添加上传方法<pre class=" language-Java"><code class="language-Java">//批量导入数据   @RequestMapping(value="/user/import", method = RequestMethod.POST)   public Result importExcel(@RequestParam(name = "upload") MultipartFile attachment) throws Exception &#123;       //根据上传流信息创建工作簿       Workbook workbook = WorkbookFactory.create(attachment.getInputStream());       //获取第一个sheet       Sheet sheet = workbook.getSheetAt(0);       List<User> users = new ArrayList<>();       //从第二行开始获取数据       for (int rowNum = 1; rowNum <sheet.getLastRowNum(); rowNum++) &#123;           Row row = sheet.getRow(rowNum);           Object objs[] = new Object[row.getLastCellNum()];           //从第二列获取数据           for(int cellNum = 1; cellNum < row.getLastCellNum();cellNum++) &#123;               Cell cell = row.getCell(cellNum);               objs[cellNum] = getValue(cell);          &#125;           //根据每一列构造用户对象          User user = new User(objs,companyId,companyName);           user.setDepartmentId(objs[objs.length-1].toString());           users.add(user);      &#125;       //第一个参数：用户列表，第二个参数：部门编码       userService.save(users,objs[objs.length-1].toString());       return Result.SUCCESS();  &#125;</code></pre></li><li>Service 保存信息<pre class=" language-Java"><code class="language-Java">@Transactional   public void save(List<User> users) throws Exception &#123;       for (User user : users) &#123;           //配置密码           user.setPassword(new Md5Hash("123456",user.getMobile(),3).toString());           //配置id           user.setId(idWorker.nextId()+"");           //其他基本属性           user.setInServiceStatus(1);           user.setEnableState(1);           user.setLevel("user");           //获取部门信息           Department dept =departmentFeignClient.findById(user.getDepartmentId(),user.getCompanyId());           if(dept != null) &#123;               user.setDepartmentId(dept.getId());               user.setDepartmentName(dept.getName());          &#125;           userDao.save(user);           &#125;  &#125;</code></pre><h2 id="POI报表导出"><a href="#POI报表导出" class="headerlink" title="POI报表导出"></a>POI报表导出</h2></li><li>Controller 添加导出方法<pre class=" language-Java"><code class="language-Java">@RequestMapping(value = "/export/&#123;month&#125;", method = RequestMethod.GET)   public void export(@PathVariable(name = "month") String month) throws Exception &#123;       //1.构造数据       List<EmployeeReportResult> list =userCompanyPersonalService.findByReport(companyId,month+"%");       //2.创建工作簿       XSSFWorkbook workbook = new XSSFWorkbook();       //3.构造sheet       String[] titles = &#123;"编号", "姓名", "手机","最高学历", "国家地区", "护照号", "籍贯", "生日", "属相","入职时间","离职类型","离职原因","离职时间"&#125;;       Sheet sheet = workbook.createSheet();        Row row = sheet.createRow(0);       AtomicInteger headersAi = new AtomicInteger();       for (String title : titles) &#123;           Cell cell = row.createCell(headersAi.getAndIncrement());           cell.setCellValue(title);      &#125;       AtomicInteger datasAi = new AtomicInteger(1);       Cell cell = null;       for (EmployeeReportResult report : list) &#123;           Row dataRow = sheet.createRow(datasAi.getAndIncrement());           //编号           cell = dataRow.createCell(0);           cell.setCellValue(report.getUserId());           //姓名           cell = dataRow.createCell(1);           cell.setCellValue(report.getUsername());           //手机           cell = dataRow.createCell(2);           cell.setCellValue(report.getMobile());           //最高学历           cell = dataRow.createCell(3);           cell.setCellValue(report.getTheHighestDegreeOfEducation());           //国家地区           cell = dataRow.createCell(4);           cell.setCellValue(report.getNationalArea());      &#125;       String fileName = URLEncoder.encode(month+"人员信息.xlsx", "UTF-8");       response.setContentType("application/octet-stream");       response.setHeader("content-disposition", "attachment;filename=" + newString(fileName.getBytes("ISO8859-1")));       response.setHeader("filename", fileName);       workbook.write(response.getOutputStream());  &#125;</code></pre></li></ol><p>dao层实现</p><pre class=" language-Java"><code class="language-Java"> @Select(value = "select new com.ihrm.domain.employee.response.EmployeeReportResult(a,b) " +            "FROM UserCompanyPersonal a LEFT JOIN EmployeeResignation b ON a.userId=b.userId )")    List<EmployeeReportResult> findByReport(String companyId, String month);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML解析</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%A7%A3%E6%9E%90HTML/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%A7%A3%E6%9E%90HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="Jsoup解析"><a href="#Jsoup解析" class="headerlink" title="Jsoup解析"></a>Jsoup解析</h2><p>  Java解析HTML文件一种解析器  </p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>导入jar包</li><li>获取Document对象</li><li>获取对应标签</li><li>获取数据</li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>Document: 文档对象,代表内存中dom树</li><li>Element:  元素对象,表示文档中的元素</li><li>Elements: 元素element对象的集合,可以当做ArrayList使用</li><li>Node:     节点对象;是Document和Element的父类<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3></li></ul><ol><li>parse: 解析html或者xml文档,返回Document对象;</li><li>获取子元素对象    * getElementById​(String id)：根据id属性值获取唯一的element对象    * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合    * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合    * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li><li>获取属性值    * String attr(String key)：根据属性名称获取属性值</li><li>获取文本内容    * String text():获取文本内容    * String html():获取标签体的所有内容(包括字标签的字符串内容)</li><li>选择器    * select(String str):使用选择器获取元素</li></ol><p><strong>案例:</strong></p><pre class=" language-Java"><code class="language-Java">import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class JsoupDemo04 &#123;  public static void main(String[] args) throws IOException &#123;    //  获取文件路径    String path = JsoupDemo01.class.getClassLoader().getResource("student.xml").getPath();    //  获取document对象;解析xml文件    Document document = Jsoup.parse(new File(path), "utf-8");    //  获取属性    Elements elements1 = document.getElementsByAttribute("id");    //  根据具体的属性名=属性值;获取元素    //  number="deyuan_0001"    Elements value = document.getElementsByAttributeValue("number", "deyuan_0001");    //  根据id属性值获取唯一的element对象    Element deyuan = document.getElementById("deyuan");    //  根据标签获取Elements 集合;获取元素对象集合    Elements elements = document.getElementsByTag("name");    //  获取元素对象的长度    System.out.println(elements.size());    //  获取第一个name的对象     Element ele_name = elements.get(0);    //  获取文本内容    String text = ele_name.text();    String html = ele_name.html();    //  标签选择器    Elements elements = document.select("name");    //  id选择器,查询  deyuan    Elements select = document.select("#deyuan");    //  属性选择器    //  获取属性  number=deyuan_0001的元素    Elements select1 = document.select("student[number=\"deyuan_0001\"]");    //  子标签选择器    Elements select2 = document.select("student[number=\"deyuan_0001\"] > age");  &#125;&#125;</code></pre><h3 id="Xpath方式解析文件"><a href="#Xpath方式解析文件" class="headerlink" title="Xpath方式解析文件"></a>Xpath方式解析文件</h3><p>​    <strong>XPath</strong>即为<a href="https://baike.baidu.com/item/XML">XML</a>路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。</p><p>   使用jsoup的xpath需要额外引入jar包</p><pre class=" language-Java"><code class="language-Java">package com.deyuan.demo04.jsoup;import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class JsoupXpath &#123;    public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123;        //获取文件路径        String path = JsoupDemo01.class.getClassLoader().getResource("student.xml").getPath();        //解析xml文件        Document document = Jsoup.parse(new File(path), "utf-8");        //根据document对象,创建JXDocument对象        JXDocument jxDocument = new JXDocument(document);        List<JXNode> jxNodes = jxDocument.selN("//student");        for (JXNode jxNode : jxNodes) &#123;            System.out.println(jxNode);        &#125;        System.out.println("=============");        //查询所有的student元素中的name标签        List<JXNode> jxNodes1 = jxDocument.selN("//student/name");        for (JXNode jxNode : jxNodes1) &#123;            System.out.println(jxNode);        &#125;        System.out.println("===================");        //查询student标签下所有带id属性的name标签        List<JXNode> jxNodes2 = jxDocument.selN("//student/name[@id]");        for (JXNode jxNode : jxNodes2) &#123;            System.out.println(jxNode);        &#125;        System.out.println("=========jxNodes3jxNodes3jxNodes3==========");        //查询student标签下所有带id属性的为德源的name标签        List<JXNode> jxNodes3 = jxDocument.selN("//student/name[@id='deyuan']");        for (JXNode jxNode : jxNodes3) &#123;            System.out.println(jxNode);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON解析</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%A7%A3%E6%9E%90JSON/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%A7%A3%E6%9E%90JSON/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Jackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架<br>Spring MVC 默认采用Jackson解析Json,出于最小依赖的考虑，Json解析第一选择应该是Jackson</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Jackson 社区相对比较活跃，更新速度也比较快， Jackson 所依赖的 jar 包较少 ，简单易用<br>Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Jackson 的 1.x 版本的包名是 org.codehaus.jackson ,<br>当升级到 2.x 版本时，包名变为 com.fasterxml.jackson。</p><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>Jackson 的核心模块由三部分组成</p><p>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json<br>jackson-annotations，注解包，提供标准注解功能；<br>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Jackson 最常用的 API 是基于”对象绑定” 的 ObjectMapper：</p><p>ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。<code>将JSON解析为Java对象也称为从JSON反序列化Java对象</code><br>ObjectMapper也可以从Java对象创建JSON。<code>从Java对象生成JSON也称为将Java对象序列化为JSON</code><br>Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象<br>之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">Car类：public class Car &#123;    private String brand = null;    private int doors = 0;    public String getBrand() &#123; return this.brand; &#125;    public void   setBrand(String brand)&#123; this.brand = brand;&#125;    public int  getDoors() &#123; return this.doors; &#125;    public void setDoors (int doors) &#123; this.doors = doors; &#125;&#125;将Json转换为Car类对象：public class Run&#123;  public static void main(String [] args)&#123;    ObjectMapper objectMapper = new ObjectMapper();    String carJson ="&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;";    try &#123;        Car car = objectMapper.readValue(carJson, Car.class);        System.out.println("car brand = " + car.getBrand());        System.out.println("car doors = " + car.getDoors());    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;  &#125;&#125;JSON字符串-->Java对象调用ObjectMapper的相关方法进行转换            1. readValue(json字符串数据,Class)</code></pre><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre class=" language-Java"><code class="language-Java">writeValue(File file,Object obj):Java对象转为json写入文件中writeValue(Writer writer,Object obj):Java对象转为json,响应字符输出流writeValue(OutputStream outputStream,Object obj):Java对象转为json,响应字节输出流String writeValueAsString(Object obj):Java对象转为json字符串</code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ol><li>@JsonIgnore：排除某个属性</li><li>@JsonFormat：属性值格式化</li></ol><ul><li>@JsonFormat(pattern = “yyyy-MM-dd”)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jdbc连接MySQL</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%BF%9E%E6%8E%A5MySQL/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%BF%9E%E6%8E%A5MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDBC 规范定义接口，具体的实现由数据库厂商实现<br>JDBC 是 Java 访问数据库的标准规范，真正操作数据库还需要具体的实现类，也就是数据库驱动<br>每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动。所以只需要调用 JDBC 接口中的方法即可，数据库驱动由数据库厂商提供。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>导入驱动jar包</li></ol><ul><li>项目下新建lib(插件)文件夹</li><li>将mysql驱动jar包解压至lib文件夹</li></ul><ol start="2"><li>注册驱动</li></ol><ul><li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>实际调用下方语句;下方语句不需要写</li><li>DriverManager.registerDriver(new Driver()); //注册数据库驱动</li></ul><ol start="3"><li>获取连接对象</li></ol><ul><li>使用用户名、密码、URL 得到连接对象<br><code>Connection connection = DriverManager.getConnection(url,用户名,密码);</code></li></ul><ol start="4"><li>获取执行sql对象或获取预编译sql对象</li></ol><ul><li>获取执行sql对象<br><code>Statement stat = conn.createStatement();</code></li><li>获取预编译sql对象<br><code>PreparedStatement prepareStatement = connection.prepareStatement(&quot;insert into student values (null,?,?,?)&quot;);</code></li></ul><ol start="5"><li>执行sql</li></ol><ul><li>增,删,改语句使用executeUpdate 执行sql,结果成功为影响的行数,执行失败返回0<br><code>int i = stat.executeUpdate(&quot;delete from student where name = &#39;陈七&#39;&quot;);</code></li><li>查询语句使用executeQuery方法执行sql,结果是ResultSet类型的结果集对象<br><code>ResultSet rs = stat.executeQuery( &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot; + password +&quot;&#39;&quot;);</code></li></ul><ol start="6"><li>处理结果</li></ol><pre class=" language-Java"><code class="language-Java">//  rs为查询的结果集对象while(rs.next())&#123;//next()判断下一个位置有没有结果,有则true,无则false;  int id = rs.getInt("id");//从结果集中获取值  String name = rs.getString("name");  double score = rs.getDouble("score");  String sex = rs.getString("sex");  Student stu = new Student(id,name,score,sex);  list.add(stu);&#125;</code></pre><ol start="7"><li>释放资源<pre class=" language-Java"><code class="language-Java">rs.close();stat.close();conn.close();</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><code>void setAutoCommit(boolean autoCommit)</code>//参数是 true 或 false;如果设置为 false，表示关闭自动提交，相当于开启事务<br><code>void commit()</code>    提交事务<br><code>void rollback()</code>    回滚事务</li></ol><h2 id="使用预编译sql对象-PreparedStatement"><a href="#使用预编译sql对象-PreparedStatement" class="headerlink" title="使用预编译sql对象(PreparedStatement)"></a>使用预编译sql对象(PreparedStatement)</h2><pre class=" language-Java"><code class="language-Java">PreparedStatement preparedStatement = connection.prepareStatement("select id from user where username=? and password=?");//使用PreparedStatement类型的对象需要填充占位符//占位符的填充位置从1开始,类型为要填充的数据类型preparedStatement.setString(1,username);preparedStatement.setString(2,password); ResultSet resultSet = preparedStatement.executeQuery();if(resultSet.next())&#123;   return  resultSet.getInt("id");&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis连接Redis</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%BF%9E%E6%8E%A5Redis/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20%E8%BF%9E%E6%8E%A5Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 连接Redis 的驱动程序</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>导入驱动jar包</li><li>创建连接对象</li><li>使用连接对象操作redis</li><li>关闭连接(释放资源)</li></ol><h2 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h2><pre class=" language-Java"><code class="language-Java">import redis.clients.jedis.Jedis; public class RedisJava &#123;    public static void main(String[] args) &#123;        //连接本地的 Redis 服务        Jedis jedis = new Jedis("localhost");        // 如果 Redis 服务设置了密码，需要下面这行，没有就不需要        // jedis.auth("123456");         System.out.println("连接成功");        //查看服务是否运行        System.out.println("服务正在运行: "+jedis.ping());    &#125;&#125;</code></pre><h2 id="操作数据结构"><a href="#操作数据结构" class="headerlink" title="操作数据结构"></a>操作数据结构</h2><p>这里使用junit测试redis</p><pre class=" language-Java"><code class="language-Java">import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;/** * @author zrh * @date 2022/2/28 * @apiNote */public class TestRedis &#123;    private Jedis jedis;    @Before    public void testBefore() &#123;        jedis = new Jedis("127.0.0.1", 6379);    &#125;    @After    public void testAfter() &#123;        jedis.close();    &#125;    /**     * 操作String类型     */    @Test    public void testString() &#123;        //  存储数据        jedis.set("stringKey", "stringValue");        //  获取数据        System.out.println(jedis.get("stringKey"));        //  删除数据        jedis.del("stringKey");        System.out.println(jedis.get("stringKey"));    &#125;    /**     * 操作Hash类型     */    @Test    public void testHash()&#123;        //  存储数据,单个添加        jedis.hset("hashKey1", "hashField1", "hashValue1");        jedis.hset("hashKey1", "hashField2", "hashValue2");        //  获取数据,单个获取        System.out.println(jedis.hget("hashKey1", "hashField1"));        System.out.println(jedis.hget("hashKey1", "hashField2"));        //  存储数据,添加整个map集合        Map<String,String> map = new HashMap<>();        map.put("hashField1","hashValue1");        map.put("hashField2","hashValue2");        jedis.hmset("hashKey2", map);        //  获取整个hash,返回值为HashMap类型        System.out.println(jedis.hgetAll("hashKey2"));        //  删除数据        jedis.hdel("hashKey2", "hashField1");        System.out.println(jedis.hgetAll("hashKey2"));    &#125;    /**     * 操作List类型     */    @Test    public void testList()&#123;        //  lpush在首部位置添加内容        jedis.lpush("listKey","listValue1","listValue2");        //  rpush在末尾位置添加内容        jedis.rpush("listKey","listValue3","listValue4");        //  获取list全部数据,返回值为List类型        List<String> listKey = jedis.lrange("listKey", 0, -1);        System.out.println(listKey);        //  删除首部位置元素        jedis.lpop("listKey");        //  删除末尾位置元素        jedis.rpop("listKey");    &#125;    /**     * 操作list person对象; 以序列化的方式存取     */    @Test    public void testList()&#123;                List<Person> list=new ArrayList<Person>();        list.add(new Person(1, "张三"));        list.add(new Person(2, "李四"));                jedis.set("key3".getBytes(), SerializeUtil.serialize(list));        byte[] personlistbyte = jedis.get(("key3").getBytes());        List<Person> list1 = (List<Person>) SerializeUtil.unserialize(personlistbyte);        System.out.println(list1);        jedis.close();    &#125;    /**     * 操作set类型     */    @Test    public void testSet()&#123;        //  添加数据        jedis.sadd("setKey","setMember1","setMember2");        //  获取数据;返回值为Set类型        Set<String> setKey = jedis.smembers("setKey");        //  删除数据        jedis.srem("setKey","setMember1");        jedis.srem("setKey");    &#125;    /**     * 操作sortedset类型     */    @Test    public void testSortedSet()&#123;        //  添加数据        jedis.zadd("sortedsetKey",5.2,"sortedsortMember1");        //  获取全部数据;返回值为Set类型        Set<String> sortedsetKey = jedis.zrange("sortedsetKey", 0, -1);        //  删除数据        jedis.zrem("sortedsetKey");    &#125;    /**     * 使用连接池     */    @Test    public  void testJedisPool()&#123;        //0.创建配置对象        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxTotal(50);        config.setMaxIdle(10);        //1.创建连接池对象        JedisPool jedisPool = new JedisPool(config,"localhost",6379);        //2.获取连接        Jedis jedis = jedisPool.getResource();        //3.使用        jedis.set("name","hehe");        //4.归还连接        jedis.close();    &#125;&#125;</code></pre><h2 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h2><p>配置文件</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token attr-name">maxTotal</span><span class="token punctuation">=</span><span class="token attr-value">50</span><span class="token attr-name">maxIdle</span><span class="token punctuation">=</span><span class="token attr-value">10</span></code></pre><p>工具类</p><pre class=" language-Java"><code class="language-Java">import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @author zrh * @date 2022/3/1 * @apiNote */public class JedisUtils &#123;private static JedisPool jedisPool;    static &#123;        InputStream inputStream = JedisUtils.class.getClassLoader().getResourceAsStream("jedis.properties");        Properties properties = new Properties();        try &#123;            properties.load(inputStream);            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        jedisPoolConfig.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle")));        jedisPoolConfig.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal")));        jedisPool = new JedisPool(jedisPoolConfig,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port")));    &#125;    public static JedisPool getJedisPool() &#123;        return jedisPool;    &#125;    public static void close()&#123;        jedisPool.close();    &#125;&#125;</code></pre><p>测试类</p><pre class=" language-Java"><code class="language-Java">public class TestRedis &#123;    //工具类测试    @Test    public void testJedisPoolUtil()&#123;        Jedis jedis = JedisUtils.getJedisPool().getResource();        jedis.set("name","lisi");        String name = jedis.get("name");        System.out.println(name);        //释放连接        JedisUtils.close();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架简介</title>
      <link href="/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/11/Java/Java%20%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>框架半成品软件;框架可以极大的提高开发效率;使我们程序员只需要关注业务。</p><p>Mybatis：持久层框架（替代掉我们以前的jdbc）<br>spring<br>springMVC：表示层框架（解决Servlet的封装）<br>springBoot：替代掉spring和springMVC<br>springCloud：（微服务架构，治理型框架）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="/2022/02/11/XML/xml%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/02/11/XML/xml%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>XML 指可扩展标记语言（eXtensible Markup Language）</p><blockquote><p>可扩展 : 标签可以自定义<code>&lt;user&gt; &lt;person&gt;</code></p></blockquote><p>XML 被设计用来传输和存储数据<br>XML 被设计用来结构化、存储以及传输信息</p><h3 id="XML与HTML的区别"><a href="#XML与HTML的区别" class="headerlink" title="XML与HTML的区别"></a>XML与HTML的区别</h3><p>XML   被设计用来传输和存储数据，其焦点是数据的内容<br>HTML  被设计用来显示数据，其焦点是数据的外观</p><h4 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h4><ol><li>xml标签是自定义的,HTML标签是预定义</li><li>xml语法比较严格, html语法比较松散</li><li>xml是存储数据的,html是展示数据的.</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>  把数据从 HTML 分离<br>  简化数据共享<br>  简化数据传输<br>  简化平台变更</p><h4 id="具体作用"><a href="#具体作用" class="headerlink" title="具体作用"></a>具体作用</h4><p>存储数据:</p><ol><li>配置文件</li><li>在网络中传输.</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- XML 声明。定义XML的版本(1.0)和所使用的编码(UTF-8 : 万国码, 可显示各种语言) --></span><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- 根元素 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 子元素 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Tove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>Jani<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget me this weekend!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 根元素结尾 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span></code></pre><blockquote><p>XML将数据组织成为一棵树,DOM 通过解析 XML 文档,为 XML 文档在逻辑上建立一个树模型,树的节点是一个个的对象。这样通过操作这棵树和这些对象就可以完成对 XML 文档的操作,为处理文档的所有方面提供了一个完美的概念性框架</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>xml声明(版本号,字符编码等…),必须放在第一行</li><li>必须有根元素</li><li>所有元素必须有<code>闭合标签</code>;声明不属于元素</li><li>大小写敏感(必须使用相同的大小写来编写打开标签和关闭标签)​</li><li>必须正确嵌套</li><li>属性值必须加引号</li><li>实体引用<ul><li>一些字符拥有特殊的意义;如<code>&lt;</code>字符,<code>&lt;</code>放在XML元素中会发生错误,因为解析器会把它当作新元素的开始,为了避免这个错误，必须使用<code>实体引用</code>来代替 <code>&lt;</code>字符</li><li>预定义的实体引用<br>| &lt;      | &lt; | less than |<br>| &gt;      | &gt; | greater than |<br>| &amp;      | &amp; | ampersand |<br>| &apos;  | ‘ | apostrophe |<br>| &quot;  | “ | quotation mark |</li><li>使用案例：<code>&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</code></li></ul></li><li>注释<br><code>&lt;!-- 这里的内容不会展示 --&gt;</code></li><li>空格会被保留<ul><li>在XML中，文档中的空格不会被删减</li></ul></li><li>xml文档的后缀名,必须是.xml</li><li>标签中的属性值必须使用引号(单双引号)引起来</li></ol><h3 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h3><ol><li>格式:  必须放到第一行 <code>&lt;?xml 属性列表?&gt;</code></li><li>属性列表:<ul><li>version  版本号   <strong><code>必须属性</code></strong></li><li>encoding: 编码格式,告知解析引擎当前文档使用的字符集,默认值: ISO-8859-1</li><li>standalone：是否独立<ul><li>取值：<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ul><li>名称可以包含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li><li>名称不能包含空格<h3 id="命名推荐习惯"><a href="#命名推荐习惯" class="headerlink" title="命名推荐习惯"></a>命名推荐习惯</h3>使用下划线的名称<br>避免 “-“ 字符。一些软件会认为您想要从 first 里边减去 name<br>避免 “.” 字符。一些软件会认为 “name” 是对象 “first” 的属性<br>避免 “:” 字符。冒号会被转换为命名空间来使用</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性（Attribute）提供有关元素的额外信息<br>属性必须加引号<br>在 XML 中，应该尽量避免使用属性。如果信息类似于数据，那么请使用元素</p><h3 id="避免-XML-属性？"><a href="#避免-XML-属性？" class="headerlink" title="避免 XML 属性？"></a>避免 XML 属性？</h3><p>使用属性而引起的一些问题：</p><ul><li>属性不能包含多个值（元素可以）</li><li>属性不能包含树结构（元素可以）</li><li>属性不容易扩展（为未来的变化）</li><li>属性难以阅读和维护。<code>请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息</code><br>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素<h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3>向元素分配 ID 引用。这些 ID 索引可用于标识 XML 元素，它起作用的方式与 HTML 中 id 属性是一样的<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>messages</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>501<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Tove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>Jani<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget me this weekend!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>502<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Jani<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>Tove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Re: Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>I will not<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>messages</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h2><p>约束 : 规定xml文档书写规则<br>作为框架的使用者(程序员):</p><ol><li>能够在xml中引入约束文件</li><li>能够简单的读懂约束文档,(不要求会写)<br>作为框架的开发者(程序员):</li></ol><ul><li>能够定义约束文档</li><li>DTD 基础约束文件 <ul><li>通过 DTD 验证的XML是”合法”的 XML</li><li>例:   student.data</li><li>引入方式<br>  本地:<!DOCTYPE students SYSTEM "student.dtd"><br>  远程:<pre class=" language-dtd"><code class="language-dtd"><!ELEMENT students (student*) ><!ELEMENT student (name,age,sex)><!ELEMENT name (#PCDATA)><!ELEMENT age (#PCDATA)><!ELEMENT sex (#PCDATA)><!ATTLIST student number ID #REQUIRED></code></pre><pre class=" language-XML"><code class="language-XML"><?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE students SYSTEM "student.dtd"><students><student number="deyuan_0001">  <name>tom</name>  <age>18</age>  <sex>male</sex></student></students></code></pre></li></ul></li><li>Schema 复杂的约束技术<br>例:<pre class=" language-xsd"><code class="language-xsd"><?xml version="1.0"?><xsd:schema xmlns="http://www.deyuan.com/xml"      xmlns:xsd="http://www.w3.org/2001/XMLSchema"      targetNamespace="http://www.deyuan.com/xml" elementFormDefault="qualified">  <xsd:element name="students" type="studentsType"/>  <xsd:complexType name="studentsType">      <xsd:sequence>          <xsd:element name="student" type="studentType" minOccurs="0" maxOccurs="unbounded"/>      </xsd:sequence>  </xsd:complexType>  <xsd:complexType name="studentType">      <xsd:sequence>          <xsd:element name="name" type="xsd:string"/>          <xsd:element name="age" type="ageType" />          <xsd:element name="sex" type="sexType" />      </xsd:sequence>      <xsd:attribute name="number" type="numberType" use="required"/>  </xsd:complexType>  <xsd:simpleType name="sexType">      <xsd:restriction base="xsd:string">          <xsd:enumeration value="male"/>          <xsd:enumeration value="female"/>      </xsd:restriction>  </xsd:simpleType>  <xsd:simpleType name="ageType">      <xsd:restriction base="xsd:integer">          <xsd:minInclusive value="0"/>          <xsd:maxInclusive value="256"/>      </xsd:restriction>  </xsd:simpleType>  <xsd:simpleType name="numberType">      <xsd:restriction base="xsd:string">          <xsd:pattern value="deyuan_\d&#123;4&#125;"/>      </xsd:restriction>  </xsd:simpleType></xsd:schema> </code></pre>``` XML<?xml version="1.0" encoding="UTF-8" ?><!--   1.填写xml文档的根元素  2.引入xsi前缀.  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  3.引入xsd文件命名空间.  xsi:schemaLocation="http://www.deyuan.com/xml  student.xsd"  4.为每一个xsd约束声明一个前缀,作为标识  xmlns="http://www.deyuan.com/xml"     </li><li>-&gt;<br>&lt;students   xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><pre><code>        xmlns=&quot;http://www.deyuan.com/xml&quot;       xsi:schemaLocation=&quot;http://www.deyuan.com/xml  student.xsd&quot;       &gt;</code></pre>   <student number="deyuan_0001">       <name>tom</name>       <age>18</age>       <sex>male</sex>   </student></li></ul> </students>```<h2 id="XML-查看"><a href="#XML-查看" class="headerlink" title="XML 查看"></a>XML 查看</h2><p>在主流的浏览器中，均能够查看原始的 XML 文件;XML 文件不会直接显示为 HTML 页面<br>查看无效的(有错的) XML 文件，浏览器会报告错误</p><h2 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2><p>操作xml文件</p><ol><li>解析(读取): 将文档中的数据读取到内存中</li><li>写入:将内存中的数据,写入到xml文档中,持久化存储</li></ol><h3 id="解析xml方式"><a href="#解析xml方式" class="headerlink" title="解析xml方式"></a>解析xml方式</h3><p>  Java解析xml常用方式DOM4j</p><h4 id="DOM4j解析"><a href="#DOM4j解析" class="headerlink" title="DOM4j解析"></a>DOM4j解析</h4><pre class=" language-Java"><code class="language-Java">package com.cxx.xml;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.util.Iterator;import java.util.List;/** * @Author: cxx * Dom4j解析xml * @Date: 2018/5/30 12:21 */public class Dom4JDemo &#123;    public static void main(String[] args) throws Exception &#123;        //1.创建Reader对象        SAXReader reader = new SAXReader();        //2.加载xml        Document document = reader.read(new File("src/main/resources/demo.xml"));        //3.获取根节点        Element rootElement = document.getRootElement();        Iterator iterator = rootElement.elementIterator();        while (iterator.hasNext())&#123;            Element stu = (Element) iterator.next();            List<Attribute> attributes = stu.attributes();            System.out.println("======获取属性值======");            for (Attribute attribute : attributes) &#123;                System.out.println(attribute.getValue());            &#125;            System.out.println("======遍历子节点======");            Iterator iterator1 = stu.elementIterator();            while (iterator1.hasNext())&#123;                Element stuChild = (Element) iterator1.next();                System.out.println("节点名："+stuChild.getName()+"---节点值："+stuChild.getStringValue());            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>  XPath 是一门在 XML 文档中查找信息的语言， 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 同时被构建于 XPath 表达之上。因此，对 XPath 的理解是很多高级 XML 应用的基础<br>  XPath非常类似对数据库操作的SQL语言，或者说JQuery，它可以方便开发者抓起文档中需要的东西<code>(dom4j也支持xpath)</code></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><pre class=" language-Java"><code class="language-Java">import java.io.IOException;import java.io.InputStream;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.XPath;import javax.xml.xpath.XPathConstants;import javax.xml.xpath.XPathExpression;import javax.xml.xpath.XPathExpressionException;import javax.xml.xpath.XPathFactory;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;public class TestXPath &#123;  public static void main(String[] args) &#123;    read();  &#125;  public static void read() &#123;    try &#123;      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();      DocumentBuilder builder = dbf.newDocumentBuilder();      InputStream in = TestXPath.class.getClassLoader().getResourceAsStream("test.xml");      Document doc = builder.parse(in);      XPathFactory factory = XPathFactory.newInstance();      XPath xpath = factory.newXPath();      // 选取所有class元素的name属性      // XPath语法介绍： http://w3school.com.cn/xpath/      XPathExpression expr = xpath.compile("//class/@name");      NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);      for (int i = 0; i < nodes.length();i++)&#123;        System.out.println("name = " + nodes.item(i).getNodeValue());      &#125;    &#125; catch (XPathExpressionException e) &#123;      e.printStackTrace();    &#125; catch (ParserConfigurationException e) &#123;      e.printStackTrace();    &#125; catch (SAXException e) &#123;      e.printStackTrace();    &#125; catch (IOException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre>--></li></ul>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN</title>
      <link href="/2022/02/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/SVN/"/>
      <url>/2022/02/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/SVN/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端功能"><a href="#服务端功能" class="headerlink" title="服务端功能"></a>服务端功能</h2><p>仓库管理<br>用户管理</p><h2 id="客户端功能"><a href="#客户端功能" class="headerlink" title="客户端功能"></a>客户端功能</h2><p>代码拉取<br>代码提交<br>代码回滚</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和生命周期</title>
      <link href="/2022/02/11/Java/Mybatis/4.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/02/11/Java/Mybatis/4.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="mybatis构建流程"><a href="#mybatis构建流程" class="headerlink" title="mybatis构建流程"></a>mybatis构建流程</h2><ol><li><p>使用mybatis提供的Resources工具类读取  核心配置文件(SqlMapConfig.xml)<br><code>InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</code></p></li><li><p>创建SqlSessionFactoryBuilder构建者对象(SqlSessionFactoryBuilder采用构建者模式)<br><code>SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</code></p></li><li><p>使用SqlSessionFactoryBuilder对象去构建SqlSessionFactory工厂对象(SqlSessionFactory采用工厂模式)<br><code>SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</code></p></li><li><p>使用SqlSessionFactory工厂对象去创建SqlSession对象 (openSession默认不开启事务)<br><code>SqlSession sqlSession = sqlSessionFactory.openSession();</code></p></li><li><p>使用SqlSession对象去创建代理对象<br><code>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</code></p></li><li><p>使用代理对象去调用方法</p><pre class=" language-Java"><code class="language-Java">User user = new User(null, "张三", Date.valueOf("2012-12-11"), "男", "南京");userMapper.addUser(user);</code></pre></li><li><p>释放资源</p><pre class=" language-Java"><code class="language-Java">//  这里提交事务sqlSession.commit();try &#123;   inputStream.close();&#125; catch (IOException e) &#123;   e.printStackTrace();&#125;sqlSession.close();</code></pre></li></ol><p>提示 对象生命周期和依赖注入框架</p><p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。</p><p>SqlSessionFactoryBuilder<br>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><p>SqlSessionFactory<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p>SqlSession<br>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><p>try (SqlSession session = sqlSessionFactory.openSession()) {<br>  // 你的应用逻辑代码<br>}<br>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p><p>映射器实例<br>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p><p>try (SqlSession session = sqlSessionFactory.openSession()) {<br>  BlogMapper mapper = session.getMapper(BlogMapper.class);<br>  // 你的应用逻辑代码<br>}</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射文件</title>
      <link href="/2022/02/11/Java/Mybatis/3.%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/11/Java/Mybatis/3.%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="xml版本信息和mybatis对mapper的dtd约束"><a href="#xml版本信息和mybatis对mapper的dtd约束" class="headerlink" title="xml版本信息和mybatis对mapper的dtd约束"></a>xml版本信息和mybatis对mapper的dtd约束</h2><pre class=" language-XML"><code class="language-XML"><!-- xml版本信息 --><?xml version="1.0" encoding="UTF-8"?><!-- mybatis对mapper的dtd约束条件 --><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></code></pre><h2 id="映射根元素mapper"><a href="#映射根元素mapper" class="headerlink" title="映射根元素mapper"></a>映射根元素mapper</h2><p>属性<code>namespace</code>指向接口全限定名</p><h2 id="mapper的xml映射文件"><a href="#mapper的xml映射文件" class="headerlink" title="mapper的xml映射文件"></a>mapper的xml映射文件</h2><pre class=" language-XML"><code class="language-XML"><!-- namespace属性必须是接口的全限定接口名 --><mapper namespace="cn.dy.mapper.UserMapper">    <!-- id属性值必须和接口中的方法名相同 -->    <!-- resultType属性值必须是pojo的全限定接口名 -->    <!-- parameterType属性值必须是方法参数的全限定接口名 -->    <!-- sql中的参数以 #&#123;pojo中的属性名&#125; 的形式传递-->    <select id="findUserById" resultType="cn.dy.pojo.User" parameterType="java.lang.Integer">        SELECT username,birthday,sex,address FROM user WHERE id = #&#123;id&#125;    </select>    <!-- 这里在添加后返回主键id -->    <!-- keyColumn为数据库中的列名 -->    <!-- keyProperty为pojo中的属性名 -->    <!-- order 取值:AFTER,BEFORE;AFTER:添加后返回,BEFORE:添加前返回(有可能导致id错误) -->    <insert id="addUser" parameterType="cn.dy.pojo.User">        INSERT INTO user (username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)        <selectKey resultType="java.lang.Integer" keyColumn="id" keyProperty="id" order="AFTER">            select last_insert_id()        </selectKey>    </insert></mapper></code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><pre class=" language-XML"><code class="language-XML"></code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><pre class=" language-XML"><code class="language-XML"></code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre class=" language-XML"><code class="language-XML"></code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre class=" language-XML"><code class="language-XML"></code></pre><h2 id="参数深入"><a href="#参数深入" class="headerlink" title="参数深入"></a>参数深入</h2><p>使用组合代替继承的方式来解决多表的问题</p><h2 id="返回值结果集的封装-用来解决数据库列名与pojo实体类属性不一致的情况"><a href="#返回值结果集的封装-用来解决数据库列名与pojo实体类属性不一致的情况" class="headerlink" title="返回值结果集的封装(用来解决数据库列名与pojo实体类属性不一致的情况)"></a>返回值结果集的封装(用来解决数据库列名与pojo实体类属性不一致的情况)</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>sql语句中起别名</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用resultMap映射数据库中的列名</p><pre class=" language-XML"><code class="language-XML"><mapper namespace="cn.dy.mapper.UserMapper">  <!-- resultMap标签用来封装结果集,id的值为自己起的名字,type的值为要映射的实体类的全限定名 -->  <resultMap id="userMap" type="cn.dy.pojo.User">  <!-- property 为实体类中的属性名 -->  <!-- column 为数据库中的列名 -->      <!-- id 用来映射主键  -->      <id property="" column="" ></id>      <!-- result 用来映射其它数据 -->      <result property="" column=""></result>  </resultMap>  <!-- resultMap的值为上方自己定义的名字    -->  <select id="findAll" resultMap="userMap">          SELECT id,username,birthday,sex,address FROM user  </select></mapper></code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心配置文件</title>
      <link href="/2022/02/11/Java/Mybatis/2.%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/11/Java/Mybatis/2.%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>mybatis使用xml作为核心配置文件,建议文件名称为<code>SqlMapConfig.xml</code></p><h2 id="xml版本信息和mybatis对核心配置文件的dtd约束"><a href="#xml版本信息和mybatis对核心配置文件的dtd约束" class="headerlink" title="xml版本信息和mybatis对核心配置文件的dtd约束"></a>xml版本信息和mybatis对核心配置文件的dtd约束</h2><pre class=" language-XML"><code class="language-XML"><!-- xml版本信息 --><?xml version="1.0" encoding="UTF-8"?><!-- mybatis对config的dtd约束条件 --><!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"></code></pre><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>configuration（配置）<ul><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境配置）<ul><li>environment（环境变量）</li><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ul></li></ul><h3 id="配置信息根标签configuration"><a href="#配置信息根标签configuration" class="headerlink" title="配置信息根标签configuration"></a>配置信息根标签configuration</h3><p>配置信息都包含在configuration中</p><h3 id="属性properties"><a href="#属性properties" class="headerlink" title="属性properties"></a>属性properties</h3><p><strong>属性可以在整个配置文件中用来替换需要动态配置的属性值</strong></p><p>属性在外部配置<br>属性文件内容</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/mybatis</span><span class="token attr-name">username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">root</span></code></pre><ol><li>使用resource指向属性文件<br><code>&lt;properties resource=&quot;jdbcConfig.properties&quot;&gt;&lt;/properties&gt;</code></li><li>使用url指向属性文件<br><code>&lt;properties url=&quot;file:///E:/Java%20%E6%95%99%E7%A8%8B/Mybatis%E6%95%99%E7%A8%8B/day4/src/main/resources/jdbcConfig.properties&quot;&gt;&lt;/properties&gt;</code></li></ol><p>属性在内部配置</p><pre class=" language-XML"><code class="language-XML"><properties >    <property name="driver" value="com.mysql.jdbc.Driver"/>    <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>    <property name="username" value="root"/>    <property name="password" value="root"/></properties></code></pre><p>属性的使用</p><pre class=" language-XML"><code class="language-XML"><dataSource type="POOlED">  <property name="driver" value="$&#123;driver&#125;"/>  <property name="url" value="$&#123;url&#125;"/>  <property name="username" value="$&#123;username&#125;"/>  <property name="password" value="$&#123;password&#125;"/></dataSource></code></pre><h3 id="设置settings"><a href="#设置settings" class="headerlink" title="设置settings"></a>设置settings</h3><p>暂未使用,详见官网:<a href="https://mybatis.net.cn/configuration.html">https://mybatis.net.cn/configuration.html</a></p><h3 id="类型别名typeAliases"><a href="#类型别名typeAliases" class="headerlink" title="类型别名typeAliases"></a>类型别名typeAliases</h3><p>类型别名可为 pojo 类设置一个缩写名字。仅用于 XML 配置，用于降低冗余的全限定类名书写</p><pre class=" language-XML"><code class="language-XML"><typeAliases>  <!-- 为cn.dy.pojo.User起个别名为user -->  <typeAlias type="cn.dy.pojo.User" alias="user"></typeAlias></typeAliases></code></pre><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean<br><strong>推荐使用此方式</strong></p><pre class=" language-XML"><code class="language-XML"><typeAliases>    <package name="cn.dy.pojo"></package></typeAliases></code></pre><h3 id="类型处理器typeHandlers"><a href="#类型处理器typeHandlers" class="headerlink" title="类型处理器typeHandlers"></a>类型处理器typeHandlers</h3><p>暂未使用,详见官网:<a href="https://mybatis.net.cn/configuration.html">https://mybatis.net.cn/configuration.html</a></p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><pre class=" language-XML"><code class="language-XML"><!--配置mybatis环境 这里默认使用MySQL配置--><environments default="mysql">    <!--配置MySQL环境-->    <environment id="mysql">        <!-- MySQL事务 -->        <transactionManager type="JDBC"></transactionManager>        <!--数据源(连接池) POOLED为mybatis的数据源-->        <dataSource type="POOLED">            <property name="driver" value="com.mysql.jdbc.Driver"/>            <property name="url" value="jdbc:mysql:///mybatis"/>            <property name="username" value="root"/>            <property name="password" value="root"/>        </dataSource>    </environment></environments></code></pre><h3 id="映射器mappers"><a href="#映射器mappers" class="headerlink" title="映射器mappers"></a>映射器mappers</h3><p>映射文件引用</p><p>使用相对于类路径的资源引用</p><pre class=" language-XML"><code class="language-XML"><mappers>  <mapper resource="cn/dy/mapper/userMapper.xml"/></mappers></code></pre><p>将包内的映射器接口实现全部注册为映射器,不再需要一个一个引入<br><strong>推荐</strong></p><pre class=" language-XML"><code class="language-XML"><mappers>  <package name="cn.dy.mapper"/></mappers></code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表操作</title>
      <link href="/2022/02/11/Java/Mybatis/8.%E5%A4%9A%E8%A1%A8/"/>
      <url>/2022/02/11/Java/Mybatis/8.%E5%A4%9A%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一对一<br>一对多<br>多对一<br>多对多</p><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p><strong>建表</strong><br>共二表<br>两张表之间是一对多的关系:<code>在多的表中添加字段指向一的表的主键</code></p><p><strong>建类</strong><br>共需两个pojo类,两个mapper接口<br>在一的类中添加一个多类型的集合属性,例</p><pre class=" language-Java"><code class="language-Java">一个用户可以有多个账户账户类public class Account &#123;    private Integer id;    private Integer uId;    private double money;&#125;用户类public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    //  使用Account类型的集合来表示:用户有多个账户    List<Account> accounts;&#125;</code></pre><p><strong>UserMapper.xml  sql语句</strong><br>查询</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 自定义返回值映射 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccount<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--  collection集合  property为要映射的属性名  ofType集合中的元素类型  --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accounts<span class="token punctuation">"</span></span>  <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aId<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--查询所有用户及用户的账户信息  需要使用自定义的返回值映射--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findUserAccount<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccount<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    SELECT u.id, u.username, u.birthday, u.sex, u.address, a.id aId, a.money    FROM `user` u LEFT JOIN account a ON u.id = a.uId;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p><strong>测试</strong></p><pre class=" language-Java"><code class="language-Java">public class TestUser &#123;  private InputStream inputStream;  private SqlSession sqlSession;  private UserMapper userMapper;  private SqlSessionFactory sqlSessionFactory;  @Before  public void init() &#123;    try &#123;        inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);    //  这里的事务默认不开启    sqlSession = sqlSessionFactory.openSession();    userMapper = sqlSession.getMapper(UserMapper.class);  &#125;  @After  public void destory() &#123;    //  这里提交事务    sqlSession.commit();    try &#123;        inputStream.close();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    sqlSession.close();  &#125;  //  查询所有用户及用户的账户信息  @Test  public void testUserAccount() &#123;    List<User> userAccount = userMapper.findUserAccount();    for (User user : userAccount) &#123;      System.out.println(user);      for (Account account : user.getAccounts()) &#123;          System.out.println(account);      &#125;      System.out.println("---------------------------------------");    &#125;  &#125;&#125;</code></pre><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p><strong>建表</strong><br>共二表<br>两张表之间是一对多的关系:<code>在多的表中添加字段指向一的表的主键</code></p><p><strong>建类</strong><br>共需两个pojo类,两个mapper接口<br>在多的类中添加一类型的属性例</p><pre class=" language-Java"><code class="language-Java">多个账户有同一个用户账户类public class Account &#123;    private Integer id;    private Integer uId;    private double money;    //  使用User类型的属性来表示:多个账户有一个用户    private  User user;&#125;用户类public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;&#125;</code></pre><p><strong>SQL操作</strong><br>查询</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 返回值映射 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountUser<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- association 映射user属性 --></span>  <span class="token comment" spellcheck="true">&lt;!--  property：要映射的属性名  column：列名   javaType：要映射的类型 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uId<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--查询所有账户及账户的用户信息--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAccountUser<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT a.id, a.money, u.id uId, u.username, u.birthday, u.sex, u.address  from account a LEFT JOIN user u ON a.UID = u.id;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p><strong>测试</strong></p><pre class=" language-Java"><code class="language-Java">public class TestAccount &#123;  private InputStream inputStream;  private SqlSession sqlSession;  private AccountMapper accountMapper;  private SqlSessionFactory sqlSessionFactory;  @Before  public void init() &#123;    try &#123;        inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);    //  这里的事务默认不开启    sqlSession = sqlSessionFactory.openSession();    accountMapper = sqlSession.getMapper(AccountMapper.class);  &#125;  @After  public void destory() &#123;    //  这里提交事务    sqlSession.commit();    try &#123;        inputStream.close();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    sqlSession.close();  &#125;  //  查询所有账户及账户的用户信息  @Test  public  void testAccountUser()&#123;    List<Account> accounts = accountMapper.findAccountUser();    for (Account account : accounts) &#123;        System.out.println(account);        System.out.println(account.getUser());        System.out.println("--------------------------------------------");    &#125;  &#125;&#125;</code></pre><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p><strong>建表</strong><br>共三表<br>两张表之间是多对多的关系:<code>需要添加一个中间表</code><br>中间表的两个字段分别关联两张表的主键<br><strong>建类</strong><br>共需两个pojo类,两个mapper接口<br>在类中添加另一类型的集合属性</p><pre class=" language-Java"><code class="language-Java">多个账户有同一个用户角色类public class Role &#123;    private Integer id;    private String roleName;    private String roleDesc;    //  指向另一表    private List<User> users;&#125;用户类public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    //  指向另一表    private List<Role> roles;&#125;</code></pre><p><strong>SQL操作</strong><br>查询</p><p>UserMapper.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userRole<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roles<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleDesc<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleDesc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--查询所有用户,用户包含拥有的角色--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findUserRole<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userRole<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    SELECT u.id,            u.username,            u.birthday,            u.sex,            u.address,            r.ID rId,            r.ROLE_DESC roleDesc,            r.ROLE_NAME roleName    FROM `user` u              LEFT JOIN user_role ur ON u.id = ur.UID              LEFT JOIN role r ON ur.RID = r.ID<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>RoleMapper.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleUser<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleDesc<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleDesc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>users<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--查询所有用户,用户包含拥有的角色--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findRoleUser<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleUser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    SELECT u.id,            u.username,            u.birthday,            u.sex,            u.address,            r.ID        rId,            r.ROLE_DESC roleDesc,            r.ROLE_NAME roleName    FROM `role` r              LEFT JOIN user_role ur ON r.id = ur.RID              LEFT JOIN user u ON ur.UID = u.id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p><strong>测试</strong><br>TestUser.java</p><pre class=" language-Java"><code class="language-Java">public class TestUser &#123;  private InputStream inputStream;  private SqlSession sqlSession;  private UserMapper userMapper;  private SqlSessionFactory sqlSessionFactory;  @Before  public void init() &#123;      try &#123;          inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125;      SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();      sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);      //  这里的事务默认不开启      sqlSession = sqlSessionFactory.openSession();      userMapper = sqlSession.getMapper(UserMapper.class);  &#125;  @After  public void destory() &#123;      //  这里提交事务      sqlSession.commit();      try &#123;          inputStream.close();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125;      sqlSession.close();  &#125;  @Test  public void testUserRole() &#123;      List<User> userRole = userMapper.findUserRole();      for (User user : userRole) &#123;          System.out.println(user);          System.out.println(user.getRoles());          System.out.println("--------------------------");      &#125;  &#125;&#125;</code></pre><p>TestRole.java</p><pre class=" language-Java"><code class="language-Java">public class TestRole &#123;  private InputStream inputStream;  private SqlSession sqlSession;  private RoleMapper roleMapper;  private SqlSessionFactory sqlSessionFactory;  @Before  public void init() &#123;      try &#123;          inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125;      SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();      sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);      //  这里的事务默认不开启      sqlSession = sqlSessionFactory.openSession();      roleMapper = sqlSession.getMapper(RoleMapper.class);  &#125;  @After  public void destory() &#123;      //  这里提交事务      sqlSession.commit();      try &#123;          inputStream.close();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125;      sqlSession.close();  &#125;  @Test  public void testUserRole() &#123;      List<Role> roleUser = roleMapper.findRoleUser();      for (Role role : roleUser) &#123;          System.out.println(role);          System.out.println(role.getUsers());          System.out.println("--------------------------");      &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/2022/02/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20File%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20File%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  File类文件和目录路径名的抽象表示形式。里面有一些文件和目录(文件夹)的相关    操作。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><code>public File(String pathname)</code> pathname表示文件的路径</li><li><code>public File(String parent, String child)</code> parent表示文件的位置，child表示文件名</li><li><code>public File(File parent, String child)</code>parent表示文件路径的file对象，child表示文件名<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="获取功能方法："><a href="#获取功能方法：" class="headerlink" title="获取功能方法："></a>获取功能方法：</h3></li><li>public String getAbsolutePath()<br>获取绝对路径</li><li>public String getPath()<br>获取路径(构造里是什么，就会获取什么)</li><li>public String getName()<br>获取路径最后一串内容，一般是文件名</li><li>public long length()<br>获取文件的大小（目录没有大小）</li></ul><h3 id="判断功能方法："><a href="#判断功能方法：" class="headerlink" title="判断功能方法："></a>判断功能方法：</h3><ul><li>public boolean exists()<br>判断文件或目录是否存在</li><li>public boolean isDirectory()<br>判断该对象是否为目录</li><li>public boolean isFile()<br>判断该对象是否为文件<h3 id="创建删除功能的方法："><a href="#创建删除功能的方法：" class="headerlink" title="创建删除功能的方法："></a>创建删除功能的方法：</h3></li><li>public boolean createNewFile()<br>创建新的文件</li><li>public boolean delete()<br>删除文件或非空目录</li><li>public boolean mkdir()<br>创建新目录，如果父目录不存在，则创建失败</li><li>public boolean mkdirs()<br>创建多级目录，如果父目录不存在，则创建父目录<h3 id="目录的遍历（下面两个方法必须要确保file对象是一个目录）"><a href="#目录的遍历（下面两个方法必须要确保file对象是一个目录）" class="headerlink" title="目录的遍历（下面两个方法必须要确保file对象是一个目录）"></a>目录的遍历（下面两个方法必须要确保file对象是一个目录）</h3></li><li>public String[] list()<br>获取目录中所有的内容名称，存储到一个字符串数组中。</li><li>public File[] listFiles()<br>获取目录中所有的内容，存储到一个文件数组中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 流</title>
      <link href="/2022/02/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO%E6%B5%81/"/>
      <url>/2022/02/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作<br><strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据</p><h2 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h2><p><code>java.io.InputStream</code>字节输入流;输入字节流的所有类的超类<br><code>java.io.OutputStream</code>字节输出流;输出字节流的所有类的超类<br><code>java.io.Reader</code>字符输入流;读取字符流的抽象类<br><code>java.io.Writer</code>字符输出流;写入字符流的抽象类</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据的流向分类：</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流</li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流</li></ul><p>数据的类型分类：</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流</li></ul><h2 id="扩展流"><a href="#扩展流" class="headerlink" title="扩展流"></a>扩展流</h2><ul><li><strong>缓冲流</strong> ：缓冲流,也叫高效流，是对4个基本流的增强，所以也是4个流</li><li><strong>转换流</strong> ：转换编码的转换流</li><li><strong>序列化流</strong> ：持久化存储对象的序列化流</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>lambda表达式<br>1.函数式编程思想<br>面向对象：根据多个对象中共有的属性和行为抽取出一个类，类去创建对象，对象调用方法。<br>函数式编程思想：<br>不去关心是哪个对象去做的，不关心怎么做的，只需要一个输入值，然后得到一个结果。<br>在java中函数式编程思想的体现就是lambda表达式。<br>可以把lambda表达式当作匿名内部类的简化版格式。（底层其实有一些区别）</p><ul><li>当接口作为方法的参数时，我们实际要传入一个接口的实现类的对象，之前我们使用匿名内部类来简化这    个过程，但是匿名内部类的格式过于繁琐，不易阅读，所以，在jdk1.8时提供了lambda的语法在某些情况    下可以替代掉匿名内部类。</li></ul><p>2.使用前提<br>1）接口必须是函数式接口（接口中只能有一个抽象方法）。<br>2）要具有上下文推断。<br>3.格式：<br>()-&gt;{}<br>()：接口中抽象方法的参数<br>-&gt;：没有特殊含义，就是一个传递作用。<br>{}：抽象方法的方法体的重写。<br>4.省略规则<br>1）小括号中方法的参数类型可以省略。<br>2）当小括号中只有一个参数时，小括号可以省略。<br>3）当方法体中只有一条语句时，return，语句后的分号，{}都可以省略。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整型</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E6%95%B4%E5%9E%8B/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E6%95%B4%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-整数间的除法运算如何保留所有小数位？"><a href="#Java-整数间的除法运算如何保留所有小数位？" class="headerlink" title="Java 整数间的除法运算如何保留所有小数位？"></a>Java 整数间的除法运算如何保留所有小数位？</h2><p>　　因为在Java中，由运算结果，由被运算数的最高数据类型决定，也就是说：整数之间的运算，数据类型都为int类型，所以，返回的结果也为int类型。<br>　　如果我们想要返回完整的运算结果 ，我们就需要将其中一个的数据类型转换成double类型或者float类型，而不是只改变接收运算结果的数据类型！<br>例:<br><code>double a = 55/Double.valueOf(5)</code></p><h2 id="1000-1000为false-100-100为true"><a href="#1000-1000为false-100-100为true" class="headerlink" title="1000==1000为false,100==100为true"></a>1000==1000为false,100==100为true</h2><p>IntegerCache.java缓存了-128到127之间的整型对象<br>所以声明 int a = 100时,内部:<code>Integer i = Integer.valueOf(100);</code>直接返回了缓存的实例<br>缓存的原因:(猜测)小整型使用率比大整型使用率高,可以减少潜在的内存占用</p>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-流异常</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E6%B5%81%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E6%B5%81%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandleException1</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 声明变量</span>        FileWriter fw <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建流对象</span>            fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 写出数据</span>            fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"德源程序员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//德源程序员</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fw <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    fw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>创建流对象语句，如果多个<span class="token punctuation">,</span>使用<span class="token string">';'</span>隔开<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 读写数据</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>代码使用演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandleException2</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 创建流对象</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span> FileWriter fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 写出数据</span>            fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"德源程序员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//德源程序员</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 被final修饰的对象</span><span class="token keyword">final</span> Resource resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">"resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 普通对象</span>Resource resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">"resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 引入方式：创建新的变量保存</span><span class="token keyword">try</span> <span class="token punctuation">(</span>Resource r1 <span class="token operator">=</span> resource1<span class="token punctuation">;</span>     Resource r2 <span class="token operator">=</span> resource2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 使用对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>改进后格式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 被final修饰的对象</span><span class="token keyword">final</span> Resource resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">"resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 普通对象</span>Resource resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">"resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 引入方式：直接引入</span><span class="token keyword">try</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">;</span> resource2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 使用对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>改进后，代码使用演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TryDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 创建流对象</span>        <span class="token keyword">final</span>  FileReader fr  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileWriter fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 引入到try中</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>fr<span class="token punctuation">;</span> fw<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 定义变量</span>            <span class="token keyword">int</span> b<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 读取数据</span>              <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 写出数据</span>                fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-转换流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E8%BD%AC%E6%8D%A2%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E8%BD%AC%E6%8D%A2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>按照某种规则，将字符存储到计算机中，称为<strong>编码</strong><br>将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。<br>按照A规则存储，再按照B规则解析，就会导致<strong>乱码</strong></p><h2 id="编码-字符–-gt-字节"><a href="#编码-字符–-gt-字节" class="headerlink" title="编码:(字符–&gt;字节)"></a>编码:(字符–&gt;字节)</h2><p>字符按照某种规则编译,转换为二进制数(字节)</p><h2 id="解码-字节–-gt-字符"><a href="#解码-字节–-gt-字符" class="headerlink" title="解码:(字节–&gt;字符)"></a>解码:(字节–&gt;字符)</h2><p>二进制数按照某种规则解析,转换为字符</p><h2 id="字符编码Character-Encoding"><a href="#字符编码Character-Encoding" class="headerlink" title="字符编码Character Encoding :"></a><strong>字符编码<code>Character Encoding</code></strong> :</h2><p>就是一套自然语言的字符与二进制数之间的对应规则</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>编码表:生活中文字和计算机中二进制的对应规则</p><ul><li>**字符集 <code>Charset</code>**：也叫<code>编码表</code>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E8%BD%AC%E6%8D%A2%E6%B5%81/1_charset.jpg"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="编码引出的问题"><a href="#编码引出的问题" class="headerlink" title="编码引出的问题"></a>编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><pre class=" language-Java"><code class="language-Java">public class ReaderDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileReader fileReader = new FileReader("E:\\File_GBK.txt");        int read;        while ((read = fileReader.read()) != -1) &#123;            System.out.print((char)read);        &#125;        fileReader.close();    &#125;&#125;输出结果：���</code></pre><p><strong><code>读取GBK编码的文件</code></strong></p><h2 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>的子类，是<code>从字节流到字符流的桥梁</code>。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>案例:</p><pre class=" language-Java"><code class="language-Java">public class ReaderDemo2 &#123;    public static void main(String[] args) throws IOException &#123;          // 定义文件路径,文件为gbk编码        String FileName = "E:\\file_gbk.txt";          // 创建流对象,默认UTF8编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));          // 创建流对象,指定GBK编码        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK");            // 定义变量,保存字符        int read;          // 使用默认编码字符流读取,乱码        while ((read = isr.read()) != -1) &#123;            System.out.print((char)read); // ��Һ�        &#125;        isr.close();                // 使用指定编码字符流读取,正常解析        while ((read = isr2.read()) != -1) &#123;            System.out.print((char)read);// 大家好        &#125;        isr2.close();    &#125;&#125;</code></pre><h2 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是<code>Writer</code>的子类，是<code>从字符流到字节流的桥梁</code>。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>案例:</p><pre class=" language-Java"><code class="language-Java">public class OutputDemo &#123;    public static void main(String[] args) throws IOException &#123;          // 定义文件路径        String FileName = "E:\\out.txt";          // 创建流对象,默认UTF8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));        // 写出数据          osw.write("你好"); // 保存为6个字节        osw.close();                      // 定义文件路径            String FileName2 = "E:\\out2.txt";           // 创建流对象,指定GBK编码        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK");        // 写出数据          osw2.write("你好");// 保存为4个字节        osw2.close();    &#125;&#125;</code></pre><h2 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h2><p><strong>转换流是字节与字符间的桥梁！</strong><img src="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E8%BD%AC%E6%8D%A2%E6%B5%81/2_zhuanhuan.jpg"></p><h2 id="练习：转换文件编码"><a href="#练习：转换文件编码" class="headerlink" title="练习：转换文件编码"></a>练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre class=" language-Java"><code class="language-Java">public class TransDemo &#123;   public static void main(String[] args) &#123;              // 1.定义文件路径         String srcFile = "file_gbk.txt";        String destFile = "file_utf8.txt";        // 2.创建流对象        // 2.1 转换输入流,指定GBK编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK");        // 2.2 转换输出流,默认utf8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));        // 3.读写数据        // 3.1 定义数组        char[] cbuf = new char[1024];        // 3.2 定义长度        int len;        // 3.3 循环读取        while ((len = isr.read(cbuf))!=-1) &#123;            // 循环写出              osw.write(cbuf,0,len);        &#125;        // 4.释放资源        osw.close();        isr.close();      &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-缓冲流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E7%BC%93%E5%86%B2%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E7%BC%93%E5%86%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><pre class=" language-Java"><code class="language-Java">// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));</code></pre><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录开始时间</span>          <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建流对象</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>            FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdk9.exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"copy.exe"</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 读写数据</span>            <span class="token keyword">int</span> b<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通流复制时间:"</span><span class="token operator">+</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>十几分钟过去了<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><ol start="2"><li>缓冲流，代码如下：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录开始时间</span>          <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建流对象</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>            BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdk9.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         BufferedOutputStream bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"copy.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 读写数据</span>            <span class="token keyword">int</span> b<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓冲流复制时间:"</span><span class="token operator">+</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>缓冲流复制时间<span class="token operator">:</span><span class="token number">8016</span> 毫秒</code></pre><p>如何更快呢？</p><p>使用数组的方式，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 记录开始时间</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建流对象</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>            BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdk9.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         BufferedOutputStream bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"copy.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 读写数据</span>            <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓冲流使用数组复制时间:"</span><span class="token operator">+</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>缓冲流使用数组复制时间<span class="token operator">:</span><span class="token number">666</span> 毫秒</code></pre><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建字符缓冲输入流</span>BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"br.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建字符缓冲输出流</span>BufferedWriter bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"bw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedReaderDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 创建流对象</span>        BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定义字符串,保存读取的一行文字</span>        String line  <span class="token operator">=</span> null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 循环读取,读取到最后返回null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 释放资源</span>        br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>newLine</code>方法演示，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedWriterDemo</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建流对象</span>      BufferedWriter bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写出数据</span>      bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"德源"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写出换行</span>      bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 释放资源</span>      bw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>输出效果<span class="token operator">:</span>德源程序员</code></pre><h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p><pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</code></pre><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-字符流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件</p><h3 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中</li></ul><h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。<br>idea中UTF-8</li><li>字节缓冲区：一个字节数组，用来临时存储字节数据。</li></ol></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>创建流对象时，必须传入一个文件路径。类似于FileInputStream</p><ul><li>构造举例，代码如下：<br>``` Java<br>public class FISRead {<br>  public static void main(String[] args) throws IOException {<pre><code>    // 使用文件名称创建流对象     FileReader fr = new FileReader(&quot;read.txt&quot;);    // 定义变量，保存有效字符个数  int len ；  // 定义字符数组，作为装字符数据的容器  char[] cbuf = new char[2];  // 循环读取  while ((len = fr.read(cbuf))!=-1) &#123;      System.out.println(new String(cbuf,0,len));  &#125;  // 关闭资源  fr.close();</code></pre>  }<br>}</li></ul><p>输出结果：<br>德源<br>程序<br>员</p><pre><code>#### 读取字符数据1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：```javapublic class FRRead &#123;    public static void main(String[] args) throws IOException &#123;          // 使用文件名称创建流对象           FileReader fr = new FileReader(&quot;read.txt&quot;);          // 定义变量，保存数据        int b ；        // 循环读取        while ((b = fr.read())!=-1) &#123;            System.out.println((char)b);        &#125;        // 关闭资源        fr.close();    &#125;&#125;输出结果：黑马程序员</code></pre><p>读取字符数据</p><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><p><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code></p><pre class=" language-Java"><code class="language-Java">public class FRRead &#123;    public static void main(String[] args) throws IOException &#123;          // 使用文件名称创建流对象           FileReader fr = new FileReader("read.txt");          // 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器         char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) &#123;            System.out.println(new String(cbuf));        &#125;        // 关闭资源        fr.close();    &#125;&#125;输出结果：德源程序员序</code></pre><p>获取有效的字符改进，代码使用演示</p><pre class=" language-Java"><code class="language-Java">public class FISRead &#123;    public static void main(String[] args) throws IOException &#123;          // 使用文件名称创建流对象           FileReader fr = new FileReader("read.txt");          // 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器        char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) &#123;            System.out.println(new String(cbuf,0,len));        &#125;        // 关闭资源        fr.close();    &#125;&#125;输出结果：德源程序员</code></pre><h4 id="字符输出流【Writer】"><a href="#字符输出流【Writer】" class="headerlink" title="字符输出流【Writer】"></a>字符输出流【Writer】</h4><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h4 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h4><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：<pre class=" language-Java"><code class="language-Java">public class FileWriterConstructor &#123;  public static void main(String[] args) throws IOException &#123;          // 使用File对象创建流对象      File file = new File("a.txt");      FileWriter fw = new FileWriter(file);          // 使用文件名称创建流对象      FileWriter fw = new FileWriter("b.txt");  &#125;&#125;</code></pre></li></ul><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><pre class=" language-Java"><code class="language-Java">public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter("fw.txt");               // 写出数据          fw.write(97); // 写出第1个字符          fw.write('b'); // 写出第2个字符          fw.write('C'); // 写出第3个字符          fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。                /*        【注意】关闭资源时,与FileOutputStream不同。           如果不关闭,数据只是保存到缓冲区，并未保存到文件。        */        // fw.close();    &#125;&#125;输出结果：abC田</code></pre><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><pre class=" language-Java"><code class="language-Java">public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter("fw.txt");        // 写出数据，通过flush        fw.write('刷'); // 写出第1个字符        fw.flush();        fw.write('新'); // 继续写出第2个字符，写出成功        fw.flush();                // 写出数据，通过close        fw.write('关'); // 写出第1个字符        fw.close();        fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed        fw.close();    &#125;&#125;</code></pre><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：<pre class=" language-Java"><code class="language-Java">public class FWWrite &#123; public static void main(String[] args) throws IOException &#123;     // 使用文件名称创建流对象     FileWriter fw = new FileWriter("fw.txt");            // 字符串转换为字节数组       char[] chars = "德源程序员".toCharArray();          // 写出字符数组       fw.write(chars); // 德源程序员          // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。     fw.write(b,2,2); // 程序          // 关闭资源     fos.close(); &#125;&#125;</code></pre></li></ol><p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</p><pre class=" language-Java"><code class="language-Java">public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter("fw.txt");               // 字符串          String msg = "德源程序员";                // 写出字符数组          fw.write(msg); //德源程序员              // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。        fw.write(msg,2,2);    // 程序                  // 关闭资源        fos.close();    &#125;&#125;</code></pre><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FWWrite</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用文件名称创建流对象，可以续写数据</span>        FileWriter fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span>，<span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 写出字符串</span>        fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"德源"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 写出换行</span>          fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 写出字符串</span>          fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"程序员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 关闭资源</span>        fw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>输出结果<span class="token operator">:</span>德源程序员</code></pre><blockquote><p>小贴士：<br>字符流，只能操作文本文件<br>操作图片，视频等非文本文件使用字节流</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-字节流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据</p><h2 id="字节输出流【OutputStream】"><a href="#字节输出流【OutputStream】" class="headerlink" title="字节输出流【OutputStream】"></a>字节输出流【OutputStream】</h2><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流</li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p><font color="red">注意：</font><br>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><p><code>java.io.FileOutputStream</code>是<code>OutputStream</code>的常用子类;是一个文件输出流，用于将数据写出到文件</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>创建流对象时，必须传入文件路径;该路径下，如果没有这个文件，会创建该文件;</li></ul><ol><li>重写;清空数据</li></ol><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件  </li></ul><ol start="2"><li>续写;追加续写数据</li></ol><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件<br><code>boolean append</code>的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空数据;这样创建的输出流对象，就可以指定是否追加续写</li></ul><p>案例：</p><pre class=" language-Java"><code class="language-Java">public class FileOutputStreamConstructor throws IOException &#123;    public static void main(String[] args) &#123;                      File file = new File("a.txt");        //  使用File对象创建流对象        FileOutputStream fos1 = new FileOutputStream(file);        //  使用File对象创建流对象;启用  数据追加        FileOutputStream fos11 = new FileOutputStream(file,true);        //  使用文件名称创建流对象        FileOutputStream fos2 = new FileOutputStream("b.txt");        // 使用文件名称创建流对象;启用  数据追加        FileOutputStream fos22 = new FileOutputStream("fos.txt"，true);    &#125;&#125;</code></pre><h4 id="写出数据"><a href="#写出数据" class="headerlink" title="写出数据"></a>写出数据</h4><p><code>void write(int b)</code> 将指定的字节写入此文件输出流<br><code>void write(byte[] b)</code> 将 b.length个字节从指定的字节数组写入此文件输出流<br><code>void write(byte[] b, int off, int len)</code> 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流<br>案例:</p><pre class=" language-Java"><code class="language-Java">public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream("fos.txt");             //  写出1个字节的数据          fos.write(97);         // 注意：虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。        //  写出整个字节数组的数据          byte[] b = "德源程序员".getBytes();//  字符串转换为字节数组          //  写出字节数组数据          fos.write(b);        //  写出指定长度字节数组的数据          byte[] b = "abcde".getBytes();//  字符串转换为字节数组            // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b,2,2);          // 关闭资源        fos.close();    &#125;&#125;输出结果：abc输出结果：德源程序员输出结果：cd</code></pre><h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows系统里，换行符号是<code>\r\n</code><br>案例：</p><pre class=" language-Java"><code class="language-Java">public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream("fos.txt");            // 定义字节数组          byte[] words = &#123;97,98,99,100,101&#125;;          // 遍历数组        for (int i = 0; i < words.length; i++) &#123;              // 写出一个字节            fos.write(words[i]);              // 写出一个换行, 换行符号转成数组写出            fos.write("\r\n".getBytes());        &#125;          // 关闭资源        fos.close();    &#125;&#125;输出结果：abcde</code></pre><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="字节输入流【InputStream】"><a href="#字节输入流【InputStream】" class="headerlink" title="字节输入流【InputStream】"></a>字节输入流【InputStream】</h2><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>注意：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>例：</li></ul><pre class=" language-Java"><code class="language-Java">public class FileInputStreamConstructor throws IOException&#123;    public static void main(String[] args) &#123;            // 使用File对象创建流对象        File file = new File("a.txt");        FileInputStream fos = new FileInputStream(file);              // 使用文件名称创建流对象        FileInputStream fos = new FileInputStream("b.txt");    &#125;&#125;</code></pre><h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><p><strong>读取字节</strong>：<code>read</code>方法，每次读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code><br>案例：</p><pre class=" language-Java"><code class="language-Java">public class FISRead &#123;    public static void main(String[] args) throws IOException&#123;          // 使用文件名称创建流对象           FileInputStream fis = new FileInputStream("read.txt");          // 读取一个字节数据，返回一个字节        int read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);          // 读取到末尾,返回-1           read = fis.read();        System.out.println( read);        //  循环改进读取方式        // 定义变量，保存数据        int b ；        // 循环读取        while ((b = fis.read())!=-1) &#123;            System.out.println((char)b);        &#125;        //  使用字节数组读取        //  定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) &#123;               // 每次读取后,把数组的有效字节部分，变成字符串打印            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数        &#125;            // 关闭资源        fis.close();    &#125;&#125;</code></pre><blockquote><p>小贴士：<br>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，开发中必须使用此方式</p></blockquote><h2 id="字节流案例-图片复制"><a href="#字节流案例-图片复制" class="headerlink" title="字节流案例(图片复制)"></a>字节流案例(图片复制)</h2><pre class=" language-Java"><code class="language-Java">public class Copy &#123;    public static void main(String[] args) throws IOException &#123;        // 1.创建流对象        // 1.1 指定数据源        FileInputStream fis = new FileInputStream("D:\\test.jpg");        // 1.2 指定目的地        FileOutputStream fos = new FileOutputStream("test_copy.jpg");        // 2.读写数据        // 2.1 定义数组        byte[] b = new byte[1024];        // 2.2 定义长度        int len;        // 2.3 循环读取        while ((len = fis.read(b))!=-1) &#123;            // 2.4 写出数据            fos.write(b, 0 , len);        &#125;        // 3.关闭资源        fos.close();        fis.close();    &#125;&#125;</code></pre><blockquote><p>小贴士：<br>流的关闭原则：先开后关，后开先关</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-序列化流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。<br>看图理解序列化： <img src="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/3_xuliehua.jpg"></p><h2 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><pre class=" language-java"><code class="language-java">FileOutputStream fileOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"employee.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ObjectOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fileOut<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><p>序列化条件</p><ol><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code></li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰</li></ol><pre class=" language-Java"><code class="language-Java">public class Employee implements java.io.Serializable &#123;    public String name;    public String address;    public transient int age; // transient瞬态修饰成员,不会被序列化    public void addressCheck() &#123;          System.out.println("Address  check : " + name + " -- " + address);    &#125;&#125;</code></pre><p>写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。<pre class=" language-Java"><code class="language-Java">public class SerializeDemo&#123;     public static void main(String [] args)   &#123;      Employee e = new Employee();      e.name = "zhangsan";      e.address = "beiqinglu";      e.age = 20;       try &#123;            // 创建序列化流对象        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt"));          // 写出对象          out.writeObject(e);          // 释放资源          out.close();          fileOut.close();          System.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。      &#125; catch(IOException i)   &#123;          i.printStackTrace();      &#125;     &#125;&#125;输出结果：Serialized data is saved</code></pre></li></ul><h2 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。<h3 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h3>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</li></ul><ul><li><code>public final Object readObject ()</code> : 读取一个对象。<pre class=" language-Java"><code class="language-Java">public class DeserializeDemo &#123; public static void main(String [] args)   &#123;      Employee e = null;      try &#123;                   // 创建反序列化流           FileInputStream fileIn = new FileInputStream("employee.txt");           ObjectInputStream in = new ObjectInputStream(fileIn);           // 读取一个对象           e = (Employee) in.readObject();           // 释放资源           in.close();           fileIn.close();      &#125;catch(IOException i) &#123;           // 捕获其他异常           i.printStackTrace();           return;      &#125;catch(ClassNotFoundException c)  &#123;          // 捕获类找不到异常           System.out.println("Employee class not found");           c.printStackTrace();           return;      &#125;      // 无异常,直接打印输出      System.out.println("Name: " + e.name);    // zhangsan      System.out.println("Address: " + e.address); // beiqinglu      System.out.println("age: " + e.age); // 0  &#125;&#125;</code></pre></li></ul><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><pre class=" language-Java"><code class="language-Java">public class Employee implements java.io.Serializable &#123;     // 加入序列版本号     private static final long serialVersionUID = 1L;     public String name;     public String address;     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.     public int eid;      public void addressCheck() &#123;         System.out.println("Address  check : " + name + " -- " + address);     &#125;&#125;</code></pre><h3 id="序列化集合"><a href="#序列化集合" class="headerlink" title="序列化集合"></a>序列化集合</h3><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建 学生对象</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">,</span> <span class="token string">"laow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"老张"</span><span class="token punctuation">,</span> <span class="token string">"laoz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"老李"</span><span class="token punctuation">,</span> <span class="token string">"laol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Student<span class="token operator">></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>student2<span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>student3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 序列化操作</span>        <span class="token comment" spellcheck="true">// serializ(arrayList);</span>                <span class="token comment" spellcheck="true">// 反序列化  </span>        ObjectInputStream ois  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"list.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 读取对象,强转为ArrayList类型</span>        ArrayList<span class="token operator">&lt;</span>Student<span class="token operator">></span> list  <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              Student s <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">getPwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">serializ</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Student<span class="token operator">></span> arrayList<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建 序列化流 </span>        ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"list.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写出对象</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 释放资源</span>        oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO-打印流</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E6%89%93%E5%8D%B0%E6%B5%81/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20IO-%E6%89%93%E5%8D%B0%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h2 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li></ul><h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。<br>案例:</p><pre class=" language-Java"><code class="language-Java">public class PrintDemo &#123;    public static void main(String[] args) throws IOException &#123;      // 调用系统的打印流,控制台直接输出97      System.out.println(97);              // 创建打印流,指定文件的名称      PrintStream ps = new PrintStream("ps.txt");                // 设置系统的打印流流向,输出到ps.txt      System.setOut(ps);      // 调用系统的打印流,ps.txt中输出97      System.out.println(97);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
            <tag> Java IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E8%BF%90%E7%AE%97/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-整数间的除法运算如何保留所有小数位？"><a href="#Java-整数间的除法运算如何保留所有小数位？" class="headerlink" title="Java 整数间的除法运算如何保留所有小数位？"></a>Java 整数间的除法运算如何保留所有小数位？</h2><p>　　因为在Java中，由运算结果，由被运算数的最高数据类型决定，也就是说：整数之间的运算，数据类型都为int类型，所以，返回的结果也为int类型。<br>　　如果我们想要返回完整的运算结果 ，我们就需要将其中一个的数据类型转换成double类型或者float类型，而不是只改变接收运算结果的数据类型！<br>例:<br><code>double a = 55/Double.valueOf(5)</code></p>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/MySQL/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>减少服务器内存压力</li><li>提高用户体验</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前端-&gt;后端<br>传递参数: </p><ol><li>当前页码(pageIndex):查询第几页的数据 设置默认值</li><li>每页展示的记录个数(pageSize):每页展示多少数据 设置默认值</li></ol><p>后端-&gt;前端<br>传递参数:</p><ol><li>总条数(total)    - 获取方式:查询数据库<code>select count(1) from 表名</code> </li><li>分页查询出来的数据(data)    - <code>select * from 表名 limit 开始索引,每页显示条数</code><ol><li>开始的索引 = (当前页码-1) * 每页显示条数</li><li>每页显示条数,由前端传递</li></ol></li><li>总页数(pageNum)    - 获取方式:<code>pageNum = total % pageSize == 0 ? total / pageSize : total / pageSize + 1</code>    - 56/5=5时,需要6页来展示</li><li>当前页码(pageIndex)    - 前端传递</li><li>每页显示条数(pageSize)    - 前端传递</li></ol><p>分页实体类（PageVo）</p><pre class=" language-Java"><code class="language-Java">/* * pageNum 页数 * pageSize 个数 * pageIndex 当前页码 * total 总条数 * data 数据 */public class PageVo<T> &#123;  // 用户列表参数  private Integer pageNum;  private Integer pageSize;  private Integer pageIndex;  private Integer total;  private List<T> data;  public PageVo() &#123;  &#125;  public PageVo(Integer pageNum, Integer pageSize, Integer pageIndex, Integer total, List<T> data) &#123;      this.pageNum = pageNum;      this.pageSize = pageSize;      this.pageIndex = pageIndex;      this.total = total;      this.data = data;  &#125;  public Integer getPageNum() &#123;      return pageNum;  &#125;  public void setPageNum(Integer pageNum) &#123;      this.pageNum = pageNum;  &#125;  public Integer getPageSize() &#123;      return pageSize;  &#125;  public void setPageSize(Integer pageSize) &#123;      this.pageSize = pageSize;  &#125;  public Integer getPageIndex() &#123;      return pageIndex;  &#125;  public void setPageIndex(Integer pageIndex) &#123;      this.pageIndex = pageIndex;  &#125;  public Integer getTotal() &#123;      return total;  &#125;  public void setTotal(Integer total) &#123;      this.total = total;  &#125;  public List<T> getData() &#123;      return data;  &#125;  public void setData(List<T> data) &#123;      this.data = data;  &#125;  @Override  public String toString() &#123;      return "PageVo&#123;" +              "pageNum=" + pageNum +              ", pageSize=" + pageSize +              ", pageIndex=" + pageIndex +              ", total=" + total +              ", data=" + data +              '&#125;';  &#125;&#125;</code></pre><p>service层</p><pre class=" language-Java"><code class="language-Java">public class UserServiceImpl implements UserService &#123;  private UserDao userDao = new UserDaoImpl();  @Override  public PageVo<User> findByPage(int pageIndex, int pageSize) &#123;    int total = userDao.selectCount();    int pageNum = total % pageSize == 0 ? total / pageSize : total / pageSize + 1;    List<User> users = userDao.findLimit((pageNum - 1) * pageSize, pageSize);    return new PageVo<User>(pageNum,pageSize,pageIndex,total,users);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判空</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E5%88%A4%E7%A9%BA/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/%E5%88%A4%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="判空的使用区别"><a href="#判空的使用区别" class="headerlink" title="判空的使用区别"></a>判空的使用区别</h2><ol><li>null 是一个有效有意义的返回值<br>返回一个空对象（而非null对象）</li><li>null是无效有误的<br>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚”</li></ol><h2 id="相对于判空语句，更好的检查方式"><a href="#相对于判空语句，更好的检查方式" class="headerlink" title="相对于判空语句，更好的检查方式"></a>相对于判空语句，更好的检查方式</h2><ol><li>assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得</li><li>也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</li></ol><h2 id="equals方法使用"><a href="#equals方法使用" class="headerlink" title="equals方法使用"></a>equals方法使用</h2><p>用equals方法，请用object&lt;不可能为空&gt;.equals(object&lt;可能为空&gt;))<br>例如使用：<br><code>&quot;bar&quot;.equals(foo)</code><br>该方案可以避免空指针异常</p><h2 id="使用spring自带工具类进行判空操作-推荐"><a href="#使用spring自带工具类进行判空操作-推荐" class="headerlink" title="使用spring自带工具类进行判空操作(推荐)"></a>使用spring自带工具类进行判空操作(推荐)</h2>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigDecimal</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/java.math.BigDecimal/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/java.math.BigDecimal/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用来对超过16位有效位的数进行 <strong><code>精确的运算</code></strong><br>包:<code>java.math.BigDecimal</code><br>float和double只能用来做科学计算或者是工程计算;在商业计算中要用<code>BigDecimal</code><br>BigDecimal所创建的是对象，进行数学运算，必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象</p><h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法(构造器)"></a>构造方法(构造器)</h2><p><code>BigDecimal(int)</code>       创建一个具有参数所指定整数值的对象<br><code>BigDecimal(double)</code>    创建一个具有参数所指定双精度值的对象(<code>不推荐使用</code>)<br><code>BigDecimal(long)</code>      创建一个具有参数所指定长整数值的对象<br><code>BigDecimal(String)</code>    创建一个具有参数所指定以字符串表示的数值的对象(<code>推荐使用</code>)</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>BigDecimal add(BigDecimal)</code>         BigDecimal对象中的值相加，然后返回这个对象<br><code>BigDecimal subtract(BigDecimal)</code>    BigDecimal对象中的值相减，然后返回这个对象<br><code>BigDecimal multiply(BigDecimal)</code>    BigDecimal对象中的值相乘，然后返回这个对象<br><code>BigDecimal divide(BigDecimal)</code>      BigDecimal对象中的值相除，然后返回这个对象<br>toString()              将BigDecimal对象的数值转换成字符串<br>doubleValue()           将BigDecimal对象中的值以双精度数返回<br>floatValue()            将BigDecimal对象中的值以单精度数返回<br>longValue()             将BigDecimal对象中的值以长整数返回<br>intValue()              将BigDecimal对象中的值以整数返回</p><h2 id="BigDecimal-double-不推荐使用的原因"><a href="#BigDecimal-double-不推荐使用的原因" class="headerlink" title="BigDecimal(double)不推荐使用的原因"></a>BigDecimal(double)不推荐使用的原因</h2><ol><li>参数类型为double的构造方法的结果有一定的不可预知性;<code>new BigDecimal(0.1)</code>所创建的BigDecimal实际上等于0.1000000000000000055511151231257827021181583404541015625;因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）</li><li>String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法<br>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</li></ol><h2 id="BigDecimal做等值比较"><a href="#BigDecimal做等值比较" class="headerlink" title="BigDecimal做等值比较"></a>BigDecimal做等值比较</h2><p> 使用compareTo 方法</p>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Api设计</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/api%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/api%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><p>任何API设计都遵循一种叫做“面向资源设计”的原则：</p><p>资源：资源是数据的一部分，例如：用户</p><p>集合：一组资源称为集合，例如：用户列表</p><p>URL：标识资源或集合的位置，例如：/user</p><ol><li><p><strong>API格式黄金法则</strong><br>扁平比嵌套好<br>简单胜于复杂<br>字符串比数字好<br>一致性比定制更好</p></li><li><p>对CRUD函数使用HTTP方法,用于解释CRUD功能<br>GET：检索资源的表示形式<br>POST：创建新的资源和子资源<br>PUT：更新现有资源<br>PATCH：更新现有资源，它只更新提供的字段，而不更新其他字段<br>DELETE：删除已存在的资源</p></li><li><p>始终在API中使用版本控制<br>始终对API使用版本控制，并将其向左移动，使其具有最大的作用域。版本号应该是v1，v2等等。<br>应该：<a href="http://api.domain.com/v1/shops/3/products">http://api.domain.com/v1/shops/3/products</a><br>始终在API中使用版本控制，因为如果API被外部实体使用，更改端点可能会破坏它们的功能。</p></li><li><p>不要使用table_name作为资源名<br>不应该：<br>product_order<br>应该：<br>product-orders<br>这是因为公开底层体系结构不是你的目的</p></li><li><p>监控<br>RESTful HTTP服务必须实现/health和/version和/metricsAPI端点。他们将提供以下信息。</p></li></ol><p>/health<br>用200 OK状态码响应对/health的请求<br>/version<br>用版本号响应对/version的请求<br>/metrics<br>这个端点将提供各种指标，如平均响应时间<br>也强烈推荐使用/debug和/status端点</p><ol start="6"><li><p>对URL使用kebab-case（短横线小写隔开形式）<br>例<code>/system-orders</code></p></li><li><p>参数使用camelCase（小驼峰形式）<br>例<code>/system-orders/&#123;orderId&#125;</code></p></li><li><p>指向集合的复数名称<br>例<code>/users</code></p></li><li><p>URL以集合开始，以标识符结束<br><code>/shops/:shopId/或/category/:categoryId</code></p></li><li><p>让动词远离你的资源URL<br>例:<code>PUT /user/&#123;userId&#125;</code></p></li><li><p>对非资源URL使用动词(非crud)<br>例:<code>/alarm/245743/resend</code></p></li><li><p>JSON属性使用camelCase驼峰形式<br>例:</p><pre class=" language-Json"><code class="language-Json">&#123;"userName": "Mohammad Faisal","userId": "1"&#125;</code></pre></li><li><p>使用API设计工具</p></li></ol><p>有许多好的API设计工具用于编写好的文档，例如：<br>API蓝图：<a href="https://apiblueprint.org/">https://apiblueprint.org/</a><br>Swagger：<a href="https://swagger.io/">https://swagger.io/</a></p><p>拥有良好而详细的文档可以为API使用者带来良好的用户体验。</p><ol start="14"><li>在你的响应体中包括总资源数</li></ol><p>如果API返回一个对象列表，则响应中总是包含资源的总数。你可以为此使用total属性。</p><p>不应该：<br>{<br>  users: [<br>     …<br>  ]<br>}</p><p>应该：<br>{<br>  users: [<br>     …<br>  ],<br>  total: 34<br>}</p><ol start="15"><li>在GET操作中始终接受limit和offset参数</li></ol><p>应该：<br>GET /shops?offset=5&amp;limit=5</p><p>这是因为它对于前端的分页是必要的。</p><ol start="16"><li>获取字段查询参数<br>返回的数据量也应该考虑在内。添加一个fields参数，只公开API中必需的字段。<br>例子：<br>只返回商店的名称，地址和联系方式。<br>GET /shops?fields=id,name,address,contact<br>在某些情况下，它还有助于减少响应大小。</li><li>不要在URL中通过认证令牌<br>错:GET /shops/123?token=some_kind_of_authenticaiton_token<br>相反，通过头部传递它们：<br>Authorization: Bearer xxxxxx, Extra yyyyy<br><code>此外，授权令牌应该是短暂有效期的</code>。</li></ol><ol start="18"><li>验证内容类型<br>服务器不应该假定内容类型。例如，如果你接受application/x-www-form-urlencoded，那么攻击者可以创建一个表单并触发一个简单的POST请求。</li></ol><p>因此，<code>始终验证内容类型</code>，如果你想使用默认的内容类型，请使用：<br>content-type: application/json</p><ol start="19"><li>CORS（跨源资源共享）<br>所有面向公共的API支持CORS（跨源资源共享）头部<br>考虑支持CORS允许的“*”来源，并通过有效的OAuth令牌强制授权<br><code>避免将用户凭证与原始验证相结合</code></li></ol><ol start="20"><li><p>安全<br>在所有端点、资源和服务上实施HTTPS（tls加密）。<br>强制并要求所有回调url、推送通知端点和webhooks使用HTTPS。</p></li><li><p>错误<br>客户端向服务发出无效或不正确的请求，或向服务传递无效或不正确的数据，服务拒绝该请求时，就会出现错误<br>当由于一个或多个服务错误而拒绝客户端请求时，<code>一定要返回4xx HTTP错误代码</code>。<br>考虑处理所有属性，然后<code>在单个响应中返回多个验证问题</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread.sleep</title>
      <link href="/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/Thread.sleep/"/>
      <url>/2022/02/09/Java/Java%20%E5%8D%9A%E5%AE%A2/Thread.sleep/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统的CPU竞争策略"><a href="#操作系统的CPU竞争策略" class="headerlink" title="操作系统的CPU竞争策略"></a>操作系统的CPU竞争策略</h2><ul><li>Unix系统使用的是时间片算法(时间分配策略)<br>时间片算法，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾</li><li>Windows则属于抢占式(抢占策略)<br>抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。<br>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他<h2 id="Thread-Sleep-0-的作用"><a href="#Thread-Sleep-0-的作用" class="headerlink" title="Thread.Sleep(0)的作用"></a>Thread.Sleep(0)的作用</h2>Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其它</title>
      <link href="/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%85%B6%E5%AE%83/"/>
      <url>/2022/02/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h3 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h3><p>面向对象：根据多个对象中共有的属性和行为抽取出一个类，类去创建对象，对象调用方法。<br>函数式编程思想：<br>不去关心是哪个对象去做的，不关心怎么做的，只需要一个输入值，然后得到一个结果。<br>在java中函数式编程思想的体现就是lambda表达式。<br>可以把lambda表达式当作匿名内部类的简化版格式。（底层其实有一些区别）</p><ul><li>当接口作为方法的参数时，我们实际要传入一个接口的实现类的对象，之前我们使用匿名内部类来简化这    个过程，但是匿名内部类的格式过于繁琐，不易阅读，所以，在jdk1.8时提供了lambda的语法在某些情况    下可以替代掉匿名内部类。</li></ul><p>2.使用前提<br>1）接口必须是函数式接口（接口中只能有一个抽象方法）。<br>2）要具有上下文推断。</p><h3 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h3><p><code>()-&gt;&#123;&#125;</code><br>()：接口中抽象方法的参数<br>-&gt;：没有特殊含义，就是一个传递作用,<br>{}：抽象方法的方法体的重写。</p><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ol><li>小括号中方法的参数类型可以省略。</li><li>当小括号中只有一个参数时，小括号可以省略。</li><li>当方法体中只有一条语句时，return，语句后的分号，{}都可以省略。</li></ol><h2 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h2><h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><ul><li><p>要排序的类必需实现一个接口：<code>Comparable</code>，重写该接口中的一个方法<code>compareTo</code>方法，在方法中给出排序的依据。</p><ul><li>升序:<code>return 类的属性 - compareTo方法的参数的属性</code></li><li>降序:<code>return compareTo方法的参数的属性 - 类的属性</code></li></ul></li><li><p>案例<br>``` Java<br>public class Student implements Comparable<Student>{<br>private int id;<br>private int score;</Student></p><p>//  重写此方法，在此方法中给出排序的依据<br>//  排序依据: 先按照成绩升序排序，，如果成绩相同，那么再按照编号降序排序<br>@Override<br>public int compareTo(Student o) {<br>  int a = this.score - o.score;<br>  //如果成绩相同<br>  if(a == 0){</p><pre><code>  a = o.id - this.id;</code></pre><p>  }<br>  return a;<br>}<br>}</p></li></ul><p>  import java.util.ArrayList;<br>  import java.util.Collections;<br>    /*<br>      自然排序<br>    */<br>  public class Run {<br>    public static void main(String[] args) {<br>      ArrayList<Student> list = new ArrayList&lt;&gt;();<br>      list.add(new Student(1,”a张三”,99));<br>      list.add(new Student(2,”c李四”,88));<br>      list.add(new Student(3,”d王五”,91));<br>      list.add(new Student(4,”d呵呵”,91));<br>      list.add(new Student(5,”b赵六”,93));<br>      //  Student实现了<code>Comparable</code>并重写<code>compareTo</code>方法才可以排序<br>      Collections.sort(list);<br>      System.out.println(list)<br>    }<br>  }</Student></p><pre><code>### 比较器排序- 在sort方法的第二个参数中给一个`Comparator`接口的实现类对象并让该对象重写`compare()`，该接口是一个比较器接口。（建议使用匿名内部类）  - 升序:`return 参数1 - 参数2`  - 降序:`return 参数2 - 参数1`- 案例  ``` Java  import java.util.ArrayList;  import java.util.Collections;  import java.util.Comparator;  /*    比较器排序  */  public class Run &#123;    public static void main(String[] args) &#123;      ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();      list.add(new Student(1,&quot;a张三&quot;,99));      list.add(new Student(2,&quot;c李四&quot;,88));      list.add(new Student(3,&quot;d王五&quot;,91));      list.add(new Student(4,&quot;d呵呵&quot;,91));      list.add(new Student(5,&quot;b赵六&quot;,93));      //  这里使用匿名内部类的方式来实现      Collections.sort(list, new Comparator&lt;Student&gt;() &#123;          //给出排序依据即可          //  升序:参数1 - 参数2          @Override          public int compare(Student o1, Student o2) &#123;              return o1.getScore() - o2.getScore();          &#125;      &#125;);      System.out.println(list);    &#125;  &#125;  ```### 两种排序方式的比较：- 自然排序：  - 类去实现Comparable接口，重写compareTo方法，在方法中给出排序依据，对类进行排序。- 比较器排序：  - 在sort方法中使用匿名内部类去使用，实现Comparator接口，重写compare方法，在方法中给出排序依据。对集合这个对象进行排序。- 比较器排序更加灵活一些。原因：有些类不方便修改时;比如：Integer## 循环性能分析多种循环方式，迭代器、for循环、forEach循环、lambda的forEach循环之间的性能问题...### ArrayList 当size很大（10万）时候for循环的性能最高，当size不是很大的时候Iterator和forEach效率就高 如何选择可参考- 如果是需要对下标进行处理操作对则选择for循环；- 对于ArrayList，从代码简洁讲优先考虑foreach，也不用去考虑下标越界对问题；- 对于实效性要求不高的，如I/O操作，可考虑lambda的forEach循环。### LinkedList 此时Iterator性能最佳，由于LinkedList的数据结构为链表结构，其中每个节点都记录了前驱和后继结点（头、尾除外）。 通过下标的方式获得值都会在链中检查一遍，直到得到我们想要的下标节点为止。 而Iterator和forEach则是始终循环子节点，直到尾节点为止。考虑到代码简洁，建议使用forEach。### HashMapIterator循环始终效率方面要占优，这里简单的提下HashMap的放值和取值原理。HashMap是一个散列桶，由数组和链表组成。每次put操作都会得到key的hash值，然后根据得到的hash值选择map数组对应的下标存入bucket（存入键对象和值对象）。而get操作时是根据键对象的hash值找map数组中对应的bucket，然后得到对应的值（当存在hash碰撞时，会以链表的形式加在相同hash值的后面，每次get的时候调用keys.equals（）得到该键与之对应的值）在之前的List对比中已经说明forEach循环底层也是由Iterator实现，而lambda的forEach循环是充分利用cup实现多线程的迭代。所以不难得出HashMap遍历Iterator效率更高一点，但是基于代码简洁性考虑也可采用forEach循环方式。## 路径绝对路径：以磁盘为起点的路径。相对路径：以项目的根目录为起点的路径。## 递归### 概述递归是指方法自己调用自己的现象。### 分类- 直接递归方法自己直接调用自己的现象。- 间接递归方法通过别的方法调用自己的现象。### 注意事项（*）1. 递归要有结束条件，否则栈内存溢出。2. 递归的次数不能过多，否则栈内存溢出。3. 构造方法不能递归。### 递归的过程：递推阶段回归阶段### 递归算法的编写思路什么情况下可以使用递归思想？如果一个大的问题可以被分解成若干个小问题，而且若干个小问题的解决思路    差不多，那么可以考虑使用递归思想。    怎么编写递归？1. 编写递归结束条件。2. 递归调用时让参数向结束条件靠拢。3. 找到本次递归与上一次递归之间的关系，描述这个关系。### 文件递归案例#### 递归打印多级目录打印出abc目录下的所有内容：如果子目录中有内容，也需要打印出来思路：1）获取出abc中的所有内容，存储到一个文件数组中2）遍历数组，判断每一个元素是文件还是目录文件直接打印即可。目录获取出该目录中的所有内容，存储到一个文件数组中。再次进行2    步骤即可。``` Java/*  递归打印多级目录 */public class Test1 &#123;  public static void main(String[] args) &#123;      File file = new File(&quot;D:\\abc&quot;);      //调用打印目录的方法      show(file);  &#125;  //打印目录的方法  public static void show(File file)&#123;      //取出该目录下的内容，存储到数组中      File[] files = file.listFiles();      //遍历该数组，判断是文件还是目录      for (File file1 : files) &#123;          if(file1.isDirectory())&#123;//目录              System.out.println(file1);    //打印出目录名字              show(file1);          &#125;else&#123;  //是文件              System.out.println(file1);          &#125;      &#125;  &#125;&#125;</code></pre><h4 id="文件搜索案例"><a href="#文件搜索案例" class="headerlink" title="文件搜索案例"></a>文件搜索案例</h4><p>搜索出abc目录下所有.mp3结尾的文件。打印出来。<br>思路：<br>1）获取出abc中的所有内容，存储到一个文件数组中<br>2）遍历数组，判断每一个元素是文件还是目录<br>文件<br>判断文件名是否以.mp3结尾，是直接打印即可。<br>目录<br>获取出该目录中的所有内容，存储到一个文件数组中。再次进行2    步骤即可。</p><pre class=" language-Java"><code class="language-Java">public class Test2 &#123;    public static void main(String[] args) &#123;        File file = new File("D:\\abc");        sou(file);    &#125;    //搜索功能：搜索以.mp3结尾的文件    public static void sou(File file) &#123;        File[] files = file.listFiles();        for (File file1 : files) &#123;            if(file1.isDirectory())&#123;                sou(file1);            &#125;else&#123;//文件                if(file1.getName().endsWith(".txt"))&#123;                    System.out.println(file1);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h4><p>FileFilter：<br>文件过滤器的一个接口，该接口中有一个方法，可以过滤掉不需要的文件。<br>要求：返回值：true，表示保留<br>false：表示过滤。</p><pre class=" language-Java"><code class="language-Java">public class Test3 &#123;    public static void main(String[] args) &#123;        File file = new File("D:\\abc");        sou(file);    &#125;    //搜索功能：搜索以.mp3结尾的文件    public static void sou(File file) &#123;        File[] files = file.listFiles(new FileFilter() &#123;            @Override            public boolean accept(File pathname) &#123;                //保留目录和以.mp3结尾的文件                return pathname.isDirectory() || pathname.getName().endsWith(".mp3");            &#125;        &#125;);        for (File file1 : files) &#123;            if(file1.isDirectory())&#123;    //如果是目录                sou(file1);            &#125;else&#123;                //如果是文件                System.out.println(file1);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><pre class=" language-Java"><code class="language-Java">/*    斐波那契数列：        1    1    2     3      5      8       13       21       34...        1    2    3     4      5      6        7        8       9            除了前两个数字之外，其它的数字都是由上一个数字和上上一个数字的和组成的。        1.编写递归结束条件。        2.递归调用时让参数向结束条件靠拢。        3.找到本次递归与上一次递归之间的关系，描述这个关系。 */public class Test5 &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println("请输入一个编号：");        int n = sc.nextInt();        System.out.println("结果为：" + fei(n));    &#125;    //求出编号对应的费事数列    public static int fei(int n)&#123;        //结束条件        if(n == 1 || n == 2)&#123;            return 1;        &#125;        return fei(n - 1) + fei(n - 2);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2022/01/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2022/01/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程:在内存中运行的程序称为进程;一个进程可以包含多个线程。进程一直运行，直到所有的非守护线程都结束运行后才能结束</li><li>线程:进程的一个执行单元,没有自己的独立的内存空间;它必须是进程的一部分</li><li>多线程：多个线程同时执行，我们称为多线程程序。<h2 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h2></li><li>多线程能高效率的运行程序,达到充分利用 CPU 的目的</li></ul><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发：在同一个时间段内同时运行。</li><li>并行：在同一个时间点同时运行。<br>（并发是并行的假象）</li></ul><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li>分时调度：<br>多个线程轮流使用cpu的执行权。</li><li>抢占式调度：<br>多个线程之间会相互抢夺cpu的执行权。</li><li>优先级：<br>线程的优先级越高，说明抢夺cpu的概率越高。<br>java是抢占式调度</li></ul><p><strong><font color="red">main方法是Java的主线程</font></strong></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><ul><li>方式一：<ol><li>定义一个类继承Thread类，重写run方法，run方法中就是线程要执行的代码。</li><li>创建该类的对象，调用start方法开启线程</li></ol></li><li>方式二：<ol><li>定义一个类实现Runnable接口，重写run方法，run方法中就是线程要执行的代码。</li><li>创建Thread类的对象，把Runnable接口的实现类对象传递过来作为线程任务，调用start方法开启线程</li></ol></li><li>方式二使用匿名内部类:<br>Thread类的构造方法中需要一个线程任务（Runnable接口），接口作为参数，可以使用匿名内部类去代表接口的实现类的对象。</li><li>方式二的优势：<ol><li>可以避免java单继承的局限性。</li><li>让线程的创建和线程任务相分离。解耦。</li><li>线程池只能接收第二种方式创建的线程。</li></ol></li><li>例:<ol><li>方式一<pre class=" language-Java"><code class="language-Java">public class MyThread extends Thread &#123;//设置线程名称public MyThread(String name)&#123;   super(name);&#125;@Overridepublic void run() &#123;   for (int i = 0; i < 200; i++) &#123;     //  获取线程名称     System.out.println("线程名称为："+getName() + "-"+ i);     try &#123;         //  休眠1秒         Thread.sleep(1000);     &#125; catch (InterruptedException e) &#123;         e.printStackTrace();     &#125;   &#125;&#125;&#125;</code></pre></li><li>方式二<pre class=" language-Java"><code class="language-Java">//  线程任务类public class MyRunnable implements Runnable &#123; @Override public void run() &#123;     for (int i = 0; i < 200; i++) &#123;         System.out.println("刘亦菲..." + i);     &#125; &#125;&#125;//  运行类public class Test1 &#123;public static void main(String[] args) &#123;   //创建一个线程任务   MyRunnable mr  = new MyRunnable();   //创建一个线程   Thread tr = new Thread(mr);   //开启线程   tr.start();&#125;&#125;</code></pre></li><li>方式二匿名内部类<pre class=" language-Java"><code class="language-Java">public class Thread2 &#123; public static void main(String[] args) &#123;     //创建一个线程对象，参数中需要一个Runnable接口     Thread tr = new Thread(new Runnable() &#123;         @Override         public void run() &#123;             System.out.println("这是一个新的线程...");         &#125;     &#125;);     tr.start(); &#125;&#125;</code></pre><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3>java提供的一个线程的根类</li></ol></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Thread()        //创建一个线程对象<br>Thread(String name)        //创建一个线程对象，可以指定线程名称<br>Thread(Runnable )<br>Thread(Runnable,String name )</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>String getName()</code>获取线程的名称<br><code>void start()</code>开启线程，在新线程内部会调用run方法<br><code>void run()</code>线程要执行的代码<br><code>static void sleep(long millis)</code>线程休眠..毫秒<br><code>static Thread currentThread()</code>获取当前线程的引用。可以获取主线程的名称。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>多个线程在同时访问同一块资源时，会引发线程安全问题。</p><h3 id="线程安全问题解决方案"><a href="#线程安全问题解决方案" class="headerlink" title="线程安全问题解决方案"></a>线程安全问题解决方案</h3><h4 id="同步锁对象"><a href="#同步锁对象" class="headerlink" title="同步锁对象"></a>同步锁对象</h4><p>同步锁只是一个概念,可以想象为在对象上标记了一个锁.<br>    1. 锁对象 可以是任意类型。<br>    2. 多个线程对象 要使用同一把锁。</p><blockquote><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等待</p></blockquote><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul><li><p>用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><pre class=" language-Java"><code class="language-Java">public class RunnableThread implements Runnable &#123;  private static int ticket = 100;  private static Object lock = new Object();  /**   * 执行卖票操作   */  @Override  public void run() &#123;      //每个窗口卖票的操作 //窗口 永远开启      while (true) &#123;          //  需要同步操作的代码:          synchronized (lock) &#123;              if (ticket <= 0) break;              //有票 可以卖 //出票操作 //使用sleep模拟一下出票时间              try &#123;                  Thread.sleep(100);              &#125; catch (InterruptedException e) &#123;                  // TODO Auto‐generated catch block                  e.printStackTrace();              &#125;              //获取当前线程对象的名字              String name = Thread.currentThread().getName();              System.out.println(name + "正在卖:" + ticket--);          &#125;      &#125;  &#125;&#125;</code></pre></li></ul><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>修饰符 synchronized  返回值类型 方法名(){}<br>同步方法的锁对象是this(当前对象);可省略<br>静态同步方法的锁对象是class对象（.class字节码文件）;可省略</p><pre class=" language-Java"><code class="language-Java">public class RunnableThread implements Runnable &#123;    private static int ticket = 100;    @Override    public void run() &#123;        developer();    &#125;    //  同步方法;这里的锁对象是this(当前对象)    public synchronized void developer() &#123;        while (true) &#123;            if (ticket <= 0) break;            //  出票操作 使用sleep模拟一下出票时间            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            //获取当前线程对象的名字            String name = Thread.currentThread().getName();            System.out.println(name + "正在卖:" + ticket--);        &#125;    &#125;&#125;</code></pre><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>包:<code>java.util.concurrent.locks.Lock</code><br>Lock锁也称同步锁;是jdk1.5出的新特性;提供了比synchronized代码块和synchronized方法更广泛的锁定操作, 同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象</p><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法:"></a>常用方法:</h5><ul><li>void lock()          加锁</li><li>void unlock()         释放锁<pre class=" language-Java"><code class="language-Java">public class RunnableThread implements Runnable &#123;private static int ticket = 100;private static Lock lock = new ReentrantLock();@Overridepublic void run() &#123;   //每个窗口卖票的操作 //窗口 永远开启   while (true) &#123;       //  加锁       lock.lock();       if (ticket <= 0) break;       //有票 可以卖 //出票操作 //使用sleep模拟一下出票时间       try &#123;           Thread.sleep(100);       &#125; catch (InterruptedException e) &#123;           // TODO Auto‐generated catch block           e.printStackTrace();       &#125;       //获取当前线程对象的名字       String name = Thread.currentThread().getName();       System.out.println(name + "正在卖:" + ticket--);   &#125;   //  释放锁   lock.unlock();&#125;&#125;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3></li></ul><pre class=" language-Java"><code class="language-Java">public class MyPiao implements Runnable &#123;    private int piao = 100;     //代表总票数    @Override    public void run() &#123;        for(;;)&#123;            //判断，只要总票数>0，可以卖票            if(piao > 0)&#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;       //   1   2   3                System.out.println(Thread.currentThread().getName() + "正在卖第"+ piao +"张票");                piao--;            &#125;        &#125;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        //创建线程任务        MyPiao mp = new MyPiao();        Thread tr1 = new Thread(mp,"窗口一");        Thread tr2 = new Thread(mp,"窗口二");        Thread tr3 = new Thread(mp,"窗口三");        //开启线程        tr1.start();        tr2.start();        tr3.start();    &#125;&#125;// 同时访问同一块资源时，会引发的安全问题  //1. 卖重复票  //2. 卖不存在的票</code></pre><p>解决方案1 同步代码块</p><pre class=" language-Java"><code class="language-Java">public class MyPiao implements Runnable &#123;    private int piao = 100;     //代表总票数    private Object object = new Object();    @Override    public void run() &#123;        for(;;)&#123;            //同步代码块  接收任意对象作为锁            synchronized (object)&#123;                //判断，只要总票数>0，可以卖票                if(piao > 0)&#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;       //   1   2   3                    System.out.println(Thread.currentThread().getName() + "正在卖第"+ piao +"张票");                    piao--;                &#125;            &#125;        &#125;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        //创建线程任务        MyPiao mp = new MyPiao();        Thread tr1 = new Thread(mp,"窗口一");        Thread tr2 = new Thread(mp,"窗口二");        Thread tr3 = new Thread(mp,"窗口三");        //开启线程        tr1.start();        tr2.start();        tr3.start();    &#125;&#125;</code></pre><p>解决方案2 同步方法</p><pre class=" language-Java"><code class="language-Java">public class MyPiao implements Runnable &#123;    private  int piao = 100;     //代表总票数    @Override    public void run() &#123;        for(;;)&#123;            //判断，只要总票数>0，可以卖票            fun();        &#125;    &#125;    //同步方法    public  synchronized void fun()&#123;        if(piao > 0)&#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;       //   1   2   3            System.out.println(Thread.currentThread().getName() + "正在卖第"+ piao-- +"张票");        &#125;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        //创建线程任务        MyPiao mp = new MyPiao();        Thread tr1 = new Thread(mp,"窗口一");        Thread tr2 = new Thread(mp,"窗口二");        Thread tr3 = new Thread(mp,"窗口三");        //开启线程        tr1.start();        tr2.start();        tr3.start();    &#125;&#125;</code></pre><p>解决方案3 lock锁</p><pre class=" language-Java"><code class="language-Java">public class MyPiao implements Runnable &#123;    private int piao = 100;     //代表总票数    Lock lock = new ReentrantLock();        //创建Lock锁对象    @Override    public void run() &#123;        for(;;)&#123;            lock.lock();        //加锁            //判断，只要总票数>0，可以卖票            if(piao > 0)&#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;       //   1   2   3                System.out.println(Thread.currentThread().getName() + "正在卖第"+ piao +"张票");                piao--;            &#125;            lock.unlock();      //释放锁        &#125;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        //创建线程任务        MyPiao mp = new MyPiao();        Thread tr1 = new Thread(mp,"窗口一");        Thread tr2 = new Thread(mp,"窗口二");        Thread tr3 = new Thread(mp,"窗口三");        //开启线程        tr1.start();        tr2.start();        tr3.start();    &#125;&#125;</code></pre><h2 id="线程的生命周期-线程状态"><a href="#线程的生命周期-线程状态" class="headerlink" title="线程的生命周期(线程状态)"></a>线程的生命周期(线程状态)</h2><p><img src="/2022/01/10/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread.jpg"></p><ul><li><p>新建状态:<br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象处于新建状态</p></li><li><p>就绪状态:<br>线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p></li><li><p>运行状态:<br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。<br>运行状态的线程，可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态:<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p></li></ul><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态</p><ul><li>死亡状态:<br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。<blockquote><p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p></blockquote></li></ul><h2 id="等待唤醒机制（线程通信）"><a href="#等待唤醒机制（线程通信）" class="headerlink" title="等待唤醒机制（线程通信）"></a>等待唤醒机制（线程通信）</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>等待唤醒机制，又叫做线程之间的通信。</li><li>很多情况下，我们是需要让多个线程配合起来工作的，这就是线程间的通信。<h3 id="需要的方法"><a href="#需要的方法" class="headerlink" title="需要的方法"></a>需要的方法</h3>wait方法与notify方法必须要由同一个锁对象调用;wait方法与notify方法必须要在同步代码块或者是同步函数中使用<br>wait()：可以使线程处于无限等待状态，必须由别的线程去唤醒。<br>notify()：可以唤醒处于无限等待状态的线程。<br>notifyAll()：唤醒所有处于无限等待状态的线程。<br>这三个方法都属于Object类，必须由锁对象去调用。一般都使用在同步代码块或者同步方法中。<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3>``` Java<br>package cn.dy.test7;</li></ul><p>/**</p><ul><li><p>包子实体类：</p></li><li><pre><code> 属性：     皮，馅儿，状态</code></pre></li><li><p>/<br>public class BaoZi {<br>  private String pi;<br>  private String xian;<br>  private boolean flag = false;</p><p>  @Override<br>  public String toString() {</p><pre><code>  return &quot;BaoZi&#123;&quot; +          &quot;pi=&#39;&quot; + pi + &#39;\&#39;&#39; +          &quot;, xian=&#39;&quot; + xian + &#39;\&#39;&#39; +          &quot;, flag=&quot; + flag +          &#39;&#125;&#39;;</code></pre><p>  }</p><p>  public BaoZi() {<br>  }</p><p>  public BaoZi(String pi, String xian, boolean flag) {</p><pre><code>  this.pi = pi;  this.xian = xian;  this.flag = flag;</code></pre><p>  }</p><p>  public String getPi() {</p><pre><code>  return pi;</code></pre><p>  }</p><p>  public void setPi(String pi) {</p><pre><code>  this.pi = pi;</code></pre><p>  }</p><p>  public String getXian() {</p><pre><code>  return xian;</code></pre><p>  }</p><p>  public void setXian(String xian) {</p><pre><code>  this.xian = xian;</code></pre><p>  }</p><p>  public boolean isFlag() {</p><pre><code>  return flag;</code></pre><p>  }</p><p>  public void setFlag(boolean flag) {</p><pre><code>  this.flag = flag;</code></pre><p>  }<br>}<br>package cn.dy.test7;<br>/*<br>  包子铺线程：</p><pre><code>  判断包子有没有：      有：自己等待，等待吃货线程去吃包子。      没有：      生产包子。      把包子的状态改为有包子。      唤醒吃货线程。</code></pre></li><li><p>/<br>public class BaoZiPu extends Thread {<br>  //锁对象<br>  private BaoZi bz ;</p></li></ul><pre><code>public BaoZiPu(BaoZi bz) &#123;    this.bz = bz;&#125;public BaoZiPu( BaoZi bz,String name) &#123;    super(name);    this.bz = bz;&#125;@Overridepublic void run() &#123;    int count = 0;    for(;;)&#123;        synchronized (bz)&#123;            //如果有包子            if(bz.isFlag())&#123;                try &#123;                    bz.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //如果代码走到这里,说明没有包子            System.out.println(getName() + &quot;：正在做包子...&quot;);            if(count % 2 == 0)&#123;                bz.setPi(&quot;薄&quot;);                bz.setXian(&quot;韭菜鸡蛋&quot;);            &#125;else&#123;                bz.setPi(&quot;厚&quot;);                bz.setXian(&quot;猪肉大葱&quot;);            &#125;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(getName() + &quot;：包子做好了,吃货来吃吧&quot;);            count++;            //把包子的状态改为true            bz.setFlag(true);            //获取吃货线程            bz.notify();        &#125;    &#125;&#125;</code></pre><p>}<br>package cn.dy.test7;</p><p>/**</p><ul><li><p>吃货线程</p></li><li><p>/<br>public class ChiHuo extends Thread {</p><p>  private BaoZi bz;</p></li></ul><pre><code>public ChiHuo(BaoZi bz) &#123;    this.bz = bz;&#125;public ChiHuo(BaoZi bz,String name) &#123;    super(name);    this.bz = bz;&#125;@Overridepublic void run() &#123;    for(;;)&#123;        synchronized (bz)&#123;            //判断包子的状态,没有包子，就等待            if(!bz.isFlag())&#123;                try &#123;                    bz.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //说明有包子,可以吃包子            System.out.println(getName() + &quot;：正在吃&quot;+bz.getPi()+&quot;皮&quot;+bz.getXian()+&quot;馅儿包子...&quot;);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(getName() + &quot;：包子吃完了，赶快去给我生产..&quot;);            //把包子的状态改为没有            bz.setFlag(false);            //唤醒包子铺            bz.notify();        &#125;    &#125;&#125;</code></pre><p>}<br>package cn.dy.test7;</p><p>public class Test1 {<br>    public static void main(String[] args) {<br>        BaoZi bz = new BaoZi();<br>        //创建包子铺线程<br>        BaoZiPu bzp = new BaoZiPu(bz,”包子铺”);<br>        ChiHuo chi = new ChiHuo(bz,”吃货”);</p><pre><code>    //开启两个线程    bzp.start();    chi.start();&#125;</code></pre><p>}</p><p>```</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>其实就是一个装线程的一个容器。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1）节省创建线程，销毁线程的时间。<br>2）当任务到达时，可以直接从线程池中取线程来使用。<br>3）管理线程，使程序不会因为线程过多而崩溃。</p><h3 id="相关类和接口"><a href="#相关类和接口" class="headerlink" title="相关类和接口"></a>相关类和接口</h3><p>线程池顶级的接口：<code>Executor</code>是一个执行线程的工具<br>线程池接口：<code>ExecutorService</code><br>线程的一个工厂类：<code>Executors</code> 提供了一些静态工厂，生成一些常用的线程池<br>方法：<br>static ExecutorService newFixedThreadPool(int nThreads)   线程池中线程的数量</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/07/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Web%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/01/07/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Web%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/07/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/01/07/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Servlet文件上传案例</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>upload.jsp</p><pre class=" language-jsp"><code class="language-jsp"><%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"    "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>文件上传实例 - 菜鸟教程</title></head><body><h1>文件上传实例 - 菜鸟教程</h1><form method="post" action="/TomcatTest/UploadServlet" enctype="multipart/form-data">    选择一个文件:    <input type="file" name="uploadFile" />    <br/><br/>    <input type="submit" value="上传" /></form></body></html></code></pre><p>UploadServlet<br>下面的实例依赖于 FileUpload，所以一定要确保在您的 classpath 中有最新版本的 commons-fileupload.x.x.jar 文件。可以从 <a href="http://commons.apache.org/proper/commons-fileupload/">http://commons.apache.org/proper/commons-fileupload/</a> 下载。<br>FileUpload 依赖于 Commons IO，所以一定要确保在您的 classpath 中有最新版本的 commons-io-x.x.jar 文件。可以从 <a href="http://commons.apache.org/proper/commons-io/">http://commons.apache.org/proper/commons-io/</a> 下载。</p><pre class=" language-Java"><code class="language-Java">package com.runoob.test;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.List; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload; /** * Servlet implementation class UploadServlet */@WebServlet("/UploadServlet")public class UploadServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;         // 上传文件存储目录    private static final String UPLOAD_DIRECTORY = "upload";     // 上传配置    private static final int MEMORY_THRESHOLD   = 1024 * 1024 * 3;  // 3MB    private static final int MAX_FILE_SIZE      = 1024 * 1024 * 40; // 40MB    private static final int MAX_REQUEST_SIZE   = 1024 * 1024 * 50; // 50MB     /**     * 上传数据及保存文件     */    protected void doPost(HttpServletRequest request,        HttpServletResponse response) throws ServletException, IOException &#123;        // 检测是否为多媒体上传        if (!ServletFileUpload.isMultipartContent(request)) &#123;            // 如果不是则停止            PrintWriter writer = response.getWriter();            writer.println("Error: 表单必须包含 enctype=multipart/form-data");            writer.flush();            return;        &#125;         // 配置上传参数        DiskFileItemFactory factory = new DiskFileItemFactory();        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中        factory.setSizeThreshold(MEMORY_THRESHOLD);        // 设置临时存储目录        factory.setRepository(new File(System.getProperty("java.io.tmpdir")));         ServletFileUpload upload = new ServletFileUpload(factory);                 // 设置最大文件上传值        upload.setFileSizeMax(MAX_FILE_SIZE);                 // 设置最大请求值 (包含文件和表单数据)        upload.setSizeMax(MAX_REQUEST_SIZE);        // 中文处理        upload.setHeaderEncoding("UTF-8");         // 构造临时路径来存储上传的文件        // 这个路径相对当前应用的目录        String uploadPath = request.getServletContext().getRealPath("./") + File.separator + UPLOAD_DIRECTORY;                        // 如果目录不存在则创建        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) &#123;            uploadDir.mkdir();        &#125;         try &#123;            // 解析请求的内容提取文件数据            @SuppressWarnings("unchecked")            List<FileItem> formItems = upload.parseRequest(request);             if (formItems != null && formItems.size() > 0) &#123;                // 迭代表单数据                for (FileItem item : formItems) &#123;                    // 处理不在表单中的字段                    if (!item.isFormField()) &#123;                        String fileName = new File(item.getName()).getName();                        String filePath = uploadPath + File.separator + fileName;                        File storeFile = new File(filePath);                        // 在控制台输出文件的上传路径                        System.out.println(filePath);                        // 保存文件到硬盘                        item.write(storeFile);                        request.setAttribute("message",                            "文件上传成功!");                    &#125;                &#125;            &#125;        &#125; catch (Exception ex) &#123;            request.setAttribute("message",                    "错误信息: " + ex.getMessage());        &#125;        // 跳转到 message.jsp        request.getServletContext().getRequestDispatcher("/message.jsp").forward(                request, response);    &#125;&#125;</code></pre><p>message.jsp</p><pre class=" language-jsp"><code class="language-jsp"><%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"    "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>文件上传结果</title></head><body>    <center>        <h2>$&#123;message&#125;</h2>    </center></body></html></code></pre><p>web.xml配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>web</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span>    <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WebApp_ID<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>UploadServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>UploadServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.runoob.test.UploadServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>UploadServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/TomcatTest/UploadServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound Eureka注册中心</title>
      <link href="/2022/01/03/Java/SpringClound/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2022/01/03/Java/SpringClound/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。<br>服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。<br>同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。<br>这就实现了服务的自动注册、发现、状态监控。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li><li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li><li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li></ul><h2 id="EnableEurekaServer"><a href="#EnableEurekaServer" class="headerlink" title="@EnableEurekaServer"></a>@EnableEurekaServer</h2><p>声明当前springboot应用是一个eureka服务中心<br>位置：<br>  主入口Application.java类上</p><h2 id="Eureka架构中的三个核心角色："><a href="#Eureka架构中的三个核心角色：" class="headerlink" title="Eureka架构中的三个核心角色："></a>Eureka架构中的三个核心角色：</h2><ul><li><p>服务注册中心<br>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的doyens-eureka。</p></li><li><p>服务提供者<br>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的doyens_service_provider。</p></li><li><p>服务消费者<br>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的doyens_service_consumer</p></li></ul><h2 id="高可用的Eureka-Server"><a href="#高可用的Eureka-Server" class="headerlink" title="高可用的Eureka Server"></a>高可用的Eureka Server</h2><p>EurekaServer也可以是一个集群，形成高可用的Eureka中心</p><p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群<br>假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把eureka启动两次即可</p><pre class=" language-yml"><code class="language-yml">server:  port: 10086 # 端口  假设要运行两个EurekaServer的集群:下次这里改为10087spring:  application:    name: eureka-server # 应用名称，会在Eureka中显示eureka:  client:    service-url: # EurekaServer的地址 假设要运行两个EurekaServer的集群:下次这里改为10086      defaultZone: http://127.0.0.1:10087/eureka</code></pre><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作</p><blockquote><p>服务注册</p></blockquote><p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否为true，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。</p><ul><li>第一层Map的Key就是服务id，一般是配置中的<code>spring.application.name</code>属性</li><li>第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：<code>locahost:service-provider:8081</code></li><li>值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。</li></ul><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><p>有两个重要参数可以修改服务续约的行为：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">90</span>    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">30</span></code></pre><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p><p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">10 </span><span class="token comment" spellcheck="true"># 10秒即过期</span>    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">5 </span><span class="token comment" spellcheck="true"># 5秒一次心跳</span></code></pre><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><blockquote><p>获取服务列表</p></blockquote><p>当服务消费者启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">registry-fetch-interval-seconds</span><span class="token punctuation">:</span> <span class="token number">5</span></code></pre><p>生产环境中，我们不需要修改这个值。</p><p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p><h2 id="失效剔除和自我保护"><a href="#失效剔除和自我保护" class="headerlink" title="失效剔除和自我保护"></a>失效剔除和自我保护</h2><blockquote><p>服务下线</p></blockquote><p>当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p><blockquote><p>失效剔除</p></blockquote><p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p><p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生产环境不要修改。</p><p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒</p><p><img src="/2022/01/03/Java/SpringClound/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/1528696142799.png" alt="1528696142799"></p><blockquote><p>自我保护</p></blockquote><p>我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src="/assets/1525618396076.png" alt="1525618396076"></p><p>这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p><p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（doyens-eureka）</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 关闭自我保护模式（缺省为打开）</span>    <span class="token key atrule">eviction-interval-timer-in-ms</span><span class="token punctuation">:</span> <span class="token number">1000 </span><span class="token comment" spellcheck="true"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound Feign伪装</title>
      <link href="/2022/01/03/Java/SpringClound/Feign%E4%BC%AA%E8%A3%85/"/>
      <url>/2022/01/03/Java/SpringClound/Feign%E4%BC%AA%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对代码再次优化<br>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作<br>项目主页：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a><br><img src="/2022/01/03/Java/SpringClound/Feign%E4%BC%AA%E8%A3%85/1525652009416.png" alt="1525652009416"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="Feign的客户端"><a href="#Feign的客户端" class="headerlink" title="Feign的客户端"></a>Feign的客户端</h2><pre class=" language-Java"><code class="language-Java">package com.fengyuan.consumer.client;@FeignClient("provider")  //引入要调用的微服务的名称public interface UserFeignClient &#123;    @GetMapping("/user/&#123;id&#125;")    User queryUserById(@PathVariable("id") Long id);&#125;</code></pre><ul><li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li></ul><h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><p>启动类添加<code>@EnableFeignClients</code> // 开启Feign功能</p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>Feign中自动集成了Ribbon负载均衡,集成自动配置,集成hystrix熔断器</p><h3 id="集成Hystix支持"><a href="#集成Hystix支持" class="headerlink" title="集成Hystix支持"></a>集成Hystix支持</h3><p>配置中开启熔断功能<br>application.yml</p><pre class=" language-yml"><code class="language-yml">feign:  hystrix:    enabled: true # 开启Feign的熔断功能</code></pre><p>实现编写的UserFeignClient，作为fallback的处理类;定义UserFeignClientFallback.java</p><pre class=" language-Java"><code class="language-Java">package cn.dy.feign.impl;import cn.dy.entity.User;import cn.dy.feign.UserFeignClient;import org.springframework.stereotype.Component;@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123;    @Override    public User queryById(Long id) &#123;        User user = new User();        user.setUserName("服务器繁忙请稍后再试!!!");        return user;    &#125;&#125;</code></pre><p>修改UserFeginClient</p><pre class=" language-Java"><code class="language-Java">import cn.dy.entity.User;import cn.dy.feign.impl.UserFeignClientFallback;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient( value = "provider",fallback = UserFeignClientFallback.class)    //引入要调用的微服务的名称public interface UserFeignClient &#123;    @GetMapping("/user/&#123;id&#125;")    User queryById(@PathVariable("id") Long id);&#125;</code></pre><h3 id="集成Ribbon负载均衡支持"><a href="#集成Ribbon负载均衡支持" class="headerlink" title="集成Ribbon负载均衡支持"></a>集成Ribbon负载均衡支持</h3><h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5.请求压缩(了解)"></a>2.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗，有时候我们会在氢气数据比较大的时候会用到。通过下面的参数即可开启请求与响应的压缩功能：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">compression</span><span class="token punctuation">:</span>    <span class="token key atrule">request</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启请求压缩</span>    <span class="token key atrule">response</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启响应压缩</span></code></pre><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">compression</span><span class="token punctuation">:</span>    <span class="token key atrule">request</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启请求压缩</span>      <span class="token key atrule">mime-types</span><span class="token punctuation">:</span> text/html<span class="token punctuation">,</span>application/xml<span class="token punctuation">,</span>application/json <span class="token comment" spellcheck="true"># 设置压缩的数据类型</span>      <span class="token key atrule">min-request-size</span><span class="token punctuation">:</span> <span class="token number">2048 </span><span class="token comment" spellcheck="true"># 设置触发压缩的大小下限</span></code></pre><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="2-6-日志级别-了解"><a href="#2-6-日志级别-了解" class="headerlink" title="2.6.日志级别(了解)"></a>2.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置com.fengyuan包下的日志级别都为debug</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">level</span><span class="token punctuation">:</span>    <span class="token key atrule">com.fengyuan</span><span class="token punctuation">:</span> debug</code></pre><p>2）编写配置类，定义日志级别</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    Logger<span class="token punctuation">.</span>Level <span class="token function">feignLoggerLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>FULL<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><p>​    <img src="/2022/01/03/Java/SpringClound/Feign%E4%BC%AA%E8%A3%85/1525674373507.png" alt="1525674373507"></p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>3）在FeignClient中指定配置类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user-service"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> UserFeignClientFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> FeignConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserFeignClient</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/&amp;#123;id&amp;#125;"</span><span class="token punctuation">)</span>     User <span class="token function">queryUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>4）重启项目，即可看到每次访问的日志：</p><p><img src="/2022/01/03/Java/SpringClound/Feign%E4%BC%AA%E8%A3%85/1525674544569.png" alt="1525674544569"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanUtils包</title>
      <link href="/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20BeanUtils%E5%8C%85/"/>
      <url>/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20BeanUtils%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>apache commons子项目中的软件包</li><li>主要目的是利用反射机制对 JavaBean 的属性进行处理</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>简化数据的封装</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>类必须是被public修饰</li><li>必须提供无参构造</li><li>成员变量必须使用private修饰</li><li>提供set和get方法</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><code>void populate(Object obj,Map map)</code>    map集合中的内容封装到obj对象中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dbutils包</title>
      <link href="/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20Dbutils%E5%8C%85/"/>
      <url>/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20Dbutils%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DBUtils简化了JDBC的开发步骤，使得我们可以用更少量的代码实现连接数据库的功能</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>QueryRunner中提供对sql语句操作的API.<br>ResultSetHandler接口，用于定义select操作后，封装结果集.<br>DbUtils类是一个工具类，定义了关闭资源与事务处理的方法</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>简化数据的封装</li></ul><h2 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p> <code>public QueryRunner(DataSource ds)</code> :传入参数为连接池</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>update(String sql, Object… params)</code> 执行insert update delete操作<br><code>query(String sql, ResultSetHandler rsh, Object… params)</code> 执行 select操作</p><h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><p><img src="/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20Dbutils%E5%8C%85/ResultSetHandler%E7%BB%93%E6%9E%9C%E9%9B%86%E5%A4%84%E7%90%86%E7%B1%BB.jpg"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">public class EmpDaoImpl implements EmpDao &#123;    private QueryRunner queryRunner = new QueryRunner(JdbcUtil.getDataSource());    //  建表    @Override    public int createTable() &#123;        String sql = "CREATE  TABLE  IF NOT EXISTS medicine (kid INT UNSIGNED AUTO_INCREMENT COMMENT '科室编号',kname VARCHAR(15) NOT NULL COMMENT '科室名称',PRIMARY KEY(kid))ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT = '科室表'";        try &#123;            return queryRunner.update(sql);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return 0;    &#125;    //  添加    @Override    public int addEmp(Emp emp) &#123;        try &#123;            return queryRunner.update("insert into emp (id,ename,job_id,mgr,joindate,salary,bonus,dept_id) values (?,?,?,?,?,?,?,?)",emp.getId(),emp.getEname(),emp.getJobId(),emp.getMgr(),emp.getJoinDate(),emp.getSalary(),emp.getBonus(),emp.getDeptId());        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return 0;    &#125;    //  修改    @Override    public int updateEmp(Emp emp) &#123;        try &#123;            return queryRunner.update("update emp set ename=?,job_id=?,mgr=?,joindate=?,salary=?,bonus=?,dept_id=? where id = ?",emp.getEname(),emp.getJobId(),emp.getMgr(),emp.getJoinDate(),emp.getSalary(),emp.getBonus(),emp.getDeptId(),emp.getId());        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return 0;    &#125;    //  删除    @Override    public int deleteEmp(int id) &#123;        try &#123;            return queryRunner.update("delete from emp where id = ?",id);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return 0;    &#125;    //  查询单个    @Override    public Emp selectEmp(int id) &#123;        try &#123;            return queryRunner.query("select id,ename,job_id,mgr,joindate,salary,bonus,dept_id deptId from emp where id = ?",new BeanHandler<>(Emp.class),id);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    //  查询全部    @Override    public List<Emp> selectAllEmp() &#123;        try &#123;            return  queryRunner.query("select id,ename,job_id,mgr,joindate,salary,bonus,dept_id deptId from emp ",new BeanListHandler<>(Emp.class));        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    //  查询个数    @Override    public int selectCount(String name) &#123;        try &#123;            Object obj = queryRunner.query("select count(1)  from emp where ename like ? ", new ScalarHandler(),"%"+name+"%");            return Integer.parseInt(String.valueOf(obj));        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return 0;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求</title>
      <link href="/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20HTTP%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/01/03/Java/Java%20%E5%B8%B8%E7%94%A8jar%E5%8C%85/Java%20HTTP%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>HttpClient</code>是Apache Jakarta Common下的子项目<br>用来提供HTTP协议的客户端编程工具包<br>支持HTTP协议最新的版本和建议</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载地址: <a href="http://hc.apache.org/downloads.cgi">http://hc.apache.org/downloads.cgi</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>基于标准、纯净的java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）</li><li>支持HTTPS协议</li><li>通过Http代理建立透明的连接</li><li>利用CONNECT方法通过Http代理建立隧道的https连接</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案</li><li>插件式的自定义认证方案</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接</li><li>自动处理Set-Cookie中的Cookie</li><li>插件式的自定义Cookie策略</li><li>Request的输入流可以避免流中内容直接缓冲到socket服务器</li><li>Response的输出流可以有效的从socket服务器直接读取相应内容</li><li>在http1.0和http1.1中利用KeepAlive保持持久连接</li><li>直接获取服务器发送的response code和 headers</li><li>设置连接超时的能力</li><li>实验性的支持http1.1 response caching</li><li>源代码基于Apache License 可免费获取</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建HttpClient对象</p></li><li><p>创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象</p></li><li><p>如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。</p></li><li><p>调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。</p></li><li><p>调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</p></li><li><p>释放连接。无论执行方法是否成功，都必须释放连接</p></li></ol><p>四、实例<br>package com.test;  </p><p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.IOException;<br>import java.io.UnsupportedEncodingException;<br>import java.security.KeyManagementException;<br>import java.security.KeyStore;<br>import java.security.KeyStoreException;<br>import java.security.NoSuchAlgorithmException;<br>import java.security.cert.CertificateException;<br>import java.util.ArrayList;<br>import java.util.List;  </p><p>import javax.net.ssl.SSLContext;  </p><p>import org.apache.http.HttpEntity;<br>import org.apache.http.NameValuePair;<br>import org.apache.http.ParseException;<br>import org.apache.http.client.ClientProtocolException;<br>import org.apache.http.client.entity.UrlEncodedFormEntity;<br>import org.apache.http.client.methods.CloseableHttpResponse;<br>import org.apache.http.client.methods.HttpGet;<br>import org.apache.http.client.methods.HttpPost;<br>import org.apache.http.conn.ssl.SSLConnectionSocketFactory;<br>import org.apache.http.conn.ssl.SSLContexts;<br>import org.apache.http.conn.ssl.TrustSelfSignedStrategy;<br>import org.apache.http.entity.ContentType;<br>import org.apache.http.entity.mime.MultipartEntityBuilder;<br>import org.apache.http.entity.mime.content.FileBody;<br>import org.apache.http.entity.mime.content.StringBody;<br>import org.apache.http.impl.client.CloseableHttpClient;<br>import org.apache.http.impl.client.HttpClients;<br>import org.apache.http.message.BasicNameValuePair;<br>import org.apache.http.util.EntityUtils;<br>import org.junit.Test;  </p><p>public class HttpClientTest {  </p><pre><code>@Test  public void jUnitTest() &#123;      get();  &#125;  /**  * HttpClient连接SSL  */  public void ssl() &#123;      CloseableHttpClient httpclient = null;      try &#123;          KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());          FileInputStream instream = new FileInputStream(new File(&quot;d:\\tomcat.keystore&quot;));          try &#123;              // 加载keyStore d:\\tomcat.keystore                trustStore.load(instream, &quot;123456&quot;.toCharArray());          &#125; catch (CertificateException e) &#123;              e.printStackTrace();          &#125; finally &#123;              try &#123;                  instream.close();              &#125; catch (Exception ignore) &#123;              &#125;          &#125;          // 相信自己的CA和所有自签名的证书          SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build();          // 只允许使用TLSv1协议          SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; &quot;TLSv1&quot; &#125;, null,                  SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);          httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();          // 创建http请求(get方式)          HttpGet httpget = new HttpGet(&quot;https://localhost:8443/myDemo/Ajax/serivceJ.action&quot;);          System.out.println(&quot;executing request&quot; + httpget.getRequestLine());          CloseableHttpResponse response = httpclient.execute(httpget);          try &#123;              HttpEntity entity = response.getEntity();              System.out.println(&quot;----------------------------------------&quot;);              System.out.println(response.getStatusLine());              if (entity != null) &#123;                  System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                  System.out.println(EntityUtils.toString(entity));                  EntityUtils.consume(entity);              &#125;          &#125; finally &#123;              response.close();          &#125;      &#125; catch (ParseException e) &#123;          e.printStackTrace();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; catch (KeyManagementException e) &#123;          e.printStackTrace();      &#125; catch (NoSuchAlgorithmException e) &#123;          e.printStackTrace();      &#125; catch (KeyStoreException e) &#123;          e.printStackTrace();      &#125; finally &#123;          if (httpclient != null) &#123;              try &#123;                  httpclient.close();              &#125; catch (IOException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;  &#125;  /**  * post方式提交表单（模拟用户登录请求）  */  public void postForm() &#123;      // 创建默认的httpClient实例.        CloseableHttpClient httpclient = HttpClients.createDefault();      // 创建httppost        HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceJ.action&quot;);      // 创建参数队列        List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;();      formparams.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;));      formparams.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;));      UrlEncodedFormEntity uefEntity;      try &#123;          uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);          httppost.setEntity(uefEntity);          System.out.println(&quot;executing request &quot; + httppost.getURI());          CloseableHttpResponse response = httpclient.execute(httppost);          try &#123;              HttpEntity entity = response.getEntity();              if (entity != null) &#123;                  System.out.println(&quot;--------------------------------------&quot;);                  System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity, &quot;UTF-8&quot;));                  System.out.println(&quot;--------------------------------------&quot;);              &#125;          &#125; finally &#123;              response.close();          &#125;      &#125; catch (ClientProtocolException e) &#123;          e.printStackTrace();      &#125; catch (UnsupportedEncodingException e1) &#123;          e1.printStackTrace();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; finally &#123;          // 关闭连接,释放资源            try &#123;              httpclient.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;  /**  * 发送 post请求访问本地应用并根据传递参数不同返回不同结果  */  public void post() &#123;      // 创建默认的httpClient实例.        CloseableHttpClient httpclient = HttpClients.createDefault();      // 创建httppost        HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceJ.action&quot;);      // 创建参数队列        List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;();      formparams.add(new BasicNameValuePair(&quot;type&quot;, &quot;house&quot;));      UrlEncodedFormEntity uefEntity;      try &#123;          uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);          httppost.setEntity(uefEntity);          System.out.println(&quot;executing request &quot; + httppost.getURI());          CloseableHttpResponse response = httpclient.execute(httppost);          try &#123;              HttpEntity entity = response.getEntity();              if (entity != null) &#123;                  System.out.println(&quot;--------------------------------------&quot;);                  System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity, &quot;UTF-8&quot;));                  System.out.println(&quot;--------------------------------------&quot;);              &#125;          &#125; finally &#123;              response.close();          &#125;      &#125; catch (ClientProtocolException e) &#123;          e.printStackTrace();      &#125; catch (UnsupportedEncodingException e1) &#123;          e1.printStackTrace();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; finally &#123;          // 关闭连接,释放资源            try &#123;              httpclient.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;  /**  * 发送 get请求  */  public void get() &#123;      CloseableHttpClient httpclient = HttpClients.createDefault();      try &#123;          // 创建httpget.            HttpGet httpget = new HttpGet(&quot;http://www.baidu.com/&quot;);          System.out.println(&quot;executing request &quot; + httpget.getURI());          // 执行get请求.            CloseableHttpResponse response = httpclient.execute(httpget);          try &#123;              // 获取响应实体                HttpEntity entity = response.getEntity();              System.out.println(&quot;--------------------------------------&quot;);              // 打印响应状态                System.out.println(response.getStatusLine());              if (entity != null) &#123;                  // 打印响应内容长度                    System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                  // 打印响应内容                    System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity));              &#125;              System.out.println(&quot;------------------------------------&quot;);          &#125; finally &#123;              response.close();          &#125;      &#125; catch (ClientProtocolException e) &#123;          e.printStackTrace();      &#125; catch (ParseException e) &#123;          e.printStackTrace();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; finally &#123;          // 关闭连接,释放资源            try &#123;              httpclient.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;  /**  * 上传文件  */  public void upload() &#123;      CloseableHttpClient httpclient = HttpClients.createDefault();      try &#123;          HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceFile.action&quot;);          FileBody bin = new FileBody(new File(&quot;F:\\image\\sendpix0.jpg&quot;));          StringBody comment = new StringBody(&quot;A binary file of some kind&quot;, ContentType.TEXT_PLAIN);          HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(&quot;bin&quot;, bin).addPart(&quot;comment&quot;, comment).build();          httppost.setEntity(reqEntity);          System.out.println(&quot;executing request &quot; + httppost.getRequestLine());          CloseableHttpResponse response = httpclient.execute(httppost);          try &#123;              System.out.println(&quot;----------------------------------------&quot;);              System.out.println(response.getStatusLine());              HttpEntity resEntity = response.getEntity();              if (resEntity != null) &#123;                  System.out.println(&quot;Response content length: &quot; + resEntity.getContentLength());              &#125;              EntityUtils.consume(resEntity);          &#125; finally &#123;              response.close();          &#125;      &#125; catch (ClientProtocolException e) &#123;          e.printStackTrace();      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; finally &#123;          try &#123;              httpclient.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;  </code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound简介</title>
      <link href="/2022/01/03/Java/SpringClound/%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/01/03/Java/SpringClound/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/">官网地址：http://projects.spring.io/spring-cloud/</a></p><p>SpringCloud必须依赖SpringBoot；反之不然</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li><li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li><li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li><li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>SpringCloud将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><ul><li>Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） </li><li>Zuul：网关组件，提供智能路由，访问过滤功能 </li><li>Ribbon：客户端负载均衡的服务调用组件（客户端负载） </li><li>Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） </li><li>Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) </li></ul><h2 id="微服务场景模拟"><a href="#微服务场景模拟" class="headerlink" title="微服务场景模拟"></a>微服务场景模拟</h2><p>搭建两个工程：provider（服务提供方）和consumer（服务调用方）<br>服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。<br>服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。</p><ul><li>使用RestTemplate发送http请求实现远程调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Servlet使用</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/jsp%E4%B8%8Ejspx%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/jsp%E4%B8%8Ejspx%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>JSP全称Java Server Pages，是一种动态网页开发技术</li><li>JSP是一种加强版的Java servlet，主要用于实现Java web应用程序的用户界面部分</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>Web 服务器识别出这是对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成</li><li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet</li><li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎</li><li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类</li><li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中</li></ol><h2 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h2><ul><li>编译阶段：servlet容器编译servlet源文件，生成servlet类</li><li>初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</li><li>执行阶段：调用与JSP对应的servlet实例的服务方法</li><li>销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</li></ul><h2 id="jsp中文编码问题"><a href="#jsp中文编码问题" class="headerlink" title="jsp中文编码问题"></a>jsp中文编码问题</h2><pre class=" language-jsp"><code class="language-jsp"><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%></code></pre><h2 id="jsp表达式"><a href="#jsp表达式" class="headerlink" title="jsp表达式"></a>jsp表达式</h2><pre class=" language-jsp"><code class="language-jsp"><%= java表达式 %></code></pre><h2 id="jsp语法"><a href="#jsp语法" class="headerlink" title="jsp语法"></a>jsp语法</h2><pre class=" language-jsp"><code class="language-jsp"><% java代码片段 %></code></pre><h2 id="jsp注释"><a href="#jsp注释" class="headerlink" title="jsp注释"></a>jsp注释</h2><pre class=" language-jsp"><code class="language-jsp"><%-- 该部分注释在网页中不会被显示--%> </code></pre><h2 id="jsp指令"><a href="#jsp指令" class="headerlink" title="jsp指令"></a>jsp指令</h2><ul><li>格式:<code>&lt;%@ 指令名称 属性名=值 属性名=值 ... %&gt;</code></li><li>分类<ol><li>page：  配置jsp页面</li></ol><ul><li>contentType：等同于repsonse.setContentType()<ol><li>设置响应体的mime类型及字符集</li><li>设置当前jsp页面的编码</li></ol></li><li>import：      导包</li><li>errorPage:    当前页面发生异常后，会自动跳转的指定的错误页面</li><li>isErrorPage： 标识当前的页面是否是错误页面。</li><li>true：        使用内置对象execption</li><li>false：       默认值。不使用execption对象。</li></ul><ol start="2"><li>include ： 页面包含的。导入页面的资源文件。</li></ol><ul><li>例:<code>&lt;%@ include file=&quot;top.jsp&quot; %&gt;</code></li></ul><ol start="3"><li>taglib： 导入资源</li></ol><ul><li>例:<code>&lt;%@ taglib prefix=&quot;c&quot;  uri=&quot;java.sun.com/jsp/jstl/core&quot; %&gt;</code><ul><li><code>prefix</code>：前缀</li></ul></li></ul></li></ul><h2 id="JSP隐含对象"><a href="#JSP隐含对象" class="headerlink" title="JSP隐含对象"></a>JSP隐含对象</h2><p><code>request</code>       HttpServletRequest类的实例<br><code>response</code>        HttpServletResponse类的实例<br><code>out</code>           PrintWriter类的实例，用于把结果输出至网页上<br><code>session</code>       HttpSession类的实例<br><code>application</code>   ServletContext类的实例，与应用上下文有关<br><code>config</code>        ServletConfig类的实例<br><code>pageContext</code>      PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问<br><code>page</code>            类似于Java类中的this关键字<br><code>exception</code>        exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>达式语句</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>  替换和简化jsp的java代码编写（可以从域中取数据）</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>${表达式}<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li><li>jsp默认支持el表达式。如果要忽略el表达式</li><li>设置jsp中page指令，  isELIgnored=”true”，禁用页面中el表达式</li><li>${表达式}：忽略当前的这个el表达式<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></li><li>运算<ol><li>算术运算符  +   -  *  /(div)    %(mod)  </li><li>比较运算符 ：  &gt;    &lt;   &gt;=   &lt;=    ==   !=</li><li>逻辑运算符：  &amp;&amp;(and)    ||(or)   !(not)</li><li>空运算符：empty</li></ol><ul><li>功能：判断字符串，集合，数组对是否为空或长度为0   </li></ul></li><li>获取值<ul><li>语法：<ul><li>${域名称.键名}：从指定域中获取键值</li><li>1.pageScope                  –&gt; pageContext    </li><li>2.requestScope            –&gt;request          </li><li>3.sessionScope            –&gt;session           </li><li>4.applicationScope        –&gt;application(ServletContext)</li></ul></li><li>说明：<br>如果省略掉了域名称，会默认从最小的域中依此去找<font color="red">！！！el表达式只能从域中取数据</font></li></ul></li><li>获取对象，list集合，Map集合的值<ol><li>对象    - 对象名.属性名</li><li>List集合    - 集合名.get(索引)   集合名[索引]</li><li>Map集合    - ${集合名.key名称}    - ${集合名[“key名称”]}</li></ol></li><li>隐式对象。<ul><li>el表达式中有11个隐式对象。</li><li>获取jsp其它的八大内置对象<br><font color="red">在jsp页面中动态获取出虚拟目录${pageContext.request.ContextPath}</font></li></ul></li></ul><h2 id="jstl标签库"><a href="#jstl标签库" class="headerlink" title="jstl标签库"></a>jstl标签库</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>apache公司提供的产品，免费的。作用：el表达式没有循环和分支，但是jstl标签    库有<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3></li><li>简化jsp页面的代码<h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3></li></ul><ol><li>导入jar包</li><li>使用tablib引入标签库</li><li>使用标签</li><li>常用的jstl标签    1. if：相当于java中的if语句<ul><li>属性：<ul><li>test：必要属性。接收布尔值。</li></ul><ul><li>如果表达式为true，执行标签体内容，否则，不执行。    2. choose：相当于java中的switch语句</li></ul></li><li>when：相当于case</li><li>otherwise：  default    3. foreach</li><li>普通for:<ul><li>begin=”开始” </li><li>end=”结束”  </li><li>step=”步长”</li></ul></li><li>增强for：<ul><li>var=””          增强for中的变量名,普通for表示自增的数字</li><li>items=””      增强for中的集合名</li></ul></li><li>varStatus=””  取出个数和索引。<ul><li>current     普通for循环时,current为当前坐标;增强for循环为当前个数</li></ul></li></ul></li></ol><h2 id="jsp和jspx的区别"><a href="#jsp和jspx的区别" class="headerlink" title="jsp和jspx的区别"></a>jsp和jspx的区别</h2><p>  jsp的格式，其中包含“&lt;%”声明符，jsp文件通常在服务器端处理后呈现为html代码，尽管jsp通常的目的是处理web页面，但是jsp的代码呈现却不是我们希望的html或xml格式，代码非常混乱，这也是为什么出现jspx<br>  jspx完全符号xml语法规范，这种规范化会带来很多的好处，我们编码会方便很多，如xml形式方便代码格式化，便于编辑呈现<br>  jspx：以xml语法来书写jsp的文件，自定义的映射类型, jspx = jsp + XML</p><h2 id="JSP与Servlet有何异同"><a href="#JSP与Servlet有何异同" class="headerlink" title="JSP与Servlet有何异同"></a>JSP与Servlet有何异同</h2><p>JSP与Servlet的相同点为：JSP可以被看作一个特殊的Servlet，它只不过是对Servlet的扩展，只要是JSP可以完成的工作，使用Servlet都可以完成，例如生成动态页面。由于JSP页面最终要被转换成Servlet来运行，因此处理请求实际上是编译后的Servlet</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Servlet使用</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Tomcat%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Tomcat%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></li><li>安装：解压压缩包即可 * 注意：安装目录中不要有中文和空格</li><li>卸载：删除目录即可</li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>bin            可执行文件</li><li>config        配置<ul><li>server.xml    tomcat环境配置</li></ul></li><li>lib            依赖jar包</li><li>logs            日志</li><li>webapps        项目部署目录</li><li>work            运行时资源</li></ul><h2 id="服务的启动与关闭"><a href="#服务的启动与关闭" class="headerlink" title="服务的启动与关闭"></a>服务的启动与关闭</h2><ul><li>启动服务<code>bin/startup.bat</code>    </li><li>关闭服务<code>bin/shutdown.bat</code> </li></ul><h2 id="部署项目的方式："><a href="#部署项目的方式：" class="headerlink" title="部署项目的方式："></a>部署项目的方式：</h2><ol><li><p>直接将项目放到webapps目录下即可    - 简化部署：将项目打成一个war包，将war包放在webapps目录下    - war包会自动解压缩</p></li><li><p>conf/server.xml文件中配置    - 在<Host>标签中配置<Context docbase="”D:\hello” path=”/hehe” /"><br> docBase属性：项目的存放的位置<br> path属性：虚拟目录</Context></Host></p></li><li><p>在conf/Catalina/localhost 创建任意名称的xml文件    - 在文件中编写：<Context docbase="D:\hello">    - 访问路径：<code>xml文件的名称</code></Context></p></li></ol><h2 id="idea集成开发环境配置tomcat"><a href="#idea集成开发环境配置tomcat" class="headerlink" title="idea集成开发环境配置tomcat"></a>idea集成开发环境配置tomcat</h2><ul><li>idea会为web项目创建配置文件</li><li>tomcat启动时会输出配置文件路径  Using CATALINA_BASE</li><li>编译打包后的真正文件位于 配置文件的docBase指向的路径</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request与Response详解</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Request%E4%B8%8EResponse%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Request%E4%B8%8EResponse%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Request-请求-与Response-响应"><a href="#Request-请求-与Response-响应" class="headerlink" title="Request(请求)与Response(响应)"></a>Request(请求)与Response(响应)</h2><ul><li>request和response对象由服务器创建 ; 程序员使用</li><li>request对象是用来获取请求信息 ; response对象用来设置响应信息</li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request继承体系结构"><a href="#Request继承体系结构" class="headerlink" title="Request继承体系结构"></a>Request继承体系结构</h3><p><code>ServletRequest</code>接口<br><code>HttpServletRequest</code>接口继承自<code>ServletRequest</code>接口;在<code>ServletRequest</code>的基础上新增一些额外的方法</p><h3 id="HttpServletRequest方法"><a href="#HttpServletRequest方法" class="headerlink" title="HttpServletRequest方法"></a>HttpServletRequest方法</h3><h4 id="获取请求行的数据"><a href="#获取请求行的数据" class="headerlink" title="获取请求行的数据"></a>获取请求行的数据</h4><ul><li><code>String getMethod()</code>      获取请求方式</li><li><code>String getContextPath()</code> 获取资源目录地址(上下文地址)</li><li><code>String getServletPath()</code> 获取servlet路径</li><li><code>String getQueryString()</code> 获取get请求的请求参数</li><li><code>String getRequestURI()</code>  获取请求URI (统一资源标识符)</li><li><code>String getRequestURL()</code>  获取请求URL (统一资源定位符)</li><li><code>String getProtocol()</code>    获取协议和版本</li><li><code>String getRemoteAddr()</code>  获取客户端的IP地址</li></ul><h4 id="获取请求头的数据"><a href="#获取请求头的数据" class="headerlink" title="获取请求头的数据"></a>获取请求头的数据</h4><ul><li><code>String getHeader(String name)</code>         通过请求头的键获取请求头的值</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>  获取所有的请求头名称</li></ul><h4 id="获取请求参数的通用方式："><a href="#获取请求参数的通用方式：" class="headerlink" title="获取请求参数的通用方式："></a>获取请求参数的通用方式：</h4><ul><li><code>getParameter(String name)</code>               通过参数名获取参数的值  </li><li><code>getParameterValues(String name)</code>         通过参数名获取参数值的数组</li><li><code>Enumeration&lt;String&gt; getParameterNames()</code> 获取所有的请求的参数名</li><li><code>Map&lt;String,String[]&gt; getParamenterMap()</code> 获取所有参数的map集合</li></ul><h4 id="获取请求体的数据"><a href="#获取请求体的数据" class="headerlink" title="获取请求体的数据"></a>获取请求体的数据</h4><ol><li>获取流对象<br><code>BufferedReader getReader()</code>          获取字符输入流<br><code>ServletInputStream getInputStream()</code> 获取字节输入流</li><li>从流中拿数据</li></ol><h4 id="设置编码格式"><a href="#设置编码格式" class="headerlink" title="设置编码格式"></a>设置编码格式</h4><ul><li><code>void setCharacterEncoding(&quot;utf-8&quot;)</code>   覆盖请求体中使用的字符编码 <font color="red">必须在读取请求参数或使用getReader()读取输入之前调用</font>  </li></ul><h4 id="获取请求转发对象"><a href="#获取请求转发对象" class="headerlink" title="获取请求转发对象"></a>获取请求转发对象</h4><ul><li><code>request.getRequestDispatcher()</code>              获取请求转发对象(请求分配器对象)</li></ul><h4 id="获取Servlet上下文地址"><a href="#获取Servlet上下文地址" class="headerlink" title="获取Servlet上下文地址"></a>获取Servlet上下文地址</h4><ul><li><code>ServletContext  getServletContext()</code>         获取Servlet上下文地址</li></ul><h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><ul><li><code>void setAttribute(String name,Object obj)</code>   存储数据</li><li><code>Object geteAttribute(String name)</code>           通过键从域中获取数据</li><li><code>void removeAttribute(String name)</code>           通过键从域中删除数据</li></ul><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="Response继承体系结构"><a href="#Response继承体系结构" class="headerlink" title="Response继承体系结构"></a>Response继承体系结构</h3><p><code>ServletResponse</code>接口<br><code>HttpServletResponse</code>接口继承自<code>ServletResponse</code>接口;在<code>ServletResponse</code>的基础上新增一些额外的方法</p><h3 id="HttpServletResponse方法"><a href="#HttpServletResponse方法" class="headerlink" title="HttpServletResponse方法"></a>HttpServletResponse方法</h3><h4 id="设置响应行"><a href="#设置响应行" class="headerlink" title="设置响应行"></a>设置响应行</h4><ul><li><code>void setStatus(int sc)</code>                设置状态码</li><li><code>void setStatus(int sc,String message)</code> 设置状态码及状态码描述</li></ul><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><ul><li><code>void setHeader(String name,String value)</code>  设置响应头中的某个参数数据信息</li></ul><h4 id="设置响应体"><a href="#设置响应体" class="headerlink" title="设置响应体"></a>设置响应体</h4><ol><li>获取输出流    - 字符输出流 <code>PrintWriter getWriter()</code>    - 字节输出流 <code>ServletOutputStream getOutputStream()</code></li><li>使用输出流，将数据输出给客户端    - <code>输出流对象.write(&quot;登录失败&quot;);</code></li></ol><h4 id="设置响应内容类型及编码格式"><a href="#设置响应内容类型及编码格式" class="headerlink" title="设置响应内容类型及编码格式"></a>设置响应内容类型及编码格式</h4><ul><li><code>void setContentType(&quot;text/html;charset=utf-8&quot;);</code> </li></ul><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><ul><li><code>response.sendRedirect(&quot;重定向的资源路径&quot;)</code></li></ul><h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><p>Request：</p><ul><li>域对象 有作用范围的对象，可以在范围内共享数据</li><li>请求域 可以在一次请求的范围内，共享数据<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><code>void setAttribute(String name,Object obj)</code> 存储数据<br><code>Object geteAttribute(String name)</code>         通过键从域中获取数据<br><code>void removeAttribute(String name)</code>         通过键从域中删除数据</li></ul><h2 id="请求转发与请求重定向"><a href="#请求转发与请求重定向" class="headerlink" title="请求转发与请求重定向"></a>请求转发与请求重定向</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul><li>在服务端内部的资源跳转方式,转发之后 当前操作的后续代码会执行</li><li>实现方式: <code>request.getRequestDispatcher(&quot;要访问的资源地址&quot;).forward(request,response)</code><ol><li><code>request.getRequestDispatcher(&quot;要访问的资源地址&quot;)</code>  获取请求转发对象</li><li><code>请求转发对象.forward(requst,response)</code>             执行资源跳转<h3 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h3></li></ol></li><li>客户端或服务端都可实现,重定向之后 当前操作的后续代码会执行</li><li>实现方式<ul><li>方式1<br>//设置状态码<br><code>response.setStatus(302);</code><br>//设置响应头<br><code>response.setHeader(&quot;location&quot;,&quot;重定向的资源路径&quot;)</code></li><li>方式2<br><code>response.sendRedirect(&quot;重定向的资源路径&quot;)</code><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点:"></a>共同点:</h3></li></ul></li><li>转发和重定向都是实现页面跳转<h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3></li><li>转发时浏览器中的url地址不会发生改变</li><li>重定向时浏览器中的url地址会发生改变</li><li>转发时浏览器只请求一次服务器</li><li>重定向时浏览器请求两次服务器</li><li>转发能使用request带数据到跳转的页面</li><li>重定向能使用ServletContext带数据到跳转的页面</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径配置</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><ul><li>相对于当前文件所在的位置;目标文件相对于当前文件所在的位置</li><li>找到当前位置和目标位置之间的关系。(描述这个关系)</li></ul><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><ul><li>绝对于项目编译后根目录(项目上下文)所在的位置;目标文件绝对于项目上下文所在的位置</li><li>以  / 开头</li><li>使用绝对路径需要获取上下文路径,使用<code>request.getContextPath()</code>获取</li></ul><h3 id="绝对路径使用规则"><a href="#绝对路径使用规则" class="headerlink" title="绝对路径使用规则"></a>绝对路径使用规则</h3><ul><li>客户端：加上下文路径</li><li>服务器：不加上下文路径 例:(转发)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet文件下载案例</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>AdaptiveBrowserUtil文件 适配不同浏览器</p><pre class=" language-Java"><code class="language-Java">package cn.dy.util;import sun.misc.BASE64Encoder;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;/** * @author zrh * @date 2022/1/6 * @apiNote */public class AdaptiveBrowserUtil &#123;    /**     * 根据浏览器不同,配置  下载文件不同的名称 编码格式     * @param agent 浏览器信息->可以在request的header中的user-agent查询     * @param filename  文件名称     * @return  文件名称     * @throws UnsupportedEncodingException     */    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123;        if (agent.contains("MSIE")) &#123;            // IE浏览器          filename = URLEncoder.encode(filename, "utf-8");          filename = filename.replace("+", " ");        &#125; else if (agent.contains("Firefox")) &#123;            // 火狐浏览器          BASE64Encoder base64Encoder = new BASE64Encoder();          filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?=";        &#125; else &#123;            // 其它浏览器          filename = URLEncoder.encode(filename, "utf-8");        &#125;        return filename;    &#125;&#125;</code></pre><p>DownloadServlet文件 实现下载Servlet</p><pre class=" language-Java"><code class="language-Java">import cn.dy.util.AdaptiveBrowserUtil;import javax.servlet.ServletContext;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;@WebServlet("/downloadServlet")public class DownloadServlet extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123;        //  获取文件名称        String fileName = request.getParameter("fileName");        //  获取项目的上下文        ServletContext servletContext = request.getServletContext();        //  找到文件的真实路径        String realPath = servletContext.getRealPath(fileName);        //  获取文件的网络通信格式        String mimeType = servletContext.getMimeType(fileName);        //  根据不同浏览器适配不同格式文件名称        fileName = AdaptiveBrowserUtil.getFileName(request.getHeader("user-agent"), fileName);        //  设置  响应的数据格式为附件形式    附件形式==文件下载        response.setHeader("Content-disposition","attachment;filename="+fileName);        //  设置内容类型为XXX文件类型的网络通信格式        response.setHeader("content-type",mimeType);        //  使用文件输入流读取文件到bytes        FileInputStream fileInputStream = new FileInputStream(realPath);        byte[] bytes = new byte[3072];        int len = 0;        //  网络输出流从bytes写入页面        ServletOutputStream responseOutputStream = response.getOutputStream();        while ((len = fileInputStream.read(bytes)) != -1) &#123;            responseOutputStream.write(bytes);        &#125;    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123;        this.doPost(request, response);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound Hystrix熔断器</title>
      <link href="/2022/01/03/Java/SpringClound/Hystrix%E7%86%94%E6%96%AD%E5%99%A8/"/>
      <url>/2022/01/03/Java/SpringClound/Hystrix%E7%86%94%E6%96%AD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hystrix熔断器<br><code>consumer（消费者）使用</code><br>主页：<a href="https://github.com/Netflix/Hystrix/">https://github.com/Netflix/Hystrix/</a></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Hystrix是Netflix开源的一个延迟和容错库<br>用于隔离访问远程服务、第三方库，防止出现级联失败</p><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><p>微服务中，服务间调用关系错综复杂，一个请求有可能调用多个微服务接口才可以实现，会形成非常复杂的调用链路<br>一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其他服务，如果此时某个服务出现异常<br>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞；服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，形成<code>雪崩效应</code>。</p><p>Hystrix解决雪崩问题的手段有两个：</p><ul><li><p>线程隔离</p></li><li><p>服务熔断</p></li></ul><h2 id="开启熔断"><a href="#开启熔断" class="headerlink" title="开启熔断"></a>开启熔断</h2><p>在启动类上添加@EnableCircuitBreaker注解</p><pre class=" language-Java"><code class="language-Java">@EnableCircuitBreaker@SpringBootApplication@EnableDiscoveryClientpublic class ConsumerApplication &#123;.......</code></pre><h2 id="SpringCloudApplication"><a href="#SpringCloudApplication" class="headerlink" title="@SpringCloudApplication"></a>@SpringCloudApplication</h2><p>SpringCloud提供了一个组合注解@SpringCloudApplication用来替换上方三个注解</p><h2 id="降级逻辑"><a href="#降级逻辑" class="headerlink" title="降级逻辑"></a>降级逻辑</h2><h3 id="HystrixCommand"><a href="#HystrixCommand" class="headerlink" title="@HystrixCommand"></a>@HystrixCommand</h3><p>目标服务的调用出现故障，希望快速失败，给用户一个友好提示，因此需要提前编写好失败降级的处理逻辑，要使用@HystrixCommand来完成</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;id&amp;#125;"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"queryByIdFallback"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>Long id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String url <span class="token operator">=</span> <span class="token string">"http://user-service/user/"</span><span class="token operator">+</span>id<span class="token punctuation">;</span>        String user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">queryByIdFallback</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"网络开小差了，请稍后再试"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>注意:<code>因为熔断降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明，失败逻辑中返回User对象没有太大意义，一般返回友好提示，所以吧queryById方法改为返回String，反正也是JSON数据，这样失败逻辑中返回一个错误说明会比较方便。</code></p><p>说明：</p><ul><li>@HystrixCommand(fallbackMethod = “queryByIdFallback”)用来声明一个降级逻辑的方法</li></ul><p>测试：<br>  当提供者正常提供服务时，访问与以前一致，但是当我们将提供者停机时，会发现页面返回了降级处理。</p><h2 id="默认的的Fallback"><a href="#默认的的Fallback" class="headerlink" title="默认的的Fallback"></a>默认的的Fallback</h2><p>Fallback配置加到类上，实现默认的fallback<br>使用注解<code>@DefaultProperties(defaultFallback = &quot;queryByIdFallback&quot;)</code>;注意,默认执行的方法里不能有参数</p><h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>@HystrixCommand(commandProperties = {<br>            @HystrixProperty(name = “execution.isolation.thread.timeoutInMilliseconds”,value = “2000”)<br>    })<br><code>这个配置会作用于全局所有方法</code></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>通过配置文件的方式来实现超时<br><code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间<br><strong>推荐</strong></p><h2 id="熔断原理"><a href="#熔断原理" class="headerlink" title="熔断原理"></a>熔断原理</h2><p>熔断器也叫断路器，其应为单词为：Circuit Breaker<br><img src="/2022/01/03/Java/SpringClound/Hystrix%E7%86%94%E6%96%AD%E5%99%A8/1525658640314-1565099920556.png" alt="1525658640314"></p><h2 id="Hystrix熔断状态"><a href="#Hystrix熔断状态" class="headerlink" title="Hystrix熔断状态"></a>Hystrix熔断状态</h2><ul><li>Closed：关闭状态（断路器关闭），所有请求都正常访问</li><li>Open：打开状态（断路器打开），所有请求都会被降级，Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断器，断路器会完全关闭，默认失败比例的阈值是50%，请求次数最少不低于20次</li><li>Half Open:半开状态，Closed状态不是永久的，关闭后会进入休眠时间（默认是5S）。随后熔断器会自动进入半开状态，此时会释放部分请求通过，若这些请求都是健康的，则会完全打开断路器，否则继续保持关闭，再次进入休眠计时。</li></ul><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>circuitBreaker.requestVolumeThreshold =10<br>circuitBreaker.sleepWindowInMilliseconds =10000<br>circuitBreaker.errorThresholdPercentage =60<br>解读<br>requestVolumeThreshold  触发熔断器最少请求次数默认是20<br>sleepWindowInMilliseconds   休眠时长，默认是5000毫秒<br>errorThresholdPercentage  触发熔断器最少占比默认50%</p><h2 id="熔断器总结"><a href="#熔断器总结" class="headerlink" title="熔断器总结"></a>熔断器总结</h2><p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。<br>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。<br>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Servlet介绍</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="静态资源与动态资源"><a href="#静态资源与动态资源" class="headerlink" title="静态资源与动态资源"></a>静态资源与动态资源</h2><ul><li>静态资源<br>前端的固定页面，包含HTML、CSS、JS、图片等，不需要查数据库也不需要请求处理，直接就能够显示，想修改内容则必须修改页面</li><li>动态资源<br>需要程序处理或者从数据库中读数据，能够根据不同的条件在页面显示不同的数据，内容更新不需要修改页面<br><code>servlet</code> <code>jsp</code> <code>asp</code> <code>html(Ajax)</code></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Servlet 是运行在 Web 服务器或应用服务器上的程序;全称Java Servlet;用Java编写的<code>服务器端程序</code></li><li>狭义的Servlet是指Java语言实现的一个接口</li><li>广义的Servlet是指任何实现了这个Servlet接口的类</li><li>位置: <code>tomcat/lib</code>存在servlet包<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2></li><li>性能更好</li><li>Servlet 在 Web 服务器的地址空间内执行。没有必要再创建一个单独的进程来处理每个客户端请求</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li><li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互</li></ul><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>运行于Servlet容器中</li><li>Servlet容器:<code>支持Java的应用服务器</code></li><li>例:<code>tomcat</code></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>主要功能在于交互式地浏览和修改数据，生成动态Web内容</li><li>实现上讲，Servlet可以响应任何类型的请求，但大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器</li></ul><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ol><li>客户端发送请求至服务器</li><li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li><li>服务器将响应返回客户端</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><strong><font color="red" size="4.8">Servlet类型的类都是单例模式,每个类都只能有一个实例,存在线程安全问题</font></strong></li><li><strong><font color="red" size="4.8">避免在Servlet中定义成员变量</font></strong>  <h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2>Servlet容器(tomcat)将Servlet类载入内存，使用反射生成Servlet实例并调用它具体的方法<br><img src="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E8%AF%A6%E8%A7%A3/tomcat%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.gif"></li></ul><h2 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h2><ul><li><code>void init()</code>：初始化方法，在第一次访问时执行，只执行1次<ul><li>可以来执行初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象从而对Servlet对象进行初始化</li></ul></li><li><code>void service(ServletRequest sq, ServletResponse sp)</code>：提供服务的方法，每次访问时都会执行，执行多次<ul><li>用来处理客户端的请求</li></ul></li><li><code>void destory()</code>：销毁的方法。在Servlet容器正常关闭之后执行1次<ul><li>常用来清除内存占用,释放资源</li></ul></li></ul><h2 id="Servlet-映射"><a href="#Servlet-映射" class="headerlink" title="Servlet 映射"></a>Servlet 映射</h2><ul><li>方式一<br><code>web.xml</code>中配置<pre class=" language-xml"><code class="language-xml">  <span class="token comment" spellcheck="true">&lt;!-- Servlet --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Servlet服务名 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>/demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Servlet类的全限定名 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>cn.dy.servlet.ServletDemo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- Servlet映射 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Servlet服务名 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>/demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Servlet服务地址 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/demo222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span></code></pre><strong><font color="red"><code>servlet</code>与<code>servlet-mapping</code>中的<code>servlet-name</code>必须一致</font></strong></li><li>方式二<br>servlet3.0后，支持类注解配置URL映射:<code>@webServlet(&quot;/访问路径&quot;)</code><br><img src="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E8%AF%A6%E8%A7%A3/@WebServlet%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7.png"><br>使用方式:<br>  <code>@webServlet(urlPatterns=&#123;访问路径1,访问路径2&#125;)</code><br>  <code>@webServlet(value=&#123;访问路径1,访问路径2&#125;)</code>value可以简写可以省略</li></ul><h2 id="Servlet体系结构及使用"><a href="#Servlet体系结构及使用" class="headerlink" title="Servlet体系结构及使用"></a>Servlet体系结构及使用</h2><ul><li><code>Servlet</code>接口<ul><li>某个类实现了<code>Servlet</code>接口之后，能够被服务器识别并使用;</li><li>常用的方法是<code>service</code>,但是需要重写所有方法</li></ul></li><li><code>GenericServlet</code>抽象类实现了<code>Servlet</code>接口<ul><li>这个类把除了servier方法之外的方法都做了空实现;</li><li>可以继承<code>GenericServlet</code>抽象类;只需要重写<code>service</code>方法就够了，当用别的方法的时，再重写别的方法</li></ul></li><li><code>HTTPServlet</code>抽象类   <ul><li>HttpServlet类继承自<code>GenericServlet</code>抽象类,并且对http协议的处理做了一些封装,更方便使用</li><li><font color="red">推荐使用继承该类的方式进行Servlet的开发</font></li></ul></li></ul><h2 id="HttpServlet使用"><a href="#HttpServlet使用" class="headerlink" title="HttpServlet使用"></a>HttpServlet使用</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//post请求进入此方法&#125;</code></li><li><code>void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//get请求进入此方法&#125;</code></li></ul><h3 id="Servlet资源路径的相关配置"><a href="#Servlet资源路径的相关配置" class="headerlink" title="Servlet资源路径的相关配置"></a>Servlet资源路径的相关配置</h3><ol><li>一个Servlet可以定义多个访问路径：<br><code>@webServlet(&#123;&quot;/demo4&quot;,&quot;/demo44&quot;,&quot;/demo444&quot;&#125;)</code></li><li>路径的定义规则：    - /xxx ：路径匹配    - /xxx/xxx  ：多层路径，目录结构    - *.do   XXX.do就可以访问</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ServletContext详解</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20ServletContext%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20ServletContext%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>ServletContext代表整个web应用，可以和程序的容器(服务器,例:tomcat)进行通信</li><li>整个web应用只有一个ServletContext对象</li></ul><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ul><li>Request获取<ul><li>request.getServletContext() </li></ul></li><li>HttpServlet获取<ul><li>this.getServletContext()</li></ul></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="作为全局域来使用-共享数据"><a href="#作为全局域来使用-共享数据" class="headerlink" title="作为全局域来使用(共享数据)"></a>作为全局域来使用(共享数据)</h3><p>这个域太大,<strong><font color="red">慎用</font></strong></p><ul><li><code>void setAttribute(String name,Object value)</code> 设置(修改)数据</li><li><code>Object getAttribute(String name)</code>  获取数据</li><li><code>void removeAttribute(String name)</code> 删除数据</li></ul><h3 id="获取MIME类型"><a href="#获取MIME类型" class="headerlink" title="获取MIME类型"></a>获取MIME类型</h3><p>MIME类型：在互联网通信过程中传输的一种文件数据类型<br>  例: png,jpg 的MIME类型 都是 image/jpeg</p><ul><li><code>String getMimeType(String file)</code> 获取MIME类型</li></ul><h3 id="获取文件的真实路径"><a href="#获取文件的真实路径" class="headerlink" title="获取文件的真实路径"></a>获取文件的真实路径</h3><ul><li><code>String getRealPath(String path)</code> 获取文件编译后的绝对路径</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Listener</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Listener%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Listener%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Filter</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Filter%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie与Session详解</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Cookie%E4%B8%8ESession%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Cookie%E4%B8%8ESession%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul><li>一次会话： 浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止</li><li>一次会话中包含多次请求和响应</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>在一次会话的范围内的多次请求中，共享数据</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>客户端会话技术 数据保存到客户端(浏览器)</li><li>cookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>  Cookie 的使用需要对中文进行编码与解码</p><pre class=" language-Java"><code class="language-Java">//  编码String str = java.net.URLEncoder.encode("中文"，"UTF-8");//  解码        String str = java.net.URLDecoder.decode("编码后的字符串","UTF-8");   </code></pre><p>  Cookie 设置在 HTTP 头信息中;</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p><code>new Cookie(String name,String value)</code>  创建Cookie对象,绑定数据</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4></li><li><p><code>response.addCookie(Cookie cookie)</code> 向客户端添加Cookie(发送cookie对象)</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4></li><li><p><code>Cookie[]  request.getCookies()</code>    使用request获取Cookie,返回值为整个Cookie数组</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4></li><li><p><code>void setDomain(String pattern)</code>    设置 cookie 适用的域</p></li><li><p><code>String getDomain()</code>                获取 cookie 适用的域</p></li><li><p><code>void setMaxAge(int expiry)</code>        设置 cookie 过期的时间(以秒为单位);如果不设置,只在当前 session 会话中持续有效</p></li><li><p><code>int getMaxAge()</code> 获取 cookie 的最大生存周期（以秒为单位）</p></li><li><p><code>String getName()</code>  获取 cookie 的名称;名称创建后不可改变</p></li><li><p><code>void setValue(String newValue)</code>  设置 cookie 关联的值</p></li><li><p><code>String getValue()</code>     获取与 cookie 关联的值</p></li><li><p><code>void setPath(String uri)</code>  设置 cookie 适用的路径;不设置时<code>当前页面相同目录</code>下的所有 URL 都会返回 cookie</p></li><li><p><code>String getPath()</code>    获取 cookie 适用的路径</p></li><li><p><code>void setSecure(boolean flag)</code>  设置 cookie 是否只在加密的（即 SSL）连接上发送</p></li><li><p><code>void setComment(String purpose)</code> 设置cookie的注释</p></li><li><p><code>String getComment()</code> 获取 cookie 的注释，没有注释则返回 null</p><h4 id="Cookie案例"><a href="#Cookie案例" class="headerlink" title="Cookie案例"></a>Cookie案例</h4><pre class=" language-Java"><code class="language-Java">@WebServlet("/servletDemo1")public class ServletDemo1 extends HttpServlet &#123;protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    response.setContentType("text/html;charset=utf-8");    //1.获取cookie数组    Cookie[] cookies = request.getCookies();    DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    //遍历Cookies数组，拿到每一个cookie    for (Cookie cookie : cookies) &#123;        //获取cookie的名称        String name = cookie.getName();        //判断cookie是否为lastTime        if("lastTime".equals(name))&#123;            //  获取当前时间格式化为字符串;并进行编码            String lastTime = URLEncoder.encode(df.format(new  Date()), "utf-8");            //  设置新的值            cookie.setValue(lastTime);            //  设置存活时间            cookie.setMaxAge(60*2);            //  响应给页面            response.addCookie(cookie);            //  获取上一次存入cookie的时间进行解码并给页面响应数据            response.getWriter().write("欢迎回来，您上次的访问时间为：" + value = URLDecoder.decode(cookie.getValue(), "utf-8"));            return        &#125;    &#125;    //  第一次登录    //  获取当前时间格式化为字符串;并进行编码    String lastTime = URLEncoder.encode(df.format(new Date()), "utf-8");    //  创建cookie对象    Cookie cookie = new Cookie("lastTime",lastTime);    //  设置存活时间    cookie.setMaxAge(60*2);    //  添加到响应中    response.addCookie(cookie);    //  给页面响应数据    response.getWriter().write("您好，欢迎您第一次访问");&#125;protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    this.doPost(request, response);&#125;&#125;</code></pre></li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>基于响应头set-cookie和请求头cookie实现的</li></ul><h3 id="Cookie的存储时间"><a href="#Cookie的存储时间" class="headerlink" title="Cookie的存储时间"></a>Cookie的存储时间</h3><ul><li>默认情况下，浏览器关闭后，cookie数据销毁</li><li>持久化存储：<ul><li><code>Cookie对象.setMaxAge(int secounds)</code> 参数为以秒为单位的整数，该整数表示cookie的存储时长<ol><li>正数：将cookie写入硬盘;并指定存储时间，时间到后，cookie文件会消失</li><li>负数：默认值</li><li>零：删除cookie信息</li></ol></li></ul></li></ul><h3 id="cookie存储中文或特殊字符"><a href="#cookie存储中文或特殊字符" class="headerlink" title="cookie存储中文或特殊字符"></a>cookie存储中文或特殊字符</h3><ul><li>cookie支持中文数据。不支持特殊字符，建议使用url编码存储，url解码解析</li><li>例:<pre class=" language-Java"><code class="language-Java">//  编码URLEncoder.encode(编码的数据, "utf-8");//  解码URLDecoder.decode(解码的数据, "utf-8");</code></pre><h3 id="cookie共享问题？"><a href="#cookie共享问题？" class="headerlink" title="cookie共享问题？"></a>cookie共享问题？</h3></li><li>默认情况下cookie不能共享</li><li>setPath(String path)：设置cookie的获取范围。默认情况，设置当前的虚拟目录</li></ul><h3 id="不同的tomcat服务器间cookie共享问题？"><a href="#不同的tomcat服务器间cookie共享问题？" class="headerlink" title="不同的tomcat服务器间cookie共享问题？"></a>不同的tomcat服务器间cookie共享问题？</h3><ul><li>setDomain(String path)：如果一级域名相同，那么多个服务器之间可以共享</li><li>例:<br><a href="https://tieba.baidu.com/">https://tieba.baidu.com/</a><br><a href="http://news.baidu.com/">http://news.baidu.com/</a><br>baidu：一级域名<br>tieba和news：二级域名<br>案例：setDomain(“.baidu.com”),那么tieba和news可以共享cookie</li></ul><h3 id="cookie的特点和作用"><a href="#cookie的特点和作用" class="headerlink" title="cookie的特点和作用"></a>cookie的特点和作用</h3><ul><li>cookie存储在客户端(浏览器)</li><li>浏览器对单个cookie的大小是有限制的(4kb)以及对同一个域名下的总cookie数量有限制(20个)</li></ul><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol><li>cookie一般用于存储少量的不太敏感的数据</li><li>在不登陆的情况下，完成服务器对客户端身份的识别</li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>服务器端会话技术    Session<br>session以属性,值的方式存储</p><h3 id="HttpSession-对象"><a href="#HttpSession-对象" class="headerlink" title="HttpSession 对象"></a>HttpSession 对象</h3><ul><li>Servlet 提供了 HttpSession 接口，该接口提供了跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式</li></ul><h4 id="获取HttpSession-对象"><a href="#获取HttpSession-对象" class="headerlink" title="获取HttpSession 对象"></a>获取HttpSession 对象</h4><p>调用 HttpServletRequest 的公共方法 getSession() 来获取 HttpSession 对象<br>例:<code>HttpSession session = request.getSession();</code></p><h4 id="HttpSession-对象的重要方法"><a href="#HttpSession-对象的重要方法" class="headerlink" title="HttpSession 对象的重要方法"></a>HttpSession 对象的重要方法</h4><ul><li><code>Object getAttribute(String name)</code>  获取session中指定属性的值,没有返回null</li><li><code>Enumeration getAttributeNames()</code> 获取session中所有属性的名称,返回类型为String 对象的枚举</li><li><code>long getCreationTime()</code>  获取session 会话的创建时间;自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以<code>毫秒</code>为单位</li><li><code>String getId()</code>  获取该 session 会话的唯一标识符的字符串</li><li><code>long getLastAccessedTime()</code>  获取客户端最后一次与该 session 会话相关的请求的时间;自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以<code>毫秒</code>为单位</li><li><code>int getMaxInactiveInterval()</code>  获取 session 会话打开的最大时间间隔，以<code>秒</code>为单位</li><li><code>void invalidate()</code> 删除整个 session 会话</li><li><code>boolean isNew()</code>   客户选择不参入该 session 会话，则该方法返回 true</li><li><code>void removeAttribute(String name)</code> 移除一个特定的属性</li><li><code>void setAttribute(String name, Object value)</code>  设置名称和值到该 session 会话</li><li><code>void setMaxInactiveInterval(int interval)</code> 设置 session 会话过期时间,以<code>秒</code>为单位</li></ul><p>5、session的特点？<br>答：<br>当客户端关闭时，在服务器关闭、前后，获取session是否为同一个</p><ul><li>默认情况下，不是同一个session。如果需要相同，则可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</li></ul><p>客户端不关闭，在服务器关闭后，两次获取的session是同一个吗</p><ul><li>不是同一个<br>（1）Session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上。<br>（2）Session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。<br>tomcat自动的把session的钝化和活化做了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/03/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><ul><li>规定客户端和服务器通信时，发送数据的格式</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>超文本传输协议</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求/响应模型：一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol><h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><ul><li>1.0 ：每一次请求都会建立新的连接</li><li>1.1 ：复用连接（提高效率）</li><li>2.0 : <ul><li>连接复用 允许通过 HTTP/2 连接发起多重的请求-响应</li><li>新增首部压缩 采用HPACK算法</li><li>新增服务端推送</li></ul></li></ul><h2 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ul><li>请求方式 资源url地址  请求的协议/版本<br>例:&nbsp;&nbsp;GET /day16/hello.html HTTP/1.1</li></ul><h3 id="请求头-常用"><a href="#请求头-常用" class="headerlink" title="请求头(常用)"></a>请求头(常用)</h3><p>客户端告诉服务器的一些信息(请求头是键值对格式的)</p><ul><li><code>Accept</code>(请求的文件类型)&nbsp;&nbsp;例: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,<em>/</em>;q=0.8</li><li><code>Accept-Encoding</code>(请求的编码格式)&nbsp;&nbsp;例: gzip, deflate</li><li><code>Accept-Language</code>(语言)&nbsp;&nbsp;例: zh-CN,zh;q=0.9</li><li><code>Content-Length</code>(请求的内容长度)&nbsp;&nbsp;例: 33</li><li><code>Connection</code>(连接状态)&nbsp;&nbsp;例: keep-alive<ul><li>keep-alive  设置该连接为常连接</li></ul></li><li><code>Host</code>(请求域名)&nbsp;&nbsp;例: localhost:8080</li><li><code>User-Agent</code>(客户端的相关信息)&nbsp;&nbsp;例: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0</li><li><code>Referer</code>(请求来源)：<ul><li>作用：<ol><li>防盗链</li><li>统计工作</li></ol></li></ul></li></ul><h3 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h3><p>是一个空行 用来分割请求头和请求体的</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>  post请求的请求参数</p><h2 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h2><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><ul><li>协议/版本 响应状态码 状态码描述<br>例:&nbsp;&nbsp;HTTP/1.1 200 描述…</li></ul><h3 id="响应头-常用"><a href="#响应头-常用" class="headerlink" title="响应头(常用)"></a>响应头(常用)</h3><p>服务器告诉客户端的一些信息(响应头是键值对格式的)<br><code>Content-Length</code>(响应的内容长度)&nbsp;&nbsp;例: 19<br><code>Content-Type</code>(响应的数据格式及编码格式)&nbsp;&nbsp;例: text/html;charset=utf-8<br><code>Content-disposition</code>(响应数据的打开方式)&nbsp;&nbsp;例: in-line</p><ul><li>in-line：默认值 ; 在当前页面内打开</li><li>attachment;filename=xxx 以附件的形式打开响应体=文件下载</li></ul><h3 id="响应空行"><a href="#响应空行" class="headerlink" title="响应空行"></a>响应空行</h3><p>是一个空行 用来分割响应头和响应体的</p><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>  给客户端传输的数据</p><h2 id="常见请求方式："><a href="#常见请求方式：" class="headerlink" title="常见请求方式："></a>常见请求方式：</h2><h2 id="get请求与post请求的区别"><a href="#get请求与post请求的区别" class="headerlink" title="get请求与post请求的区别"></a>get请求与post请求的区别</h2><ul><li>GET （没有请求体）<ol><li>请求的参数在url路径后</li><li>请求的url长度有限制</li><li>不太安全</li></ol></li><li>POST<ol><li>请求的参数在请求体中</li><li>请求的url长度没有限制</li><li>相对安全</li></ol></li></ul><h2 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码:"></a>常见的http状态码:</h2><ul><li>200 ：请求成功</li><li>301 ：资源移动。所请求资源自动到新的URL，浏览器自动跳转到新的URL</li><li>304 ：请求缓存服务端的资源与客户端上一次请求的一致，不需要重新传输，客户端使用本地缓存的即可</li><li>400 ：错误请求</li><li>404 ：(资源丢失)未找到资源</li><li>500 ：服务器内部错误</li></ul><h2 id="请求转发与请求重定向"><a href="#请求转发与请求重定向" class="headerlink" title="请求转发与请求重定向"></a>请求转发与请求重定向</h2><p>转发和重定向都是实现页面跳转</p><ul><li>转发：在服务端内部的资源跳转方式,转发之后 当前操作的后续代码会执行<ol><li>地址栏不发生变化</li><li>转发只能转发服务器内部的资源</li><li>转发是一次请求</li></ol></li><li>重定向：客户端操作,后续代码会执行<ol><li>地址栏发生变化</li><li>重定向可以访问任意资源</li><li>重定向是两次请求</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound zuul网关</title>
      <link href="/2022/01/03/Java/SpringClound/zuul%E7%BD%91%E5%85%B3/"/>
      <url>/2022/01/03/Java/SpringClound/zuul%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2022/01/03/Java/SpringClound/zuul%E7%BD%91%E5%85%B3/1525674644660.png" alt="1525674644660"><br>Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；<br>而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；<br>通过<code>Spring Cloud Config实现了应用多环境的外部化配置以及版本管理??</code>。<br>为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p><p>在该架构中，服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。</p><p><strong>存在问题:</strong></p><ul><li>首先，破坏了服务无状态特点。<ul><li>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</li><li>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</li></ul></li><li>其次，无法直接复用既有接口。<ul><li>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口</li></ul></li></ul><p><strong>解决方案:</strong><br>zuul网关</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>服务网关是微服务架构中一个不可或缺的部分。<br>通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。<br>Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。<br>官网：<a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a><br><img src="/2022/01/03/Java/SpringClound/zuul%E7%BD%91%E5%85%B3/1525675168152.png" alt="1525675168152"></p><h2 id="Zuul加入后的架构"><a href="#Zuul加入后的架构" class="headerlink" title="Zuul加入后的架构"></a>Zuul加入后的架构</h2><p><img src="/2022/01/03/Java/SpringClound/zuul%E7%BD%91%E5%85%B3/1525675648881.png" alt="1525675648881"><br><strong>描述</strong><br>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>pom.xml</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-zuul<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- SpringCloud的依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Finchley.SR2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span></code></pre><h2 id="EnableZuulProxy-开启Zuul的功能"><a href="#EnableZuulProxy-开启Zuul的功能" class="headerlink" title="@EnableZuulProxy 开启Zuul的功能"></a>@EnableZuulProxy 开启Zuul的功能</h2><p>在启动类通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableZuulProxy</span> <span class="token comment" spellcheck="true">// 开启Zuul的网关功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZuulApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ZuulApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre class=" language-yml"><code class="language-yml">server:  port: 10010 #服务端口spring:   application:        name: api-gateway #指定服务名</code></pre><h2 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h2><p>方式一:</p><pre class=" language-yml"><code class="language-yml">zuul:  routes:    provider:                     # 这里是路由id，推荐和服务的名称一致      path: /provider/**          # 这里是映射路径      url: http://127.0.0.1:8082  # 映射路径对应的实际url地址</code></pre><p>方式二:</p><pre class=" language-yml"><code class="language-yml">zuul:  routes:    provider:                 # 这里是路由id，推荐和服务的名称一致      path: /provider/**      # 这里是映射路径      serviceId: provider     # 指定服务名称  # 映射路径对应的实际url地址</code></pre><p>方式三:<br><strong><code>推荐使用此方式</code></strong></p><pre class=" language-yml"><code class="language-yml">zuul:  routes:    provider: /provider/** # 这里是映射路径</code></pre><p>项目中使用zuul配置路由规则之后；访问地址为：<code>localhost:10010/provider/</code></p><h3 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h3><pre class=" language-yml"><code class="language-yml">zuul:  prefix: /api # 添加路由前缀  routes:    provider: /provider/** # 这里是映射路径</code></pre><h2 id="zuul注册在eureka"><a href="#zuul注册在eureka" class="headerlink" title="zuul注册在eureka"></a>zuul注册在eureka</h2><p>在zuul的pom.xml中配置</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Eureka客户端 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>启动类添加<code>@EnableDiscoveryClient</code>  </p><pre class=" language-Java"><code class="language-Java">@SpringBootApplication@EnableZuulProxy // 启动Zuul组件@EnableDiscoveryClient  //  开启Eureka客户端功能public class ZuulApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ZuulApplication.class, args);    &#125;&#125;</code></pre><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>需要继承<code>ZuulFilter</code>抽象类并实现其中的方法</p><pre class=" language-Java"><code class="language-Java">package cn.dy.filter;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.apache.http.HttpStatus;import javax.servlet.http.HttpServletRequest;/** * @author zrh * @date 2022/4/21 * @apiNote */public class TestFilter extends ZuulFilter &#123;    /**     *过滤器类型===过滤时机     *  值:     *      pre     之前     *      route   路由     *      post    之后     *      error   错误     * @return     */    @Override    public String filterType() &#123;        return "pre";    &#125;    /**     * 执行优先级     * 值越小优先级越高     * @return     */    @Override    public int filterOrder() &#123;        return 5;    &#125;    /**     * 是否过滤     * @return     */    @Override    public boolean shouldFilter() &#123;        return true;    &#125;    /**     * 具体的过滤业务逻辑     * @return     * @throws ZuulException     */    @Override    public Object run() throws ZuulException &#123;        //  获取到当前上下文        RequestContext currentContext = RequestContext.getCurrentContext();        //  获取到Request        HttpServletRequest request = currentContext.getRequest();        String token = request.getParameter("token");        if(token==null)&#123;            currentContext.setResponseStatusCode(HttpStatus.SC_FORBIDDEN);            currentContext.setResponseBody("权限不足");        &#125;        return null;    //  return null 代表不做任何操作    &#125;&#125;</code></pre><h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：   </p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">zuul</span><span class="token punctuation">:</span>  <span class="token key atrule">retryable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>  <span class="token key atrule">ConnectionTimeOut</span><span class="token punctuation">:</span> <span class="token number">500  </span><span class="token comment" spellcheck="true"># 连接超时时间(ms)</span>  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">2000 </span><span class="token comment" spellcheck="true"># 通信超时时间(ms)</span><span class="token key atrule">hystrix</span><span class="token punctuation">:</span>  <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">execution</span><span class="token punctuation">:</span>         <span class="token key atrule">isolation</span><span class="token punctuation">:</span>            <span class="token key atrule">thread</span><span class="token punctuation">:</span>               <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">6000 </span><span class="token comment" spellcheck="true"># 熔断超时时长：6000ms</span></code></pre><h2 id="3-11-zuul的高可用"><a href="#3-11-zuul的高可用" class="headerlink" title="3.11.zuul的高可用"></a>3.11.zuul的高可用</h2><p>启动多个zuul服务，自动注册Eureka，形成集群如果是服务内部访问，你访问zuul，自动负载均衡，没问题，但是zuul更多的是外部访问，PC端，移动端等，他们无法通过Eureka进行负载均衡，那么该怎么办</p><p>此时我们会使用其他的服务网关，来对zuul进行代理，比如：nginx</p><p>Eureka，Ribbon，Hystrix，Feign，Zuul</p><p>Spring-Cloud config：统一配置中心，自动去Git拉取最新配置，缓存，使用git的Webhook钩子，去通知配置中心，说配置发生了变化，配置中心会通过消息总线去通知所有的微服务，更新配置。</p><p>Spring-Cloud-bus：消息总线</p><p>Spring-Cloud-stream：消息通信</p><p>Spring-Cloud-Hystrix-dashboard：容错统计，形成图形化界面</p><p>Spring-Cloud-sleuth：链路追踪，结合ZipKin</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringClound Ribbon负载均衡</title>
      <link href="/2022/01/03/Java/SpringClound/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2022/01/03/Java/SpringClound/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实际环境中，会开启多个provider(提供者)的集群<br>此时获取的服务列表中就会有多个，这种情况下就需要编写负载均衡算法，在多个服务列表中进行选择。<br>Eureka中已经集成了负载均衡组件：<code>Ribbon</code><br><code>consumer（消费者）使用</code></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/assets/1525619257397.png" alt="1525619257397"></p><h2 id="开启负载均衡"><a href="#开启负载均衡" class="headerlink" title="开启负载均衡"></a>开启负载均衡</h2><p>Eureka中已经集成了Ribbon，所以无需引入新的依赖</p><p>在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment" spellcheck="true">//  开启负载均衡</span><span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"consumer/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RestTemplate restTemplate<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Autowired</span>    <span class="token comment" spellcheck="true">//private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> User <span class="token function">queryUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取服务提供方的服务列表，这里根据提供方名称;使用轮询的方式获取</span>        String baseUrl <span class="token operator">=</span> <span class="token string">"http://service-provider/user/"</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>baseUrl<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p><code>LoadBalancerInterceptor</code>根据service名称，获取到了服务实例的ip和端口</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>有轮询和随机两种策略;<br>由<code>IRule</code>接口定义负载均衡的规则接口<br>有以下实现：</p><ul><li><code>com.netflix.loadbalancer.RoundRobinRule</code>轮询实现</li><li><code>com.netflix.loadbalancer.RandomRule</code>随机实现</li></ul><p>默认为轮询的方式;<br>修改负载均衡规则的配置入口需要在consumer的application.yml添加如下配置</p><pre class=" language-yml"><code class="language-yml"># 服务提供者名称service-provider:  ribbon:    # 修改负载均衡规则为随机的方式    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2022/01/03/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/03/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序</p><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><p><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</p><ul><li>缺点：开发，升级维护的成本高</li><li>好处：客户的体验度要好一些。对电脑的配置要求低</li></ul><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等</p><ul><li>缺点：用户的体验度较低，对电脑的配置要求高</li><li>好处：开发，升级维护的成本低</li></ul><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><ul><li>概述:计算机在通信的过程中通信双方都必须要遵守的规则，称之为网络通信协议<h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><ul><li>TCP通信协议<ul><li>传输控制协议;需要建立链接，连接建立成功之后才可以通信</li><li>特点：<br>需要建立连接，传输数据安全。效率低</li></ul></li><li>UDP通信协议<ul><li>数据报协议。不需要连理连接。数据不安全，数据有可能会丢失，效率高</li></ul></li><li>IP协议<ul><li>网络通信时，计算机的唯一标识</li></ul></li><li>http超文本传输协议<ul><li>信息是明文传输;连接无状态,端口号80;基于tcp协议</li></ul></li><li>https具有安全性的ssl加密传输协议<ul><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全;端口号443</li></ul></li><li>SSL协议:安全套接层协议<ul><li>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持</li><li>SSL通过互相认证、使用数字签名确保完整性、使用加密确保机密性，以实现客户端和服务器之间的安全通讯</li><li>该协议由两层组成：SSL记录协议和SSL握手协议</li><li>SSL协议提供的服务：<ol><li>认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>加密数据以防止数据中途被窃取</li><li>维护数据的完整性，确保数据在传输过程中不被改变</li></ol></li></ul></li></ul></li></ul><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><ul><li>计算机网络体系结构划分为七层</li><li>自下而上为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<ol><li>物理层：硬件设备<br>以太网 · 光纤 · 电缆 等</li><li>数据链路层：<br>Wi-Fi(IEEE 802.11) · 令牌环 · 以太网 等</li><li>网络层协议：<br>IP (IPv4 · IPv6) 等</li><li>传输层协议：<br>TCP · UDP 等</li><li>应用层协议：<br>DHCP · DNS · FTP · HTTP · SSH 等</li></ol></li></ul><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul><li>应用软件在服务器中的唯一标识。用两个字节表示的整数，取值范围是0~65535。但0-1024的字节被系统占用，不能使用</li><li>常见端口号<ul><li>mysql：3306</li><li>http：80</li><li>tomcat：8080</li><li>https:443</li></ul></li></ul><h2 id="TCP通信协议"><a href="#TCP通信协议" class="headerlink" title="TCP通信协议"></a>TCP通信协议</h2><ul><li>概述  TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）</li><li>在Java中，提供了两个类用于实现TCP通信程序<ul><li>客户端：<code>java.net.Socket</code> 类</li><li>服务端：<code>java.net.ServerSocket</code>类</li></ul></li><li>在Java中,用于通信程序数据传递的类<ul><li><code>socket.getInputStream()</code>输入流(读取)</li><li><code>socket.getOutputStream()</code>输出流(写入)</li></ul></li></ul><h2 id="静态资源与动态资源"><a href="#静态资源与动态资源" class="headerlink" title="静态资源与动态资源"></a>静态资源与动态资源</h2><ul><li>静态资源<br>前端的固定页面，这里包含HTML、CSS、JS、图片等，不需要查数据库也不需要请求处理，直接就能够显示的页面，如果想修改内容则必须修改页面，但是访问效率相当高</li><li>动态资源<br>需要程序处理或者从数据库中读数据，能够根据不同的条件在页面显示不同的数据，内容更新不需要修改页面但是访问速度不及静态页面<br>servlet jsp asp html(Ajax)</li></ul><h2 id="案例-模拟tomcat服务器–半成品简易版"><a href="#案例-模拟tomcat服务器–半成品简易版" class="headerlink" title="案例(模拟tomcat服务器–半成品简易版)"></a>案例(模拟tomcat服务器–半成品简易版)</h2><pre class=" language-Java"><code class="language-Java">public class Server &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket serverSocket = new ServerSocket(8850);        while (true) &#123;            try &#123;                //  监听客户端连接                Socket socket = serverSocket.accept();                InputStream socketInputStream = socket.getInputStream();                //  把网络字节输入流转换为字符流                BufferedReader br = new BufferedReader(new InputStreamReader(socketInputStream));                //  读取第一行                String line = br.readLine();                //  截取出访问的路径                String path = line.split(" ")[1].substring(1);      // day15/reg.html                //  获取网络字节输出流                OutputStream socketOutputStream = socket.getOutputStream();                //  先把http的协议头回写给客户端                socketOutputStream.write("HTTP/1.1 200 OK\r\n".getBytes());                socketOutputStream.write("ConTent-Type:text/html\r\n".getBytes());                socketOutputStream.write("\r\n".getBytes());                //  读取浏览器请求的文件                FileInputStream fileInputStream = new FileInputStream("day3/web/"+path);                byte[] bytes = new byte[1024];                int len;                //  将文件写回给浏览器                while ((len = fileInputStream.read(bytes)) != -1) &#123;                    socketOutputStream.write(bytes, 0, len);                &#125;                //  释放资源                fileInputStream.close();                socket.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2021/12/31/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%9E%9A%E4%B8%BE/"/>
      <url>/2021/12/31/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/29/%E5%85%B6%E5%AE%83/hello-world/"/>
      <url>/2021/12/29/%E5%85%B6%E5%AE%83/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 面试题</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li>查询中不使用select * 的原因<br>增加查询分析器解析成本。</li></ol><p>增减字段容易与 resultMap 配置不一致。<br>不需要的列会增加数据传输时间和网络开销<br>对于无用的大字段，如 varchar、blob、text，会增加 io 操作<br>失去MySQL优化器“覆盖索引”策略优化的可能性<br>2. 主键ID生成方案<br>主键id的生成方案<br>数据库中主键id的生成方案，主要有三种<br>数据库自增ID<br>采用随机数生成不重复的ID<br>采用jdk提供的uuid</p><p>主键id性能排列<br>自增ID &gt; 雪花算法生成的ID &gt;uuid生成的ID。</p><p>实际使用<br>在实际使用过程中，推荐使用主键自增ID和雪花算法生成的随机ID。</p><ol start="3"><li>联合索引的优势<br>减少开销<br>覆盖索引<br>效率高</li><li>索引是建的越多越好吗<br>数据量小的表不需要建立索引，建立会增加额外的索引开销</li></ol><p>不经常引用的列不要建立索引，因为不常用，即使建立了索引也没有多大意义</p><p>经常频繁更新的列不要建立索引，因为肯定会影响插入或更新的效率</p><p>数据重复且分布平均的字段，因此他建立索引就没有太大的效果（例如性别字段，只有男女，不适合建立索引）</p><p>数据变更需要维护索引，意味着索引越多维护成本越高。</p><ol start="5"><li><p>什么情况下考虑分库分表？<br>不管是IO瓶颈还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载的活跃连接数的阈值。在业务service来看， 就是可用数据库连接少甚至无连接可用，接下来就可以想象了（并发量、吞吐量、崩溃）。<br>IO瓶颈<br>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询会产生大量的IO，降低查询速度-&gt;分库和垂直分表<br>第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt;分库<br>CPU瓶颈<br>第一种：SQl问题：如SQL中包含join,group by, order by，非索引字段条件查询等，增加CPU运算的操作-&gt;SQL优化，建立合适的索引，在业务Service层进行业务计算。<br>第二种：单表数据量太大，查询时扫描的行太多，SQl效率低，增加CPU运算的操作。-&gt;水平分表。<br>能不分就不分<br>数据量过大，正常运维影响业务访问<br>随着业务发展，需要对某些字段垂直拆分<br>数据量快速增长</p></li><li><p>分库分表带来的问题<br>事务一致性问题<br>分布式事务<br>当更新内容同时存在于不同库找那个，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用“XA协议”和“两阶段提交”处理。分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间，导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。<br>最终一致性<br>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误立刻回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等。<br>跨节点关联查询join问题<br>切分之前，系统中很多列表和详情表的数据可以通过join来完成，但是切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。解决的一些方法：<br>全局表<br>全局表，也可看做“数据字典表”，就是系统中所有模块都可能依赖的一些表，为了避免库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少修改，所以不必担心一致性的问题。<br>字段冗余<br>一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。例如，订单表在保存userId的时候，也将userName也冗余的保存一份，这样查询订单详情顺表就可以查到用户名userName，就不用查询买家user表了。但这种方法适用场景也有限，比较适用依赖字段比较少的情况，而冗余字段的一致性也较难保证。<br>数据组装<br>在系统service业务层面，分两次查询，第一次查询的结果集找出关联的数据id，然后根据id发起器二次请求得到关联数据，最后将获得的结果进行字段组装。这是比较常用的方法。<br>ER分片<br>关系型数据库中，如果已经确定了表之间的关联关系（如订单表和订单详情表），并且将那些存在关联关系的表记录存放在同一个分片上，那么就能较好地避免跨分片join的问题，可以在一个分片内进行join。在1:1或1：n的情况下，通常按照主表的ID进行主键切分。<br>跨节点分页、排序、函数问题<br>跨节点多库进行查询时，会出现limit分页、order by 排序等问题。分页需要按照指定字段进行排序，当排序字段就是分页字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂.需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户 </p></li><li><p>delete和truncate的区别</p></li></ol><ol start="8"><li>delete，drop，truncate 都有删除表的作用，区别在于：</li><li>delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。</li><li>delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。</li><li>执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。</li></ol><p> where和having的区别？（！！）<br>where是对分组前的条件进行限定。having是对分组后的内容进行限定。<br>where后面不能加聚合函数，having后可以跟聚合函数。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 设计规范</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h1><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li>数据库名称必须使用<code>小写字母并用下划线分割</code>。</li><li>数据库名称<code>禁止使用 MySQL 保留关键字</code>(如果表名中包含关键字查询时，需要将其用单引号括起来)。</li><li>数据库名称的命名要能做到<code>见名知意</code>，并且<code>不要超过 32 个字符</code>。</li><li><code>临时库表必须以 tmp 为前缀并以日期为后缀</code>，<code>备份表必须以 bak 为前缀并以日期 (时间戳) 为后缀</code>。</li><li><code>存储相同数据的列名和列类型必须一致</code>(一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低)</li></ul><h2 id="基本设计规范"><a href="#基本设计规范" class="headerlink" title="基本设计规范"></a>基本设计规范</h2><ol><li>表必须使用 InnoDB 存储引擎<ul><li>没有特殊要求(即 InnoDB 无法满足的功能如：列存储，存储空间数据等)的情况下;表必须使用 InnoDB 存储引擎;因为InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</li></ul></li><li>数据库和表的字符集统一使用 UTF8MB4<ul><li>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</li></ul></li><li>表和字段都需要添加注释<ul><li>使用 comment 从句添加表和列的备注 从一开始就进行数据字典的维护</li></ul></li><li>控制单表数据量的大小，建议控制在 500 万以内<ul><li>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题，可以用历史数据归档(应用于日志数据)，分库分表(应用于业务数据)等手段来控制数据量大小</li></ul></li><li>谨慎使用 MySQL 分区表<ul><li>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据。</li></ul></li><li>尽量做到冷热数据分离，减小表的宽度<ul><li>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节 减少磁盘 IO，保证热数据的内存缓存命中率(表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO) 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中(避免更多的关联操作)</li></ul></li><li>禁止在表中建立预留字段<ul><li>预留字段很难做到见名识义,无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定</li></ul></li><li>禁止在数据库中存储图片，文件等大的二进制数据;<ul><li>应该设置独立的图片服务器和文件服务器进行存放，数据库只存储文件和图片的地址信息</li></ul></li><li>禁止在线上做数据库压力测试</li><li>禁止从开发环境，测试环境直接连接生成环境数据库</li></ol><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><ol><li>优先选择符合存储需要的最小的数据类型<ul><li>列的字段越大，建立索引时所需要的空间也就越大，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差</li><li>常用方式<ul><li>将字符串转换成数字类型存储<br>IP 地址的存取<br>  inet_aton 把 ip 转为无符号整型 (4-8 位)<br>  inet_ntoa 把整型的 ip 转为地址 插入数据前，先用 inet_aton 把 IP 地址转为整型，可以节省空间。显示数据时，使用 inet_ntoa 把整型的 IP 地址转为地址显示即可。</li><li>对于非负型的数据(如自增 ID、整型 IP)来说，优先使用无符号整型来存储，无符号相对于有符号可以多出一倍的存储空间<br>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295<br>VARCHAR (N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字 Varchar (255)=765 个字节。过大的长度会消耗更多的内存</li></ul></li></ul></li><li>避免使用 TEXT、BLOB 数据类型<ul><li>把 BLOB 或是 TEXT 列分离到单独的扩展表中</li><li>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行</li><li>而且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能变得很差 ; 如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询</li><li>TEXT 或 BLOB 类型只能使用前缀索引 ; 因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</li></ul></li><li>避免使用 ENUM 类型<ul><li>修改 ENUM 值需要使用 ALTER 语句</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</li><li>禁止使用数值作为 ENUM 的枚举值</li></ul></li><li>尽可能把所有列定义为 NOT NULL<ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</li><li>进行比较和计算时要对 NULL 值做特别的处理</li></ul></li><li>使用 TIMESTAMP(4 个字节)或 DATETIME 类型(8 个字节)存储时间<ul><li>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</li><li>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高，超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储。</li><li>经常会有人用字符串存储日期型的数据(不正确的做法)：<ul><li>缺点 1：无法用日期函数进行计算和比较</li><li>缺点 2：用字符串存储日期要占用更多的空间</li></ul></li></ul></li><li>同财务相关的金额类数据必须使用 decimal 类型<ul><li>非精准浮点：float，double</li><li>精准浮点：decimal</li><li>Decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 bigint 更大的整型数据。</li></ul></li></ol><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><ol><li><p>限制每张表上的索引数量，建议单张表索引不超过 5 个</p><ul><li>索引并不是越多越好！索引可以提高效率同样也可以降低效率；索引可以增加查询效率，但同样也会降低插入和更新的效- 率，甚至有些情况下会降低查询效率。</li><li>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能</li></ul></li><li><p>禁止给表中的每一列都建立单独的索引</p><ul><li>5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</li></ul></li><li><p>每个 InnoDB 表必须有个主键</p><ul><li>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种; InnoDB 是按照主键索引的顺序来组织表的。</li><li>不要使用更新频繁的列作为主键，不适用多列主键(相当于联合索引) 不要使用 UUID、MD5、HASH、字符串列作为主键(无法保证数据的顺序增长)。主键建议使用自增 ID 值。</li></ul></li></ol><h2 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h2><ol><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段。<br>并不要将符合 1 和 2 中的字段的列都建立一个索引，通常将 1、2 中的字段建立联合索引效果更好。<br>多表 JOIN 的关联列</li></ol><h2 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h2><ol><li>建立索引的目的是：</li></ol><ul><li>希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</li><li>区分度最高的放在联合索引的最左侧(区分度 = 列中不同值的数量 / 列的总行数)。</li><li>尽量把字段长度小的列放在联合索引的最左侧(因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好)。</li><li>使用最频繁的列放到联合索引的左侧(这样可以比较少的建立一些索引)。</li></ul><ol start="2"><li>避免建立冗余索引和重复索引</li></ol><ul><li>因为这样会增加查询优化器生成执行计划的时间。</li><li>重复索引示例：primary key (id)、index (id)、unique index (id)</li><li>冗余索引示例：index (a,b,c)、index (a,b)、index (a)</li></ul><ol start="3"><li>优先考虑覆盖索引</li></ol><ul><li>对于频繁的查询优先考虑使用覆盖索引。</li><li>覆盖索引</li><li>就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引</li><li>覆盖索引的好处：<ul><li>避免 InnoDB 表进行索引的二次查询</li><li>InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li>可以把随机 IO 变成顺序 IO 加快查询效率</li><li>由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul></li></ul><ol start="4"><li>索引 SET 规范<ul><li>尽量避免使用外键约束。</li><li>不建议使用外键约束(foreign key)，但一定要在表与表之间的关联键上建立索引。</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现。</li><li>外键会影响父表和子表的写操作从而降低性能。</li></ul></li></ol><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><ol><li><p>建议使用预编译语句进行数据库操作</p><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</li></ul></li><li><p>避免数据类型的隐式转换</p><ul><li>隐式转换会导致索引失效。如：<code>select name,phone from customer where id = &#39;111&#39;;</code></li></ul></li><li><p>充分利用表上已经存在的索引</p></li><li><p>避免使用双 % 号的查询条件。</p><ul><li>如 a like ‘%123%’，(如果无前置 %，只有后置 %，是可以用到列上的索引的)</li></ul></li><li><p>一个 SQL 只能利用到复合索引中的一列进行范围查询</p><ul><li>如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到，在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。</li></ul></li><li><p>使用 left join 或 not exists 来优化 not in 操作， 因为 not in 也通常会使用索引失效。</p></li><li><p>数据库设计时，应该要对以后扩展进行考虑</p></li><li><p>程序连接不同的数据库使用不同的账号，禁止跨库查询</p><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul></li><li><p>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</p><ul><li>消耗更多的 CPU 和 IO 以网络带宽资源</li><li>无法使用覆盖索引</li><li>可减少表结构变更带来的影响</li></ul></li><li><p>禁止使用不含字段列表的 INSERT 语句</p><ul><li>如：<code>insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</code></li><li>应使用：<code>insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</code></li></ul></li><li><p>避免使用子查询，可以把子查询优化为 JOIN 操作</p><ul><li>通常子查询在 in 子句中，且子查询中为简单 SQL (不包含 union、group by、order by、limit 从句) 时，才可以把子查询转化为关联查询进行优化。</li><li>子查询性能差的原因：</li><li> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li><li>特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li><li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li></ul></li><li><p>避免使用 JOIN 关联太多的表<br>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。<br>在 MySQL 中，对于同一个 SQL 多关联(join)一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。<br>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。<br>同时对于关联操作来说，会产生临时表操作，影响查询效率 MySQL 最多允许关联 61 个表，建议不超过 5 个。</p></li><li><p>减少同数据库的交互次数</p><ul><li>数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率</li></ul></li><li><p>对应同一列进行 or 判断时，使用 in 代替 or</p><ul><li>In 的值不要超过 500 个， in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</li></ul></li><li><p>禁止使用 order by rand () 进行随机排序</p><ul><li>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</li><li>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</li></ul></li><li><p>WHERE 从句中禁止对列进行函数转换和计算</p><ul><li>对列进行函数转换或计算时会导致无法使用索引。<ul><li>不推荐<code>where date(create_time)=&#39;20190101&#39;</code></li><li>推荐<code>where create_time &gt;= &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</code></li></ul></li></ul></li><li><p>在明显不会有重复值时使用 UNION ALL 而不是 UNION</p><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作。</li><li>UNION ALL 不会再对结果集进行去重操作。</li></ul></li><li><p>拆分复杂的大 SQL 为多个小 SQL</p><ul><li>大 SQL：逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL 。</li><li>MySQL：一个 SQL 只能使用一个 CPU 进行计算。</li><li>SQL 拆分后可以通过并行执行来提高处理效率。</li></ul></li></ol><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><ol><li>超 100 万行的批量写(UPDATE、DELETE、INSERT)操作，要分批多次进行操作<br>大批量操作可能会造成严重的主从延迟<br>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况<br>Binlog 日志为 row 格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</li></ol><p>避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</p><ol start="2"><li><p>对于大表使用 pt-online-schema-change 修改表结构<br>避免大表修改产生的主从延迟<br>避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉，把原来一个 DDL 操作，分解成多个小的批次进行。</p></li><li><p>禁止为程序使用的账号赋予 super 权限</p><ul><li>当达到最大连接数限制时，还运行 1 个 有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账号使用。</li></ul></li><li><p>对于程序连接数据库账号，遵循权限最小原则</p><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库 程序使用的账号原则上不准有 drop 权限。</li></ul></li></ol><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol><li><p>避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p></li><li><p>避免在 where 子句中对字段进行 null 值判断</p></li><li><p>避免在 where 子句中使用 != 或 &lt;&gt; 操作符。MySQL 只有对以下操作符才使用索引：<code>&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的 like</code></p></li><li><p>避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用 union 合并查询:<code>select id from t where num=10 union all select id from t where num=20</code></p></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描。对于连续的数值，能用 between 就不要用 in:<code>select id from t where num between 1 and 3</code></p></li><li><p>模糊查询的使用区别：</p><ul><li><code>select id from t where name like &#39;%abc%&#39;</code> 或<code>select id from t where name like &#39;%abc&#39;</code>会导致全表扫描</li><li>而<code>select id from t where name like &#39;abc%&#39;</code>才用到索引</li></ul></li><li><p>在 where 子句中使用参数，也会导致全表扫描</p></li><li><p>避免在 where 子句中对字段进行<font color="red">表达式操作</font>，避免在 where 子句中对字段进行<font color="red">函数操作</font></p></li><li><p>很多时候用 exists 代替 in 是一个好的选择:select num from a where num in(select num from b)</p><ul><li>使用:<code>select num from a where exists(select 1 from b where num=a.num)</code>替换</li></ul></li><li><p>索引提高相应的 select 的效率，同时也降低了 insert 及 update 的效率;因为 insert 或 update 时有可能会重建索引 ; 所以一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要</p></li><li><p>应尽可能的避免更新 clustered(聚合) 索引数据列， 因为 clustered(聚合) 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销</p></li><li><p>尽可能的使用 varchar, nvarchar 代替 char, nchar。因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些</p></li><li><p>不要使用返回所有：<code>select * from t</code>，用具体的字段列表代替 “*”，不要返回用不到的任何字段</p></li><li><p>避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理</p></li><li><p>使用表的别名(Alias)：</p><ul><li>当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个 Column 上。这样一来，就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误</li></ul></li><li><p>使用“临时表”暂存中间结果</p><ul><li>简化 SQL 语句的重要方法就是采用临时表暂存中间结果。但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在 tempdb 中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能</li></ul></li><li><p>SQL 查询语句应加上 nolock，读、写是会相互阻塞的，为了提高并发性能。对于一些查询，可以加上 nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据</p><ul><li>使用 nolock 原则：<ul><li>查询的结果用于“插、删、改”的不能加 nolock；</li><li>查询的表属于频繁发生页分裂的，慎用 nolock ；</li><li>使用临时表一样可以保存“数据前影”，起到类似 Oracle 的 undo 表空间的功能，能采用临时表提高并发性能的，不要用 nolock</li></ul></li></ul></li><li><p>常见的简化规则</p><ul><li>不要有超过 5 个以上的表连接(join)，考虑使用临时表或表变量存放中间结果</li><li>少用子查询，视图嵌套不要过深，一般视图嵌套不要超过 2 个为宜</li></ul></li><li><p>将需要查询的结果预先计算好放在表中，查询的时候再select ; 这在SQL7.0以前是最重要的手段，例如医院的住院费计算</p></li><li><p>用 or 的字句可以分解成多个查询，并且通过 union 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 union all 执行的效率更高。多个 or 的字句没有用到索引，改写成 union 的形式再试图与索引匹配。一个关键的问题是否用到索引</p></li><li><p>在 in 后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数</p></li><li><p>将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程</p><ul><li>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的 sql 语句，是控制流语言的集合，速度当然快。反复执行的动态 SQL，可以使用临时存储过程，该过程(临时表)被放在 Tempdb 中。</li></ul></li><li><p>当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用配制线程数量&lt; 最大连接数，启用 sql server 的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能</p></li><li><p>查询的关联同写的顺序 :</p><ul><li><code>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = &#39;JCNPRH39681&#39; (A = B, B = &#39;号码&#39;) select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = &#39;JCNPRH39681&#39; and b.referenceid = &#39;JCNPRH39681&#39; (A = B, B = &#39;号码&#39;, A = &#39;号码&#39;) select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = &#39;JCNPRH39681&#39; and a.personMemberID = &#39;JCNPRH39681&#39; (B = &#39;号码&#39;, A = &#39;号码&#39;)</code></li></ul></li><li><p>使用 exists 代替 select count(1) 来判断是否存在记录</p></li><li><p>尽量使用 “&gt;=”，不要使用 “&gt;”</p></li><li><p>索引的使用规范</p><ul><li>索引的创建要与应用结合考虑，建议大的 oltp 表不超过 6 个索引</li><li>尽可能的使用索引字段作为查询条件，尤其是聚合索引，必要时可以通过 index index_name 来强制指定索引;避免对大表查询时进行 table scan，必要时考虑新建索引;</li><li>在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用;</li><li>要注意索引的维护，周期性重建索引，重新编译存储过程</li></ul></li><li><p>当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新</p></li><li><p>在所有的存储过程中，能够用 SQL 语句的，绝不用循环去实现</p></li><li><p>提高 group by 语句的效率，可以通过将不需要的记录在 group by 之前过滤掉。下面两个查询返回相同结果，但第二个快很多</p><ul><li>低效:<code>SELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING JOB = &#39;PRESIDENT&#39; OR JOB = &#39;MANAGER&#39;</code></li><li>高效:<code>SELECT JOB, AVG(SAL) FROM EMPWHERE JOB = &#39;PRESIDENT&#39; OR JOB = &#39;MANAGER&#39; GROUP BY JOB</code></li></ul></li><li><p>SQL语句的书写规范</p><ul><li>所有表名，列名全部小写</li><li>关键字，内置函数名全部大写</li></ul></li><li><p>别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快 1.5 倍</p></li><li><p>避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，<code>在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入</code></p></li><li><p>避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替。大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在 TempDb 数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢</p></li><li><p>最好不要使用触发器</p><ul><li>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程;如果能够使用约束实现的，尽量不要使用触发器;</li><li>不要为不同的触发事件(Insert、Update 和 Delete)使用相同的触发器;不要在触发器中使用事务型代码</li></ul></li><li><p>索引创建规则<br>表的主键、外键必须有索引；<br>数据量超过 300 的表应该有索引；<br>经常与其他表进行连接的表，在连接字段上应该建立索引；<br>经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引；<br>索引应该建在选择性高的字段上；<br>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；<br>正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>复合索引的几个字段是否经常同时以 AND 方式出现在 WHERE 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；<br>如果复合索引中包含的字段经常单独出现在 WHERE 子句中，则分解为多个单字段索引；<br>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；<br>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>频繁进行数据操作的表，不要建立太多的索引；<br>删除无用的索引，避免对执行计划造成负面影响；<br>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。<br>尽量不要对数据库中某个含有大量重复的值的字段建立索引</p></li><li><p>MySQL 查询优化总结<br>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。</p></li></ol><p>久而久之性能总会变化，避免在整个表上使用 count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用 GROUP BY 而不是 DISTINCT，在 WHERE、GROUP BY 和 ORDER BY 子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p><p>有时候 MySQL 会使用错误的索引，对于这种情况使用 USE INDEX，检查使用 SQL_MODE=STRICT 的问题，对于记录数小于5的索引字段，在 UNION 的时候使用LIMIT不是是用OR。</p><p>为了避免在更新前 SELECT，使用 INSERT ON DUPLICATE KEY 或者 INSERT IGNORE；不要用 UPDATE 去实现，不要使用 MAX；使用索引字段和 ORDER BY子句 LIMIT M，N 实际上可以减缓查询在某些情况下，有节制地使用，在 WHERE 子句中使用 UNION 代替子查询，在重新启动的 MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p><p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用 SHOW PROCESSLIST 查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询</p><ol start="39"><li>MySQL 备份过程<br>从二级复制服务器上进行备份；<br>在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；<br>彻底停止 MySQL，从数据库文件进行备份；<br>如果使用 MySQL dump 进行备份，请同时备份二进制日志文件 – 确保复制没有中断；<br>不要信任 LVM 快照，这很可能产生数据不一致，将来会给你带来麻烦；<br>为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。<br>当使用 mysqldump 时请使用 –opt；<br>在备份之前检查和优化表；<br>为了更快的进行导入，在导入时临时禁用外键约束。；<br>为了更快的进行导入，在导入时临时禁用唯一性检测；<br>在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；<br>通过自动调度脚本监控复制实例的错误和延迟；<br>定期执行备份。</li><li>查询缓冲并不自动处理空格，因此，在写 SQL 语句时，应尽量减少空格的使用，尤其是在 SQL 首和尾的空格(因为查询缓冲并不自动截取首尾空格)</li><li>我们应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的(推荐使用 UNSIGNED)，并设置上自动增加的 AUTO_INCREMENT 标志</li><li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON，在结束时设置 SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息</li><li>MySQL 查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多</li><li>EXPLAIN SELECT 查询用来跟踪查看效果<ul><li><strong><font color="red">使用 EXPLAIN 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</font></strong></li></ul></li><li>当只要一行数据时使用 LIMIT 1<ul><li> 当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</li><li> 在这种情况下，加上 LIMIT 1 可以增加性能。这样一来，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li></ul></li><li>选择表合适存储引擎<br>myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。<br>InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB 有效地降低删除和更新导致的锁定）。<br>对于支持事务的 InnoDB类 型的表来说，影响速度的主要原因是 AUTOCOMMIT 默认设置是打开的，而且程序没有显式调用 BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行 SQL 前调用 begin，多条 SQL 形成一个事物（即使 autocommit 打开也可以），将大大提高性能</li><li>优化表的数据类型，选择合适的数据类型<br>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免 NULL。</li></ol><p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint 就比 int 更合适) </p><p>比如时间字段：datetime 和 timestamp。datetime 占用8个字节，timestamp 占用4个字节，只用了一半。而 timestamp 表示的范围是 1970—2037 适合做更新时间。</p><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p><p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如：在定义邮政编码这个字段时，如果将其设置为 CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR 这种类型也是多余的，因为 CHAR(6) 就可以很好的完成任务了。</p><p>同样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段，应该尽量把字段设置为 NOT NULL，这样在将来执行查询的时候，数据库不用去比较 NULL 值。</p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL 中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能</p><ol start="51"><li><p>字符串数据类型：char, varchar, text 选择区别。</p></li><li><p>任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边</p></li><li><p>count(1) 和 count(*)  查询所有数据;count(1)效率更高</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E9%94%81/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>锁是计算机协调多个进程或线程并发访问某一资源的机制</li><li>锁保证数据并发访问的一致性、有效性</li><li>锁冲突也是影响数据库并发访问性能的一个重要因素</li><li>锁是Mysql在服务器层和存储引擎层的的并发控制</li></ul><h2 id="损耗"><a href="#损耗" class="headerlink" title="损耗"></a>损耗</h2><p>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等</p><p>锁机制<br>共享锁与排他锁<br>共享锁（读锁）：其他事务可以读，但不能写。<br>排他锁（写锁） ：其他事务不能读取，也不能写。<br>粒度锁<br>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p><p>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）<br>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁<br>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><p>不同粒度锁的比较：<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<br>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>最大程度的支持并发，同时也带来了最大的锁开销。<br>在 InnoDB 中，除单个 SQL 组成的事务外，<br>锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。<br>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>MyISAM 表锁<br>MyISAM表级锁模式：<br>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；<br>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 （This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.）。</p><p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p><p>可以设置改变读锁和写锁的优先级：</p><p>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。<br>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。<br>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。<br>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。<br>MyISAM加表锁方法：<br>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作<br>（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>MyISAM存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p><p>如果MyISAM表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用MyISAM表的INSERT和SELECT语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到MyISAM表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p><p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p><p>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。<br>查询表级锁争用情况：<br>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><p>mysql&gt; SHOW STATUS LIKE ‘Table%’;<br>+———————–+———+<br>| Variable_name | Value |<br>+———————–+———+<br>| Table_locks_immediate | 1151552 |<br>| Table_locks_waited | 15324 |<br>+———————–+———+<br>InnoDB行级锁和表级锁<br>InnoDB锁模式：<br>InnoDB 实现了以下两种类型的行锁：</p><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。<br>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。<br>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</p><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。<br>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。<br>锁模式的兼容情况：</p><p>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p><p>InnoDB加锁方法：<br>意向锁是 InnoDB 自动加的， 不需用户干预。<br>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；<br>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。<br>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</p><p>隐式锁定：<br>InnoDB在事务执行过程中，使用两阶段锁协议：</p><p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p><p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p><p>显式锁定 ：<br>select … lock in share mode //共享锁<br>select … for update //排他锁<br>select for update：</p><p>在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。</p><p>select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。</p><p>select lock in share mode ：in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。</p><p>性能影响：<br>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。<br>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p><p>for update 和 lock in share mode 的区别：</p><p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p><p>InnoDB 行锁实现方式：<br>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！<br>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。<br>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：MySQL索引总结）<br>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。<br>InnoDB的间隙锁：<br>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p>InnoDB使用间隙锁的目的：</p><p>防止幻读，以满足相关隔离级别的要求；<br>满足恢复和复制的需要：<br>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p><p>一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p><p>二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p><p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p><p>InnoDB 在不同隔离级别下的一致性读及锁的差异：<br>锁和多版本数据（MVCC）是 InnoDB 实现一致性读和 ISO/ANSI SQL92 隔离级别的手段。</p><p>因此，在不同的隔离级别下，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的：</p><p>对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。</p><p>因此， 我们在应用中， 应该尽量使用较低的隔离级别， 以减少锁争用的机率。实际上，通过优化事务逻辑，大部分应用使用 Read Commited 隔离级别就足够了。对于一些确实需要更高隔离级别的事务， 可以通过在程序中执行 SET SESSION TRANSACTION ISOLATION</p><p>LEVEL REPEATABLE READ 或 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE 动态改变隔离级别的方式满足需求。</p><p>获取 InnoDB 行锁争用情况：<br>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p><p>mysql&gt; show status like ‘innodb_row_lock%’;<br>+——————————-+——-+<br>| Variable_name | Value |<br>+——————————-+——-+<br>| InnoDB_row_lock_current_waits | 0 |<br>| InnoDB_row_lock_time | 0 |<br>| InnoDB_row_lock_time_avg | 0 |<br>| InnoDB_row_lock_time_max | 0 |<br>| InnoDB_row_lock_waits | 0 |<br>+——————————-+——-+<br>5 rows in set (0.01 sec)<br>LOCK TABLES 和 UNLOCK TABLES<br>Mysql也支持lock tables和unlock tables，这都是在服务器层（MySQL Server层）实现的，和存储引擎无关，它们有自己的用途，并不能替代事务处理。 （除了禁用了autocommint后可以使用，其他情况不建议使用）：</p><p>LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。<br>UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时，<br>或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁<br>LOCK TABLES语法：<br>在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；<br>事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；<br>COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁。<br>正确的方式见如下语句：<br>例如，如果需要写表 t1 并从表 t 读，可以按如下做：</p><p>SET AUTOCOMMIT=0;<br>LOCK TABLES t1 WRITE, t2 READ, …;<br>[do something with tables t1 and t2 here];<br>COMMIT;<br>UNLOCK TABLES;<br>使用LOCK TABLES的场景：<br>给表显示加表级锁（InnoDB表和MyISAM都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与MyISAM默认的表锁行为类似）</p><p>在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</p><p>其实，在MyISAM自动加锁（表锁）的情况下也大致如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个 订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检 查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：</p><p>Select sum(total) from orders;<br>Select sum(subtotal) from order_detail;<br>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，<br>order_detail 表可能已经发生了改变。因此，正确的方法应该是：</p><p>Lock tables orders read local, order_detail read local;<br>Select sum(total) from orders;<br>Select sum(subtotal) from order_detail;<br>Unlock tables;<br>（在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持“并发插入”））</p><p>死锁（Deadlock Free）<br>死锁产生：<br>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。<br>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。<br>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。<br>检测死锁：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。<br>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。<br>外部锁的死锁检测：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决<br>死锁影响性能：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。<br>MyISAM避免死锁：<br>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。<br>InnoDB避免死锁：<br>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。<br>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁<br>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会<br>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。<br>改变事务隔离级别<br>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><p>一些优化锁性能的建议<br>尽量使用较低的隔离级别；<br>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会<br>选择合理的事务大小，小事务发生锁冲突的几率也更小<br>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁<br>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会<br>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响<br>不要申请超过实际需要的锁级别<br>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作<br>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能<br>乐观锁、悲观锁<br>乐观锁(Optimistic Lock)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。<br>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p><p>悲观锁(Pessimistic Lock)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 约束</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E7%BA%A6%E6%9D%9F/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-约束"><a href="#MySQL-约束" class="headerlink" title="MySQL 约束"></a>MySQL 约束</h1><h2 id="数据库表的约束"><a href="#数据库表的约束" class="headerlink" title="数据库表的约束"></a>数据库表的约束</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对表中的数据进行限制，保证数据库的正确性，有效性和完成性。如果一个表添加了约束，不正确的数据将无法添加到表中。一般会在创建表的时候添加约束。<br>（约束会加在字段后面，对某一列的数据进行限制）</p><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>  非空：不能为空。   <code>not null</code></p><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>  唯一：数据唯一，不能重复。 <code>unique</code></p><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>  表的每一行都应该具有可以唯一标识自己的一列(或一组列);而这个承担标识作用的列称为主键<br>  非空+唯一(一个表中只能有一个主键) <code>primary key</code><br>  <strong>主键列的值不建议修改</strong><br>  主键可以在建表时声明;<br>  <code>auto_increment</code>  (自增，一般会和主键一起使用)</p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ul><li>用于关联父表</li><li>表中非主键的字段指向另一个表的主键,这个字段叫做外键;一个表中可以有多个外键</li></ul><h3 id="外键的作用"><a href="#外键的作用" class="headerlink" title="外键的作用"></a>外键的作用</h3><ul><li>外键所在的表为子表;指向的主键所在的表为父表;</li><li>对子表的作用:进行操作时,外键字段在父表中找不到对应的匹配,操作会失败</li><li>对父表的作用:进行修改删除时,对应的主键在子表中被引用,操作会失败</li></ul><h3 id="约束模式"><a href="#约束模式" class="headerlink" title="约束模式"></a>约束模式</h3><ul><li>district 严格模式(默认) 父表不能删除修改子表引用的数据</li><li>cascade 级联模式()  父表操作后,子表关联的数据一起操作</li><li>set null  置空模式  外键值允许为null,父表操作后,子表对应的外键字段被置空</li></ul><h3 id="使用外键的条件"><a href="#使用外键的条件" class="headerlink" title="使用外键的条件"></a>使用外键的条件</h3><ul><li>表存储引擎必须是InnoDB,否则创建的外键无约束效果</li><li>外键的类型必须和父表的主键类型一致</li><li>外键的名字不能重复</li><li>已存在数据的列设为外键时,必须和父表的主键数据对应</li></ul><h2 id="复合键-组合键"><a href="#复合键-组合键" class="headerlink" title="复合键(组合键)"></a>复合键(组合键)</h2><ul><li>将多个列作为一个索引键,一般用于复合索引</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>使用索引可快速访问数据表中的特定信息,索引是对数据表中一列或多列的值进行排序的一种结构</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>  <code>CREATE INDEX 索引名称 ON 表名 (字段名)</code></p><h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><p>  <code>ALTER table 表名 ADD INDEX 索引名(字段名)</code></p><h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><p>  <code>CREATE TABLE 表名(ID INT NOT NULL,username VARCHAR(16) NOT NULL,INDEX 索引名 (字段名(长度)));</code></p><h3 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h3><p>  <code>DROP INDEX 索引名 ON 表名; </code></p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>  unique<br>  索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一<br>  <code>CREATE UNIQUE INDEX 索引名 ON 表名(字段名(长度))</code></p><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>参照完整性要求关系中不允许引用不存在的实体,与实体完整性是关系型数据模型必须满足的完整性约束条件;目的是保证数据的唯一性</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 数据类型</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>  <strong>MySQL 中定义数据字段的类型对数据库的优化是非常重要的</strong><br>  MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="TINYINT"><a href="#TINYINT" class="headerlink" title="TINYINT"></a>TINYINT</h3><ul><li>占用空间  1 bytes</li><li>范围<ul><li>有符号  (-128，127)</li><li>无符号  (0，255)</li></ul></li><li>用途<strong>小整数值</strong><h3 id="SMALLINT"><a href="#SMALLINT" class="headerlink" title="SMALLINT"></a>SMALLINT</h3></li><li>占用空间  2 bytes</li><li>范围<ul><li>有符号  (-32 768，32 767)</li><li>无符号    (0，65 535)</li></ul></li><li>用途<strong>大整数值</strong><h3 id="MEDIUMINT"><a href="#MEDIUMINT" class="headerlink" title="MEDIUMINT"></a>MEDIUMINT</h3></li><li>占用空间  3 bytes</li><li>范围<ul><li>有符号  (-8 388 608，8 388 607)</li><li>无符号    (0，16 777 215)</li></ul></li><li>用途<strong>大整数值</strong><h3 id="INT或INTEGER"><a href="#INT或INTEGER" class="headerlink" title="INT或INTEGER"></a>INT或INTEGER</h3></li><li>占用空间  4 bytes</li><li>范围<ul><li>有符号  (-2 147 483 648，2 147 483 647)</li><li>无符号    (0，4 294 967 295)</li></ul></li><li>用途<strong>大整数值</strong><h3 id="BIGINT"><a href="#BIGINT" class="headerlink" title="BIGINT"></a>BIGINT</h3></li><li>占用空间  8 bytes</li><li>范围<ul><li>有符号  (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</li><li>无符号    (0，18 446 744 073 709 551 615)</li></ul></li><li>用途<strong>极大整数值</strong><h3 id="FLOAT"><a href="#FLOAT" class="headerlink" title="FLOAT"></a>FLOAT</h3></li><li>占用空间  4 bytes</li><li>范围<ul><li>有符号  (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</li><li>无符号    0，(1.175 494 351 E-38，3.402 823 466 E+38)</li></ul></li><li>用途<strong>单精度 浮点数值</strong><h3 id="DOUBLE"><a href="#DOUBLE" class="headerlink" title="DOUBLE"></a>DOUBLE</h3></li><li>占用空间  8 bytes</li><li>范围<ul><li>有符号  (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</li><li>无符号    0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</li></ul></li><li>用途<strong>双精度 浮点数值</strong><h3 id="DECIMAL"><a href="#DECIMAL" class="headerlink" title="DECIMAL"></a>DECIMAL</h3></li><li>占用空间  对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</li><li>范围<ul><li>有符号  依赖于M和D的值</li><li>无符号    依赖于M和D的值</li></ul></li><li>用途<strong>小数值</strong></li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><ul><li>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</li><li>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</li></ul><h3 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h3><ul><li>占用空间  3 bytes</li><li>范围  1000-01-01/9999-12-31</li><li>格式  YYYY-MM-DD</li><li>用途  <strong>日期值</strong><h3 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h3></li><li>占用空间  3 bytes</li><li>范围  ‘-838:59:59’/‘838:59:59’</li><li>格式  HH:MM:SS</li><li>用途  <strong>时间值或持续时间</strong><h3 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR"></a>YEAR</h3></li><li>占用空间  1 bytes</li><li>范围  1901/2155</li><li>格式  YYYY</li><li>用途  <strong>年份值</strong><h3 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h3></li><li>占用空间  8 bytes</li><li>范围  1000-01-01 00:00:00/9999-12-31 23:59:59</li><li>格式  YYYY-MM-DD HH:MM:SS</li><li>用途  <strong>混合日期和时间值</strong><h3 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h3></li><li>占用空间  4 bytes</li><li>范围  1970-01-01 00:00:00/2038<br>  结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</li><li>格式  YYYYMMDD HHMMSS</li><li>用途  <strong>混合日期和时间值，时间戳</strong></li></ul><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型</p><h3 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h3><ul><li>大小    0-255 bytes</li><li>用途  <strong>定长字符串</strong><h3 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h3></li><li>大小    0-65535 bytes</li><li>用途  <strong>变长字符串</strong><h3 id="TINYBLOB"><a href="#TINYBLOB" class="headerlink" title="TINYBLOB"></a>TINYBLOB</h3></li><li>大小    0-255 bytes</li><li>用途  <strong>不超过 255 个字符的二进制字符串</strong><h3 id="TINYTEXT"><a href="#TINYTEXT" class="headerlink" title="TINYTEXT"></a>TINYTEXT</h3></li><li>大小    0-255 bytes</li><li>用途  <strong>短文本字符串</strong><h3 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a>BLOB</h3></li><li>大小    0-65535 bytes</li><li>用途  <strong>二进制形式的长文本数据</strong><h3 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a>TEXT</h3></li><li>大小    0-65535 bytes</li><li>用途  <strong>长文本数据</strong><h3 id="MEDIUMBLOB"><a href="#MEDIUMBLOB" class="headerlink" title="MEDIUMBLOB"></a>MEDIUMBLOB</h3></li><li>大小    0-16777215 bytes</li><li>用途  <strong>二进制形式的中等长度文本数据</strong><h3 id="MEDIUMTEXT"><a href="#MEDIUMTEXT" class="headerlink" title="MEDIUMTEXT"></a>MEDIUMTEXT</h3></li><li>大小    0-16777215 bytes</li><li>用途  <strong>中等长度文本数据</strong><h3 id="LONGBLOB"><a href="#LONGBLOB" class="headerlink" title="LONGBLOB"></a>LONGBLOB</h3></li><li>大小    0-4294967295 bytes</li><li>用途  <strong>二进制形式的极大文本数据</strong><h3 id="LONGTEXT"><a href="#LONGTEXT" class="headerlink" title="LONGTEXT"></a>LONGTEXT</h3></li><li>大小    0-4294967295 bytes</li><li>用途  <strong>极大文本数据</strong></li></ul><p><strong><font color="red">注意：char(n) 和 varchar(n) 中括号中n代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 存储引擎</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>InnoDB存储引擎<br>InnoDB是事务型数据库的首选引擎，通过上图也看到了，InnoDB是目前MYSQL的默认事务型引擎，是目前最重要、使用最广泛的存储引擎。支持事务安全表（ACID），支持行锁定和外键。InnoDB主要特性有：</p><p>1、InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</p><p>2、InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</p><p>3、InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</p><p>4、InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</p><p>5、InnoDB被用在众多需要高性能的大型数据库站点上</p><p>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。</p><p>场景：由于其支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><p>MyISAM存储引擎<br>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物和外键。</p><p>MyISAM主要特性有：</p><p>1、大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</p><p>2、当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</p><p>3、每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</p><p>4、最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</p><p>5、BLOB和TEXT列可以被索引，支持FULLTEXT类型的索引，而InnoDB不支持这种类型的索引</p><p>6、NULL被允许在索引的列中，这个值占每个键的0~1个字节</p><p>7、所有数字键值以高字节优先被存储以允许一个更高的索引压缩</p><p>8、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</p><p>9、可以把数据文件和索引文件放在不同目录</p><p>10、每个字符列可以有不同的字符集</p><p>11、有VARCHAR的表可以固定或动态记录长度</p><p>12、VARCHAR和CHAR列可以多达64KB</p><p>存储格式：</p><p>1、静态表（默认）：字段都是非变长的（每个记录都是固定长度的）。存储非常迅速、容易缓存，出现故障容易恢复；占用空间通常比动态表多。</p><p>2、动态表：占用的空间相对较少，但是频繁的更新删除记录会产生碎片，需要定期执行optimize table或myisamchk -r命令来改善性能，而且出现故障的时候恢复比较困难。</p><p>3、压缩表：使用myisampack工具创建，占用非常小的磁盘空间。因为每个记录是被单独压缩的，所以只有非常小的访问开支。</p><p>静态表的数据在存储的时候会按照列的宽度定义补足空格，在返回数据给应用之前去掉这些空格。如果需要保存的内容后面本来就有空格，在返回结果的时候也会被去掉。（其实是数据类型char的行为，动态表中若有这个数据类型也同样会有这个问题）</p><p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）。</p><p>场景：如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。</p><p>MERGE存储引擎<br>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p><p>场景：对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p><p>MEMORY存储引擎<br>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。MEMORY主要特性有：</p><p>1、MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</p><p>2、MEMORY存储引擎执行HASH和BTREE缩影</p><p>3、可以在一个MEMORY表中有非唯一键值</p><p>4、MEMORY表使用一个固定的记录长度格式</p><p>5、MEMORY不支持BLOB或TEXT列</p><p>6、MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</p><p>7、MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）</p><p>8、MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</p><p>9、当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</p><p>MEMORY存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。现在mongodb、redis等NOSQL数据库愈发流行，MEMORY存储引擎的使用场景越来越少。</p><p>场景：如果需要该数据库中一个用于查询的临时表。</p><p>ARCHIVE存储引擎<br>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p><p>场景：由于高压缩和快速插入的特点Archive非常适合作为日志表的存储引擎，但是前提是不经常对该表进行查询操作。</p><p>CSV存储引擎<br>使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null。csv的编码转换需要格外注意。</p><p>场景：这种引擎支持从数据库中拷入/拷出CSV文件。如果从电子表格软件输出一个CSV文件，将其存放在MySQL服务器的数据目录中，服务器就能够马上读取相关的CSV文件。同样，如果写数据库到一个CSV表，外部程序也可以立刻读取它。在实现某种类型的日志记录时，CSV表作为一种数据交换格式，特别有用。</p><p>BLACKHOLE存储引擎（黑洞引擎）<br>该存储引擎支持事务，而且支持mvcc的行级锁，写入这种引擎表中的任何数据都会消失，主要用于做日志记录或同步归档的中继存储，这个存储引擎除非有特别目的，否则不适合使用。</p><p>场景：如果配置一主多从的话，多个从服务器会在主服务器上分别开启自己相对应的线程，执行binlogdump命令而且多个此类进程并不是共享的。为了避免因多个从服务器同时请求同样的事件而导致主机资源耗尽，可以单独建立一个伪的从服务器或者叫分发服务器。</p><p>PERFORMANCE_SCHEMA存储引擎<br>该引擎主要用于收集数据库服务器性能参数。这种引擎提供以下功能：提供进程等待的详细信息，包括锁、互斥变量、文件信息；保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断；对于新增和删除监控事件点都非常容易，并可以随意改变mysql服务器的监控周期，例如（CYCLE、MICROSECOND）。 MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表。</p><p>场景： DBA能够较明细得了解性能降低可能是由于哪些瓶颈。</p><p>Federated存储引擎<br>该存储引擎可以不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。这种存储引擎非常适合数据库分布式应用。</p><p>Federated存储引擎可以使你在本地数据库中访问远程数据库中的数据，针对federated存储引擎表的查询会被发送到远程数据库的表上执行，本地是不存储任何数据的。</p><p>缺点：</p><p>1.对本地虚拟表的结构修改，并不会修改远程表的结构</p><p>2.truncate 命令，会清除远程表数据</p><ol start="3"><li>drop命令只会删除虚拟表，并不会删除远程表</li></ol><p>4.不支持 alter table 命令</p><ol start="5"><li>select count(*), select * from limit M, N 等语句执行效率非常低，数据量较大时存在很严重的问题，但是按主键或索引列查询，则很快，如以下查询就非常慢（假设 id 为主索引）</li></ol><p>select id from db.tablea where id &gt;100 limit 10 ;</p><p>而以下查询就很快：</p><p>select id from db.tablea where id &gt;100 and id&lt;150</p><ol start="6"><li><p> 如果虚拟虚拟表中字段未建立索引，而实体表中为此字段建立了索引，此种情况下，性能也相当差。但是当给虚拟表建立索引后，性能恢复正常。</p></li><li><p>类似 where name like “str%” limit 1 的查询，即使在 name 列上创建了索引，也会导致查询过慢，是因为federated引擎会将所有满足条件的记录读取到本地，再进行 limit 处理。</p></li></ol><p>场景： dblink。</p><p>存储引擎的选择<br>功 能</p><p>MYISAM</p><p>Memory</p><p>InnoDB</p><p>Archive</p><p>存储限制</p><p>256TB</p><p>RAM</p><p>64TB</p><p>None</p><p>支持事物</p><p>No</p><p>No</p><p>Yes</p><p>No</p><p>支持全文索引</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>支持数索引</p><p>Yes</p><p>Yes</p><p>Yes</p><p>No</p><p>支持哈希索引</p><p>No</p><p>Yes</p><p>No</p><p>No</p><p>支持数据缓存</p><p>No</p><p>N/A</p><p>Yes</p><p>No</p><p>支持外键</p><p>No</p><p>No</p><p>Yes</p><p>No</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用语句</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="MySQL-服务"><a href="#MySQL-服务" class="headerlink" title="MySQL 服务"></a>MySQL 服务</h3><ul><li>启动服务<code>net start mysql</code></li><li>关闭服务<code>net stop mysql</code></li></ul><h3 id="查看-MySQL-内部设置的编码"><a href="#查看-MySQL-内部设置的编码" class="headerlink" title="查看 MySQL 内部设置的编码"></a>查看 MySQL 内部设置的编码</h3><ul><li><code>show variables like &#39;character%&#39;;</code></li></ul><h3 id="DOS-命令窗口操作数据乱码问题的解决"><a href="#DOS-命令窗口操作数据乱码问题的解决" class="headerlink" title="DOS 命令窗口操作数据乱码问题的解决"></a>DOS 命令窗口操作数据乱码问题的解决</h3><ul><li>修改 client、connection、results 的编码为 GBK，保证和 DOS 命令行编码保持一致 </li><li>同时设置三项:<code>set names gbk;</code></li><li>注意：退出 DOS 命令行就失效了，需要每次都配置</li></ul><h3 id="MySQL-连接服务端"><a href="#MySQL-连接服务端" class="headerlink" title="MySQL 连接服务端"></a>MySQL 连接服务端</h3><ul><li>本地连接<ul><li>方式一(密码可见)<code>mysql -u用户名 -p密码</code></li><li>方式二(密码不可见)<ul><li><code>mysql -u root -p</code></li><li>提示输入密码</li><li>输入密码+回车</li></ul></li></ul></li><li>远程连接<ul><li>方式一(密码可见)<code>mysql -h远程地址 -u用户名 -p密码</code></li><li>方式二(密码不可见)<ul><li><code>mysql -h远程地址 -u用户名 -p</code></li><li>提示输入密码</li><li>输入密码+回车</li></ul></li></ul></li></ul><h3 id="DOS命令窗口关闭连接"><a href="#DOS命令窗口关闭连接" class="headerlink" title="DOS命令窗口关闭连接"></a>DOS命令窗口关闭连接</h3><ul><li><code>quit</code> 或 <code>exit</code></li></ul><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li><code>create database 数据库名;</code></li><li>如果不存在则创建<code>create database if not exists 数据库名;</code></li><li>创建并指定字符集<code>create database 数据库名 character set 字符集;</code></li><li>不存在则新建数据库并指定字符集<code>CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET &#39;utf8mb4&#39;;</code></li></ul><h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><ul><li>查询全部数据库<code>show databases;</code></li><li>查询某个数据库的创建语句<code>show create database 数据库名;</code></li><li>查询正在使用的数据库<code>select database();</code></li></ul><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><ul><li>修改数据库的字符集<code>alter database 数据库名 character set 字符集;</code></li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li><code>drop database 数据库名;</code></li></ul><h3 id="使用数据库-切换数据库"><a href="#使用数据库-切换数据库" class="headerlink" title="使用数据库(切换数据库)"></a>使用数据库(切换数据库)</h3><ul><li><code>use 数据库名;</code></li></ul><hr><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul><li><code>CREATE TABLE 表名(字段名 字段类型);</code></li><li>指定表引擎和字符集并添加表注释<code>CREATE TABLE 表名(字段名 字段类型) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT = &#39;表注释&#39;;</code></li><li>不存在则新建<code>CREATE TABLE IF NOT EXISTS 表名(字段名 字段类型);</code></li><li>自增主键无符号并添加字段注释<code>CREATE TABLE IF NOT EXISTS 表名(id INT UNSIGNED AUTO_INCREMENT COMMENT &#39;编号&#39;,PRIMARY KEY(</code>id<code>));</code></li><li>非空字段<code>CREATE TABLE 表名(字段名 字段类型  NOT NULL);</code></li><li>总结<pre class=" language-SQL"><code class="language-SQL">    CREATE TABLE  IF NOT EXISTS `student` (    `id` INT UNSIGNED AUTO_INCREMENT COMMENT '学生编号',    `name` VARCHAR(15) NOT NULL COMMENT '学生姓名',    `grade` VARCHAR(5) NOT NULL COMMENT '学生班级',    `age` TINYINT(1) NOT NULL COMMENT '学生年龄',    `score` DOUBLE(3,1) NOT NULL COMMENT '学生成绩',    `start_date` DATE NOT NULL COMMENT '入学日期',    PRIMARY KEY(`id`)     )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT = '学生表';    -- IF NOT EXISTS      不存在时新建    -- UNSIGNED           无符号    -- AUTO_INCREMENT     自增    -- COMMENT            字段注释    -- PRIMARY KEY(`id`)  指定id为主键    -- ENGINE=InnoDB      引擎使用InnoDB    -- DEFAULT CHARSET    默认编码为utf8mb4    -- NOT NULL           非空</code></pre>  <font c olor="red">注意: varchar类型数据需要设置长度,double类型需要设置长度和精度</font></li><li>创建结构相同的表<code>create table 新表名 like 已存在表名;</code></li><li>创建带有复合主键的表<code>create table 表名(字段名 字段类型...,primary key(字段名,字段名2...));</code></li></ul><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ul><li>查看某个数据库的所有表<code>show tables;</code></li><li>查看表结构<code>desc 表名;</code></li><li>查看创建表的 SQL 语句<code>show create table 表名;</code></li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul><li><code>drop table 表名;</code></li><li>判断表是否存在，如果存在则删除表<code>drop table if exists 表名;</code></li></ul><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ul><li>修改表名<code>rename table 旧表名 to 新表名;</code></li><li>修改表的字符集<code>alter table 表名 character set 字符集;</code></li></ul><hr><h2 id="主键操作"><a href="#主键操作" class="headerlink" title="主键操作"></a>主键操作</h2><h3 id="表创建好之后添加主键："><a href="#表创建好之后添加主键：" class="headerlink" title="表创建好之后添加主键："></a>表创建好之后添加主键：</h3><ul><li><code>alter table 表名 add primary key(字段名);</code></li></ul><h3 id="删除主键："><a href="#删除主键：" class="headerlink" title="删除主键："></a>删除主键：</h3><ul><li><code>alter table 表名 drop primary key;</code></li></ul><hr><h2 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h2><h3 id="添加新的字段-列"><a href="#添加新的字段-列" class="headerlink" title="添加新的字段(列)"></a>添加新的字段(列)</h3><ul><li><code>alter table 表名 add 字段名 类型;</code></li></ul><h3 id="修改字段-列-类型"><a href="#修改字段-列-类型" class="headerlink" title="修改字段(列)类型"></a>修改字段(列)类型</h3><ul><li><code>alter table 表名 modify 字段名 新的类型;</code></li></ul><h3 id="修改字段-列-名"><a href="#修改字段-列-名" class="headerlink" title="修改字段(列)名"></a>修改字段(列)名</h3><ul><li><code>alter table 表名 change 旧字段名 新字段名 类型;</code></li></ul><h3 id="删除字段-列"><a href="#删除字段-列" class="headerlink" title="删除字段(列)"></a>删除字段(列)</h3><ul><li><code>alter table 表名 drop 字段名;</code></li></ul><hr><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><ul><li>插入部分字段<code>insert into 表名 (字段名1, 字段名2, 字段名3) values (值1, 值2, 值3);</code></li><li>插入多行数据<code>insert into 表名 (字段名1, 字段名2, 字段名3) values (值1, 值2, 值3),(值1,值2,值3);</code></li><li>蠕虫复制:将一张已经存在的表中的数据复制到另一张表中<ul><li>语法格式: 将表名 2 中的所有的字段(列)复制到表名 1 中<code>insert into 表名1 select * from 表名2;</code></li><li>只复制部分列<code>insert into 表名1 (字段1, 字段2) select 字段1, 字段2 from 表名2;</code></li></ul></li><li>添加数据返回自增的主键;在添加语句后执行:<code>select last_insert_id()</code><h2 id="更新表数据-修改"><a href="#更新表数据-修改" class="headerlink" title="更新表数据(修改)"></a>更新表数据(修改)</h2></li><li>不带条件修改数据<code>update 表名 set 字段名=值;</code> – 修改所有的行</li><li>带条件修改数据<code>update 表名 set 字段名=值 where 字段名=值;</code></li></ul><h2 id="更新某个日期字段为当前时间-now-函数"><a href="#更新某个日期字段为当前时间-now-函数" class="headerlink" title="更新某个日期字段为当前时间( now()函数 )"></a>更新某个日期字段为当前时间( now()函数 )</h2><ul><li> <code>update 表名 set 字段名 = now() where 条件</code></li></ul><h2 id="删除表数据"><a href="#删除表数据" class="headerlink" title="删除表数据"></a>删除表数据</h2><ul><li>不带条件删除数据<code>delete from 表名;</code>或<code>truncate table 表名;</code></li><li>带条件删除数据<code>delete from 表名 where 字段名=值;</code></li><li>truncate 和 delete 的区别：truncate 相当于删除表的结构，再创建一张表</li></ul><h2 id="查询表数据"><a href="#查询表数据" class="headerlink" title="查询表数据"></a>查询表数据</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li>查询指定字段<code>select 字段1,字段2... from 表名;</code>推荐</li><li>查询所有<code>select * from 表名;</code>影响性能</li></ul><h3 id="别名操作"><a href="#别名操作" class="headerlink" title="别名操作"></a>别名操作</h3><p>关键字: <code>as</code>可省略<br>优势： 显示的时候使用新的名字，并不修改表的结构,多个表时对性能有提高</p><ul><li>字段起别名<code>select 字段1 as 字段别名1,字段2 as 字段别名2... from 表名;</code></li><li>表起别名<code>select 字段名1,字段名2 from 表名 as 表别名;</code></li><li>字段和表起别名<code>select 字段名1 as 字段别名1, 字段字段名2 as 别名2...  from  表名 as 表别名;</code></li></ul><h3 id="清除重复结果"><a href="#清除重复结果" class="headerlink" title="清除重复结果"></a>清除重复结果</h3><ul><li>关键字:<code>distinct</code></li><li><code>select distinct 字段名 from 表名;</code></li></ul><h3 id="查询结果参与运算"><a href="#查询结果参与运算" class="headerlink" title="查询结果参与运算"></a>查询结果参与运算</h3><ul><li>字段数据和固定值运算<ul><li><code>select  字段1 + 固定值 from 表名;</code></li></ul></li><li>字段数据1和字段数据2参与运算<ul><li><code>select 字段名1 + 字段名2 from 表名;</code></li></ul></li></ul><h3 id="NULL值替换"><a href="#NULL值替换" class="headerlink" title="NULL值替换"></a>NULL值替换</h3><ul><li>coalesce(字段名,替换值,替换值)</li><li>IFNULL(字段名,替换值)</li><li>如果字段名对应的值不是NULL,返回值，否则返回替换值;类型为数字或字符串</li><li>例:<code>SELECT IFNULL(</code>mgr<code>,5) FROM </code>emp<code>WHERE</code>id<code>=7839;</code>若mgr的值不为null返回该值,否则返回5</li><li>例:<code>SELECT coalesce(</code>mgr<code>, &#39;总数&#39;) FROM </code>emp<code>WHERE</code>id<code>=7839;</code>若mgr的值不为null返回该值,否则返回总数</li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li>对记录进行过滤</li><li>格式:<code>select 字段 from 表名 where 条件;</code></li></ul><h4 id="条件使用比较运算符"><a href="#条件使用比较运算符" class="headerlink" title="条件使用比较运算符"></a>条件使用比较运算符</h4><ul><li>=  检测两个值是否相等，相等返回true;例:<code>select name from student where age = 22</code></li><li>!= 检测两个值是否相等，不相等返回true;例:<code>select name from student where age != 22</code></li><li>&gt; 检测左边的值是否大于右边的值, 若成立返回true;例:<code>select name from student where age &gt; 22</code></li><li>&lt;  检测左边的值是否小于右边的值, 若成立返回true;例:<code>select name from student where age &lt; 22</code></li><li>&gt;= 检测左边的值是否大于或等于右边的值, 若成立返回true;例:<code>select name from student where age &gt;= 22</code></li><li>&lt;= 检测左边的值是否小于或等于右边的值, 若成立返回true;例:<code>select name from student where age &lt;= 22</code><h4 id="条件使用逻辑运算符"><a href="#条件使用逻辑运算符" class="headerlink" title="条件使用逻辑运算符"></a>条件使用逻辑运算符</h4></li><li>and(与)    两个条件同时满足,例:<code>select name from student where age&gt;20 and name=&#39;王五&#39;;</code></li><li>or(或)    两个条件其中一个满足,例:<code>select name from student where age&gt;20 or name=&#39;王五&#39;;</code></li><li>not(非)    取反,例:<code>select name from student where age&gt;20 and not name=&#39;王五&#39;;</code><h4 id="范围-between-and-…"><a href="#范围-between-and-…" class="headerlink" title="范围 between .. and …"></a>范围 between .. and …</h4></li><li>关键字: 返回between ..  and …</li><li>..和…之间的所有数据;<font color="red">between后的值和and后的值都会包含</font><br><code>select name from student where score between 84  and 89;</code><h4 id="表示集合"><a href="#表示集合" class="headerlink" title="表示集合"></a>表示集合</h4></li><li>关键字:in()</li><li><font color="red">in()内部的值都会包含</font><br><code>select name from student where score in(83,89);</code><h4 id="模糊查询-like"><a href="#模糊查询-like" class="headerlink" title="模糊查询 like"></a>模糊查询 like</h4></li><li>通配符： <code>%</code>占位符，表示0个或多个;<code>_</code>占位符，表示一个<ul><li><code>select name from student where 字段 like &#39;%王%&#39;;</code></li><li><code>select name from student where 字段 like &#39;王_&#39;;</code><h4 id="非空判断"><a href="#非空判断" class="headerlink" title="非空判断"></a>非空判断</h4></li></ul></li><li><code>is null</code>  – 查询空的<ul><li><code>select name from student where 字段 is  null;</code></li></ul></li><li><code>is not null</code>  – 查询非空的<ul><li><code>select name from student where 字段 is not null;</code></li></ul></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>关键字:<code>order by</code>排序 <code>asc</code>升序和<code>desc</code>降序</li><li>语法：<ul><li>升序:<code>select 字段 from 表名  order by 字段 asc;</code></li><li>降序:<code>select 字段 from 表名  order by 字段 desc;</code></li></ul></li><li>组合排序：<ul><li>先根据第一个字段排序，如果第一个字段相同，再根据第二个字段排序，以此类推<ul><li><code>select 字段 from 表名 where 条件 order by 字段1 asc,字段2 desc</code></li></ul></li></ul></li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>数据库内置的一些函数，可以计算信息<font color="red">(聚合函数会忽略null)</font></li><li>函数: max最大值 min最小值 avg平均值 count统计个数 sum求和</li><li>语法：<code>select 聚合函数(字段名) from 表名;</code></li><li><code>count(*)</code>或<code>count(1)</code>返回总记录数</li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>关键字: <code>group by</code>用来分组 <code>having</code>用来筛选分组后的数据(条件) with rollup 在分组统计数据的基础上再统计汇总</li><li>语法: <code>select 字段 from 表名 where 条件  group by 分组字段 with rollup having 条件;</code></li><li>注意: <font color="red">若加上分组;查询的字段只能是聚合函数或者分组的字段</font></li><li>例:查询学生表以性别分组的 性别和平均成绩(成绩保留1位小数)<code>select sex,TRUNCATE (avg(score),1) from student group by sex;</code></li><li>分组后再使用条件筛选数据<code>select sex,TRUNCATE (avg(score),1) from student group by sex HAVING TRUNCATE (avg(score),1) &gt; 80;</code></li><li>分组统计数据的基础上再进行统计汇总<code>SELECT name, SUM(signin) as signin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</code></li><li>where和having的区别?(面试题)<ul><li>where是对分组前的条件进行限定。having是对分组后的内容进行限定</li><li>where后面不能加聚合函数，having后可以跟聚合函数</li></ul></li></ul><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul><li>关键字:<code>REGEXP</code></li><li>正则操作符<ul><li>&nbsp;&nbsp;&nbsp;&nbsp;^    匹配开始位置</li><li>&nbsp;&nbsp;&nbsp;&nbsp;$    匹配结束位置</li><li>&nbsp;&nbsp;&nbsp;&nbsp;.    匹配除 “\n” 之外的任何单个字符。要包括 ‘\n’ ，请使用’[.\n]’ 的模式</li><li>&nbsp;&nbsp;&nbsp;&nbsp;[…]    字符集合。匹配所包含的任意一个字符</li><li>&nbsp;&nbsp;&nbsp;&nbsp;[^…]    负值字符集合。匹配未包含的任意字符</li><li>&nbsp;&nbsp;&nbsp;&nbsp;p1|p2|p3    匹配 p1 或 p2 或 p3</li><li>&nbsp;&nbsp;&nbsp;&nbsp;*    匹配前面的子表达式零次或多次</li><li>&nbsp;&nbsp;&nbsp;&nbsp;+    匹配前面的子表达式一次或多次</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{n}    n 是一个非负整数。匹配确定的 n 次</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{n,m}    m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次</li></ul></li><li>例:<code>SELECT 字段名 FROM 表名 WHERE 要筛选的字段 REGEXP &#39;正则字符串&#39;;</code></li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul><li>关键字: <code>limit 开始索引,个数</code><strong>mysql的方言</strong>,只能在MySQL使用; 用来分页</li><li>公式: 开始的索引 = (页码-1) * 每页的个数</li><li>语法: <code>select 字段名 from student limit 开始索引,个数;</code></li></ul><h2 id="特殊查询"><a href="#特殊查询" class="headerlink" title="特殊查询"></a>特殊查询</h2><ol><li>根据班级分组，求出平均分最高的班级名称;    - 获取最大值思路:1分组,2排序:降序,3取出第一条数据<br>SELECT <code>grade</code>,AVG(<code>score</code>)<code>score</code> FROM <code>student</code> GROUP BY <code>grade</code>  ORDER BY <code>score</code> DESC LIMIT 0,1;<h2 id="多思路查询"><a href="#多思路查询" class="headerlink" title="多思路查询"></a>多思路查询</h2></li><li>查询product表中所有的电脑办公记录    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>category_name</code>=’电脑办公’;    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>category_name</code> in(‘电脑办公’);</li><li>查询价格为800商品    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> = 800;    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> in(800);</li><li>查询价格不是800的所有商品    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> != 800;    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> NOT IN(800);</li><li>查询商品价格在200到1000之间所有商品    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> BETWEEN  200 AND 1000;    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> &gt;=200 AND  <code>price</code>&lt;=1000;</li><li>查询商品价格是200或800或者2000的所有商品    - SELECT <code>id</code>,<code>name</code>,<code>price</code>,<code>category_name</code> FROM <code>product</code> WHERE <code>price</code> IN(200,800,2000);</li></ol><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h2 id="创建表时设置外键"><a href="#创建表时设置外键" class="headerlink" title="创建表时设置外键"></a>创建表时设置外键</h2><ul><li><code>create table 表名(字段名,字段类型...,primary key(主键名),constraint &#39;新建约束名&#39; foreign key (&#39;外键名&#39;) references 参照主键表名(&#39;主键名&#39;));</code></li></ul><h2 id="创建好的表添加外键约束"><a href="#创建好的表添加外键约束" class="headerlink" title="创建好的表添加外键约束"></a>创建好的表添加外键约束</h2><ul><li><code>alter table 表名 add constraimt 约束名称 foreign key(外键字段名) references 参照主键表名(主键字段名);</code></li></ul><h2 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h2><ul><li><code>alter table 表名 drop foreign key 外键名;</code></li></ul><h2 id="删除表里的重复记录"><a href="#删除表里的重复记录" class="headerlink" title="删除表里的重复记录"></a>删除表里的重复记录</h2><p><code>delete from 表名 where id not in( select min_id from(selectmin(id)as min_id from 表名 groupby name, sex, age )as x)</code></p><h2 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h2><p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</p><p> 两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</p><p>如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。</p><p>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</p><p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p><p>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；</p><p>Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。</p><p>可以在最后一个结果集中指定Order by子句改变排序方式。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用语句</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%85%B6%E5%AE%83/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库范式NF-规范"><a href="#数据库范式NF-规范" class="headerlink" title="数据库范式NF(规范)"></a>数据库范式NF(规范)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  满足一些规则来优化数据库的设计和存储，这些规则我们称为范式</p><h3 id="范式说明"><a href="#范式说明" class="headerlink" title="范式说明"></a>范式说明</h3><p>第一范式:</p><ul><li>(<strong>列原子性</strong>)数据库表的每列都是不可分割的原子数据项，而不能是集合，数组等非原子数据项<br>第二范式:</li><li>(<strong>列唯一性</strong>)在第一范式的基础上建立，要求数据库表中的每个实例或记录必须可以被唯一地区分;选取一个能区分每个实体的属性或属性组，作为实体的唯一标识<br>第三范式：</li><li>(<strong>列与非主键列之间不可存在耦合性</strong>)在第二范式的基础上建立，任何非主属性不依赖于其它非主属性<br>巴斯-科德范式（BCNF）</li><li>(<strong>列不能与主键列的子集产生依赖</strong>)在第一范式的基础上建立，任何非主属性不能对主键子集依赖</li></ul><h2 id="数据库备份和还原"><a href="#数据库备份和还原" class="headerlink" title="数据库备份和还原"></a>数据库备份和还原</h2><ol><li>概述<br>使用数据库存储数据时，可以给数据做一些备份，防止数据丢失或者出现错误</li><li>备份格式：<br><code>mysqldump -u用户名 -密码 数据库&gt;文件的路径;</code></li><li>还原格式：<br><code>use 数据库;</code><br><code>source 路径;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元);完整的业务需要批量的DML(insert、update、delete)语句共同联合完成</li><li>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同</li><li>事务是为数据安全操作提出的,用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行</li></ul><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul><li><strong>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务</strong></li><li><strong><font color="red">只在同一连接对象生效</font></strong></li></ul><h2 id="事务的特征-ACID"><a href="#事务的特征-ACID" class="headerlink" title="事务的特征(ACID)"></a>事务的特征(ACID)</h2><p>  事务必须服从ACID原则</p><ul><li>原子性(A)：<ul><li>事务是最小单位，不可再分</li></ul></li><li>一致性(C)：<ul><li>必须保证同时成功或者同时失败;数据库的完整性没有被破坏;不能有数据丢失的情况。</li></ul></li><li>隔离性(I)：<ul><li>消除事务间的相互影响;事务A和事务B之间具有隔离性</li></ul></li><li>持久性(D)：<ul><li>保证事务执行的结果在磁盘上永久的存储</li></ul></li></ul><h2 id="事务隔离性的后果"><a href="#事务隔离性的后果" class="headerlink" title="事务隔离性的后果"></a>事务隔离性的后果</h2><ol><li>脏读：事务获取到其它事务执行过程中的结果</li></ol><ul><li>解决方案：事务执行过程中获取不到其它事务执行过程中的结果。</li></ul><ol start="2"><li>不可重复读(修改操作导致)：事务执行过程中获取了其它事务不同的阶段的结果;</li></ol><ul><li>解决方案：事务在其它事务执行过程中开启，其它事务相对于该事务透明</li></ul><ol start="3"><li>幻读(插入或删除操作导致)：事务执行过程中获取到其它事务不同阶段的结果。</li></ol><ul><li>解决方案：间隙锁。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ol><li>读未提交：<code>read uncommitted</code><ul><li>事物A和事物B，事物A未提交的数据，事物B可以读取到;这里读取到的数据叫做<code>“脏数据”</code></li><li>这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别</li></ul></li><li>读已提交：<code>read committed</code><ul><li>事物A和事物B，事物A提交的数据，事物B才能读取到;这种隔离级别高于读未提交</li><li>换句话说，对方事物提交之后的数据，我当前事物才能读取到;这种级别可以避免“脏数据”;这种隔离级别会导致<code>“不可重复读取”</code></li><li>Oracle默认隔离级别</li></ul></li><li>可重复读：<code>repeatable read</code><ul><li>事务A和事务B，事务A提交之后的数据，事务B读取不到</li><li>事务B是可重复读取数据</li><li>这种隔离级别高于读已提交</li><li>换句话说，对方提交之后的数据，我还是读取不到</li><li>这种隔离级别可以避免“不可重复读取”，达到可重复读取</li><li>比如1点和2点读到数据是同一个</li><li>MySQL默认级别</li><li>虽然可以达到可重复读取，但是会导致“幻像读”</li></ul></li><li>串行化：<code>serializable</code>可序列化：事务变成串行处理<ul><li>事务A和事务B，事务A在操作数据库时，事务B只能排队等待</li><li>这种隔离级别很少使用，吞吐量太低，用户体验差</li><li>这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发<br><img src="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E4%BA%8B%E5%8A%A1/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png"><br>当前隔离级别：每次一个客户端连接服务器，服务器分配给它的隔离级别，修改时修改的是当前隔离级别。<br>全局隔离级别：数据库服务端默认的隔离级别(可重复读)，在配置文件中写的，数据库加载时直接读取配置文件</li></ul></li></ol><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>  在 MySQL 的默认设置下，事务是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作</p><ul><li>启用自动提交<br><code>SET AUTOCOMMIT=1</code></li><li>禁止自动提交<br>使用<code>BEGIN</code> 或 <code>START TRANSACTION</code> 或 <code>SET AUTOCOMMIT=0</code>用来禁止使用当前会话(连接)的自动提交</li><li>提交事务(执行操作)<br>使用<code>COMMIT</code> 或 <code>COMMIT WORK</code></li><li>回滚事务(撤销操作)<br>使用<code>ROLLBACK</code> 或 <code>ROLLBACK WORK</code>，回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>设置事务点<br><code>SAVEPOINT identifier</code>，<code>SAVEPOINT</code> 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li><li>删除事务点<br><code>RELEASE SAVEPOINT identifier</code> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>回滚到事务点<br><code>ROLLBACK TO identifier</code> 把事务回滚到标记点；</li><li>设置隔离级别<br><code>SET TRANSACTION</code>用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li></ul><h2 id="嵌套事务-子事务"><a href="#嵌套事务-子事务" class="headerlink" title="嵌套事务,子事务"></a>嵌套事务,子事务</h2><p>使用保留点 <code>SAVEPOINT</code></p><p>savepoint 是在数据库事务处理中实现“子事务”（subtransaction），也称为嵌套事务的方法<br>事务可以回滚到 savepoint 而不影响 savepoint 创建前的变化, 不需要放弃整个事务<br>ROLLBACK 回滚的用法可以设置保留点 SAVEPOINT，执行多条操作时，回滚到想要的那条语句之前</p><h3 id="使用-SAVEPOINT"><a href="#使用-SAVEPOINT" class="headerlink" title="使用 SAVEPOINT"></a>使用 SAVEPOINT</h3><p>SAVEPOINT 保留点名称;    // 声明一个 savepoint<br>ROLLBACK TO 保留点名称;  // 回滚到savepoint<br>删除 SAVEPOINT<br><code>保留点再事务处理完成（执行一条 ROLLBACK 或 COMMIT）后自动释放</code><br>MySQL5 以来，可以用:<br><code>RELEASE SAVEPOINT 保留点名称;</code>  – 删除指定保留点</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 多表</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%20%E5%A4%9A%E8%A1%A8/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%20%E5%A4%9A%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h1><h2 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h2><p>一对一：</p><ul><li>一般不用, 用一张表表示即可!<br>一对多：</li><li>在多的一方建立字段, 指向一的一方的主键<br>多对多：</li><li>如果两张表是多对多的关系，一般情况下会设置一张中间表，让中间表的两个字段分别去关联两张表的主键列</li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><strong>获取两个表中字段匹配关系的记录</strong><br>用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如：从表.外键=主表.主键</p><ol><li>隐式内连接：</li></ol><ul><li>没有 JOIN 关键字，条件使用 WHERE 指定<br>例:<pre class=" language-SQL"><code class="language-SQL">SELECT e.`id`,e.`ename`,e.`salary`,j.`jname`,j.`description` FROM  emp e,job j WHERE e.`job_id` = j.`id`</code></pre></li></ul><ol start="2"><li>显示内连接：</li></ol><ul><li>使用 <code>INNER JOIN ... ON</code> 语句, 可以省略 INNER 使用 <code>JOIN</code><br>例:<pre class=" language-SQL"><code class="language-SQL">SELECT e.`id`,e.`ename`,e.`salary`,j.`jname`,j.`description` FROM  emp e JOIN job j ON e.`job_id` = j.`id`</code></pre></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul><li>LEFT JOIN（左连接）：使用 <code>LEFT OUTER JOIN ... ON</code>，OUTER 可以省略<br><strong>获取左表所有记录，即使右表没有对应匹配的记录</strong><br>用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示 NULL<br>可以理解为：在内连接的基础上保证左表的数据全部显示<br>例:<pre class=" language-SQL"><code class="language-SQL">SELECT e.`id`,e.`ename`,e.`salary`,j.`jname`,j.`description` FROM  emp e LEFT JOIN job j ON e.`job_id` = j.`id`</code></pre></li><li>RIGHT JOIN（右连接）：右外连接：使用 RIGHT OUTER JOIN … ON，OUTER 可以省略<br><strong>与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录</strong><br>用右边表的记录去匹配左边表的记录，如果符合条件的则显示；否则，显示 NULL<br>可以理解为：在内连接的基础上保证右表的数据全部显示<br>例:<pre class=" language-SQL"><code class="language-SQL">SELECT e.`id`,e.`ename`,e.`salary`,j.`jname`,j.`description` FROM job j RIGHT JOIN   emp e ON e.`job_id` = j.`id`</code></pre></li></ul><h3 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h3><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><pre class=" language-SQL"><code class="language-SQL">SELECT `字段名1`,`字段名2`, ... `字段名n` FROM `表名1`where `条件`UNION [ALL | DISTINCT]SELECT `字段名1`,`字段名2`, ... `字段名n` FROM `表名2`where `条件`;-- DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。-- ALL: 可选，返回所有结果集，包含重复数据。</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>一个查询的结果做为另一个查询的条件</li><li>有查询的嵌套，内部的查询称为子查询</li><li>子查询要使用括号</li></ol><h4 id="子查询结果的三种情况："><a href="#子查询结果的三种情况：" class="headerlink" title="子查询结果的三种情况："></a>子查询结果的三种情况：</h4><ol><li>子查询的结果是单行单列(一个值)<ul><li>子查询结果只要是单行单列，肯定在 WHERE 后面作为条件，父查询使用：比较运算符，如：&gt; 、&lt;、&lt;&gt;、= 等</li></ul></li><li>子查询的结果是多行单列(一列值)<ul><li>子查询结果是多列，则在 FROM 后面作为表进行二次查询;结果集类似于一个数组，父查询使用 IN 运算符</li></ul></li><li>子查询的结果是多行多列(多行多列值)<ul><li>子查询结果只要是多列，肯定在 FROM 后面作为表;子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段</li></ul></li></ol><h2 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h2><p>可用来拼接语句<br>GROUP_CONCAT：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )<br>例:</p><pre class=" language-sql"><code class="language-sql">    <span class="token keyword">SELECT</span> sku_id  <span class="token punctuation">,</span> GROUP_CONCAT<span class="token punctuation">(</span>sale_attr_value_id  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sp<span class="token punctuation">.</span>base_sale_attr_id <span class="token keyword">ASC</span> SEPARATOR <span class="token string">'|'</span><span class="token punctuation">)</span> value_ids     <span class="token keyword">FROM</span>  <span class="token punctuation">`</span>sku_sale_attr_value<span class="token punctuation">`</span> sv     <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token punctuation">`</span>spu_sale_attr_value<span class="token punctuation">`</span> sp <span class="token keyword">on</span> sp<span class="token punctuation">.</span>id <span class="token operator">=</span> sv<span class="token punctuation">.</span>sale_attr_value_id     <span class="token keyword">WHERE</span> sv<span class="token punctuation">.</span>spu_id<span class="token operator">=</span><span class="token comment" spellcheck="true">#&amp;#123;spuId&amp;#125;</span>     <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sku_id</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 临时表</title>
      <link href="/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
      <url>/2021/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%20%E4%B8%B4%E6%97%B6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用来保存一些临时数据 ; 临时表在MySQL 3.23版本中添加</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>只在当前连接可见<br>使用 SHOW TABLES命令显示数据表列表时，无法看到 临时表</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>使用关键字<code>TEMPORARY</code></p><pre class=" language-SQL"><code class="language-SQL">CREATE TEMPORARY TABLE tmp_test_2012-03-12 (`id` INT UNIQUE PRIMARY key,`name` varchar(20),`age` TINYINT);</code></pre><p>用查询直接创建临时表：</p><pre class=" language-SQL"><code class="language-SQL">CREATE TEMPORARY TABLE 临时表名 AS (SELECT *  FROM 旧的表名 LIMIT 0,10000);</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>自动销毁: 关闭连接时，Mysql会自动删除表并释放空间<br>手动销毁: <code>drop table 表名</code></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Properties</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Properties/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Properties/</url>
      
        <content type="html"><![CDATA[<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java 语言的配置文件所使用的类</li><li>Xxx.properties 为Java 语言常见的配置文件，如数据库的配置 jdbc.properties, 系统参数配置 system.properties等</li><li>位于<code>java.util.Properties</code></li><li>继承了Hashtable 类，以Map 的形式进行放置值， put(key,value) get(key)</li><li>规则: 以key=value 的 键值对的形式进行存储值。 key值不能重复</li><li>这个类是线程安全的：多个线程可以共享一个Properties对象，而不需要外部同步</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>Xxx.properties文件内容案例<br>内容是key=value的形式,<font color="red">注意value后方不能存在空格;如果存在,读取在Java中的数据也会存在空格</font><pre class=" language-Poperties"><code class="language-Poperties">driver=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/db1?useUnicode=true&characterEncoding=utf-8username=rootpassword=root</code></pre></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>String getProperty(String key)<br>使用此属性列表中指定的键搜索属性</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">import java.io.IOException;import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Properties;//读取jdbc.properties配置文件public class ReadJdbcConfig &#123;    private static Properties properties;    //用Map集合存放properties文件下的配置信息    private static Map<String, String> configMap;    //配置文件只加载一次    static &#123;        properties = new Properties();        configMap = new HashMap<>();        InputStream inputStream = null;        try &#123;            inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("jdbc.properties");            properties.load(inputStream);            Enumeration en = properties.propertyNames();            while (en.hasMoreElements()) &#123;                String key = (String) en.nextElement();                String value = properties.getProperty(key);                configMap.put(key, value);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (inputStream != null) &#123;                try &#123;                    inputStream.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    //获取配置文件里面的value值    public static String getPropertyValue(String key) &#123;        return configMap.get(key);    &#125;&#125;</code></pre><h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建属性集对象</span>        Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加键值对元素</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"length"</span><span class="token punctuation">,</span> <span class="token string">"209385038"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"location"</span><span class="token punctuation">,</span> <span class="token string">"D:\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印属性集对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过键,获取属性值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"length"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"location"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历属性集,获取所有键的集合</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">stringPropertyNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印键值对</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> strings <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">" -- "</span><span class="token operator">+</span>properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>输出结果：<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>filename<span class="token operator">=</span>a<span class="token punctuation">.</span>txt<span class="token punctuation">,</span> length<span class="token operator">=</span><span class="token number">209385038</span><span class="token punctuation">,</span> location<span class="token operator">=</span>D<span class="token operator">:</span>\a<span class="token punctuation">.</span>txt<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>txt<span class="token number">209385038</span>D<span class="token operator">:</span>\a<span class="token punctuation">.</span>txtfilename <span class="token operator">--</span> a<span class="token punctuation">.</span>txtlength <span class="token operator">--</span> <span class="token number">209385038</span>location <span class="token operator">--</span> D<span class="token operator">:</span>\a<span class="token punctuation">.</span>txt</code></pre><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><pre><code>filename=a.txtlength=209385038location=D:\a.txt</code></pre><p>加载代码演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProDemo2</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> FileNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建属性集对象</span>        Properties pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 加载文本中信息到属性集</span>        pro<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历集合并打印</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> pro<span class="token punctuation">.</span><span class="token function">stringPropertyNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> strings <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">" -- "</span><span class="token operator">+</span>pro<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>输出结果：filename <span class="token operator">--</span> a<span class="token punctuation">.</span>txtlength <span class="token operator">--</span> <span class="token number">209385038</span>location <span class="token operator">--</span> D<span class="token operator">:</span>\a<span class="token punctuation">.</span>txt</code></pre><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><h1 id="第六章改造JDBC连接属性配置"><a href="#第六章改造JDBC连接属性配置" class="headerlink" title="第六章改造JDBC连接属性配置"></a>第六章改造JDBC连接属性配置</h1><h2 id="6-1-创建jdbc-properties文件"><a href="#6-1-创建jdbc-properties文件" class="headerlink" title="6.1.创建jdbc.properties文件"></a>6.1.创建jdbc.properties文件</h2><p><img src="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Properties/1598354505898.png" alt="1598354505898"></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/db3</span><span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span></code></pre><h2 id="6-2-读取配置文件"><a href="#6-2-读取配置文件" class="headerlink" title="6.2.读取配置文件"></a>6.2.读取配置文件</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JDBC工具类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCUtils</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String url<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String user<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String driver<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */</span>    <span class="token keyword">static</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//读取资源文件，获取值。</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//1. 创建Properties集合类。</span>            Properties pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取src路径下的文件的方式--->ClassLoader 类加载器</span>            ClassLoader classLoader <span class="token operator">=</span> JDBCUtils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//URL是统一资源定位</span>            URL res  <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String path <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// System.out.println(path);ies</span>            <span class="token comment" spellcheck="true">//2. 加载文件</span>           <span class="token comment" spellcheck="true">// pro.load(new FileReader("D:\\IdeaProjects\\code\\day20_jdbc\\src\\jdbc.properties"));</span>            pro<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3. 获取数据，赋值</span>            url <span class="token operator">=</span> pro<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user <span class="token operator">=</span> pro<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            password <span class="token operator">=</span> pro<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            driver <span class="token operator">=</span> pro<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4. 注册驱动</span>            Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Objects/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Objects/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ol><li>概述:</li></ol><ul><li>在<strong>JDK7</strong>添加了一个Objects工具类</li><li>它提供了一些方法来操作对象</li></ul><ol start="2"><li>常用方法:</li></ol><ul><li>boolean equals()<br>Object的equals()容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题<pre class=" language-Java"><code class="language-Java">//Objects的equals();实际还是调用了Object的equals();只是加了一些非空判断...public static boolean equals(Object a, Object b) &#123;    return (a == b) || (a != null && a.equals(b));  &#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Date</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Date/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Date/</url>
      
        <content type="html"><![CDATA[<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>位于<code>java.util</code>;表示特定的瞬间，精确到毫秒; 1秒 = 1000毫秒</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p> Date()<br>  表示当前的时间<br> Date(long date)<br>  表示从标准基准时间（即 1970 年 1 月 1 日 00:00:00 GMT）+ 指定毫秒数(date)的时间</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>  long getTime()<br>    表示时间对象所对应的毫秒值</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
            <tag> Java 日期,时间,日历类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calendar</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Calendar/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Calendar/</url>
      
        <content type="html"><![CDATA[<h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>表示日历的一个抽象类。</li><li>Calendar 对象能够生成为特定语言和日历风格实现日期-时间格式化所需的所有日历字段值</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul><li>static Calendar getInstance() </li><li>因为语言敏感性，Calendar类在创建对象时并非直接创建，而是通过此静态方法创建，返回子类对象;</li></ul><h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><p>Calendar类中提供很多成员常量，代表给定的日历字段：  </p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>set(要设置的字段，值)<ul><li>设置时间</li><li>注意：月份是从0开始的。</li></ul></li><li>get(要获取的字段)<ul><li>获取时间</li></ul></li><li>add(要设置的字段，数字)<ul><li>修改时间</li><li>第二个参数中，正数表示加时间，负数表示减少时间。</li></ul></li><li>Date getTime()<ul><li>把日历转成一个Date对象</li></ul></li></ul><h2 id="常用方法案例"><a href="#常用方法案例" class="headerlink" title="常用方法案例"></a>常用方法案例</h2><pre class=" language-Java"><code class="language-Java">import java.util.Calendar;public class Demo1 &#123;    public static void main(String[] args) &#123;        //  创建Calendar日历对象        Calendar calendar = Calendar.getInstance();        //  设置年        calendar.set(Calendar.YEAR, 2021);        //  设置月 //该类中月份是从0开始的，范围是0-11;0为1月,11为12月        calendar.set(Calendar.MONTH, 11);        //  设置日        calendar.set(Calendar.DAY_OF_MONTH, 8);        //  获取        System.out.println(calendar.get(Calendar.YEAR) + "年");        System.out.println(calendar.get(Calendar.MONTH) + 1 + "月");        System.out.println(calendar.get(Calendar.DAY_OF_MONTH) + "日");        //  修改  add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量        calendar.add(Calendar.DAY_OF_MONTH, -1);        System.out.println(calendar.get(Calendar.YEAR) + "年");        System.out.println(calendar.get(Calendar.MONTH) + 1 + "月");        System.out.println(calendar.get(Calendar.DAY_OF_MONTH) + "日");        //  转换为Date日期类型        Date date = calendar.getTime();        System.out.println(date);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
            <tag> Java 日期,时间,日历类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.ArrayList/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.ArrayList/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>概述:<br>    ArrayList 类是一个可以动态修改的数组，它没有固定大小的限制，可以添加或删除元素。<br>    ArrayList 继承了 AbstractList ，并实现了 List 接口<br>    ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能<br>    <font color="red"><strong>实现了基于动态数组的数据结构&nbsp;&nbsp;查询操作效率高&nbsp;&nbsp;插入和删除操作效率低</strong></font></p><p>使用: </p><ol><li>导包:   <code>import java.util.ArrayList;</code> </li><li>创建:   <code>ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;();　 // 初始化</code></li><li>常用方法: <code>objectName.add();objectName.remove();objectName.size();objectName.get()</code></li></ol><p>案例:</p><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;public class Demo &#123;    public static void main(String[] args) &#123;        //创建 String 类型 的集合对象        ArrayList<String> list = new ArrayList<>();        // 添加元素        list.add("杨过");        //根据索引删除，返回被删除的元素        list.remove(0);             //根据元素删除，返回成功或者失败        list.remove("杨过");         //获取集合的长度大小        System.out.println("集合列表的长度为:"list.size())        //获取集合中索引为0的元素        System.out.println("集合列表中索引为0的元素内容是:"list.get(0))    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DateFormat</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.text.DateFormat/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.text.DateFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><ul><li>位于<code>java.text</code>;</li><li>日期/时间格式化子类的抽象类，</li><li>通过这个类可以帮我们完成日期和文本之间的转换(可以在Date对象与String对象之间进行来回转换)</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>  由于DateFormat为抽象类，不能直接使用，所以使用子类<code>java.text.SimpleDateFormat</code>。</p><h2 id="SimpleDateFormat-使用"><a href="#SimpleDateFormat-使用" class="headerlink" title="SimpleDateFormat 使用"></a>SimpleDateFormat 使用</h2><p>  这个类需要一个模式（格式）来指定格式化或解析的标准</p><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><p>SimpleDateFormat(String pattern)：</p><ul><li>用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat</li><li>参数pattern是一个字符串，代表日期时间的自定义格式</li></ul><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><table><thead><tr><th>标识字母(区分大小写)</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>创建SimpleDateFormat对象</p><pre class=" language-Java"><code class="language-Java">public class Demo02SimpleDateFormat &#123;    public static void main(String[] args) &#123;        //日期/时间字符串格式        String dateStringFormat = "yyyy-MM-dd HH:mm:ss"        // 对应的日期格式如：2018-01-16 15:06:38        DateFormat format = new SimpleDateFormat(dateStringFormat);    &#125;    &#125;</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>String format(Date date)<br>  日期对象转字符串<br>Date parse(String s)<br>  字符串转日期对象</p><h3 id="常用方法案例"><a href="#常用方法案例" class="headerlink" title="常用方法案例"></a>常用方法案例</h3><p>format使用</p><pre class=" language-Java"><code class="language-Java">import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* Date对象转换成String*/public class DateFormatDemo &#123;    public static void main(String[] args) &#123;      //创建日期对象        Date date = new Date();        // 创建日期格式化对象,在获取格式化对象时可以指定风格        DateFormat df = new SimpleDateFormat("yyyy年MM月dd日");        //调用format将日期/时间对象转为字符串        String str = df.format(date);        System.out.println(str); // 2008年1月23日    &#125;&#125;</code></pre><p>parse使用</p><pre class=" language-Java"><code class="language-Java">import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class DateFormatDemo &#123;   public static void main(String[] args) throws ParseException &#123;        // 创建日期/时间格式化对象        DateFormat df = new SimpleDateFormat("yyyy年MM月dd日");        // 日期时间字符串        String str = "2018年12月11日";        //将String转为日期/时间对象        Date date = df.parse(str);        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
            <tag> Java 日期,时间,日历类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.System/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.System/</url>
      
        <content type="html"><![CDATA[<h1 id="System"><a href="#System" class="headerlink" title="System"></a>System</h1><p>概述<br>  表示和系统操作相关的类。里面的方法都是静态的。</p><p>方法</p><ul><li><p>static long currentTimeMillis()<br>  获取当前系统时间的毫秒值</p></li><li><p>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)<br>  实现数组拷贝</p><pre><code>参数1： 原数组参数2： 原数组中第一个要拷贝的数组元素的索引参数3： 目标数组参数4： 目标数组中第一位要放置的位置的索引参数5： 长度| 参数序号  | 参数名称  | 参数类型 | 参数含义             || -------- | -------- | -------- | ------------------- || 1        | src      | Object   | 源数组               || 2        | srcPos   | int      | 源数组索引起始位置    || 3        | dest     | Object   | 目标数组             || 4        | destPos  | int      | 目标数组索引起始位置  || 5        | length   | int      | 复制元素个数         |</code></pre></li><li><p>staitc void exit(int n)<br>  结束jvm的执行,一般用于结束系统中。       </p></li></ul><p>方法案例</p><pre class=" language-Java"><code class="language-Java">public class Demo &#123;    public static void main(String[] args) &#123;        //  获取当前系统时间        long currentSystemTimeMs = System.currentTimeMillis();        System.out.println(currentSystemTimeMs);        //  将数组中指定的数据拷贝到另一个数组中        int[] arr = &#123;21, 13, 6, 8, 55&#125;;        int[] arr2 = new int[8];        System.arraycopy(arr, 0, arr2, 1, 4);        for (int i = 0; i < arr2.length; i++) &#123;            System.out.println(arr2[i]);        &#125;        //  结束jvm的执行        int i = 1;        for (; ; ) &#123;            if (i == 2000) &#123;                System.exit(0);            &#125;            System.out.println(i);            i++;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String+StringBuilder+StringBuffer</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.String/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.String/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><blockquote><p>是和字符串相关的类。  位于java.lang包<br>使用final修饰(最终类)</p></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法:"></a>构造方法:</h3><ul><li>new String() <ul><li> 初始化一个新创建的 String 对象，使其表示一个空字符序列。</li></ul></li><li>new String(“abc”) <ul><li> 初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列</li></ul></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>字符串常量池和运行时常量池逻辑上属于方法区，但是实际存放在堆内存中</p><h3 id="常见问题-面试题"><a href="#常见问题-面试题" class="headerlink" title="常见问题(面试题):"></a>常见问题(面试题):</h3><ul><li>String s = “hello” 和String s = new String(“hello”)区别<ul><li>内存分配:<ul><li>栈区</li><li>堆区:<ul><li>常量池</li></ul></li><li>方法区</li></ul></li><li>String s = “hello”<ul><li>(常量池不存在hello时)在常量池开辟空间存放hello生成地址,栈区中的s变量指向hello生成的地址</li><li>(常量池存在hello时)栈区中的s变量指向hello的地址</li></ul></li><li>String s = new String(“hello”)<ul><li>(常量池不存在hello时)在常量池开辟空间存放hello并生成地址,堆区中开辟空间指向hello生成的地址,栈区中的s变量指向堆区中的地址</li><li>(常量池存在hello时)堆区中开辟空间指向hello生成的地址,栈区中的s变量指向堆区中的地址</li></ul></li></ul></li><li>equals和==的区别:<ul><li>基本数据类型中的==比较的是值是否相同</li><li>引用数据类型:<ul><li>==比较的是内存中的地址值是否相同</li><li>equals默认继承object的情况下比较的还是内存中的地址值,String 这里的equals比较的是字符串的内容是否相同</li></ul></li><li>String s = “hello”,s += “world”，变量s的值变了吗？<ul><li>s的值变为helloworld;但是内存中的常量池中还是存在hello;只是栈区中的s变量指向改为了helloworld</li></ul></li></ul></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="案例如下"><a href="#案例如下" class="headerlink" title="案例如下"></a>案例如下</h4><pre class=" language-Java"><code class="language-Java">public static void main(String[] args) &#123;  //  equals  比较两个字符串的内容是否相同  // 这里的str1直接指向常量池中"123"的地址值  String str1 = "123";  // 这里的str2指向堆中new String("123")的地址值  String str2 = new String("123");  // 这里是栈区中str1变量所指向的地址,和堆中new String("123")的地址进行比较,所以不相同  if (str1 != str2) &#123;      System.out.println("==比较堆中的地址值不相同");  &#125;  if (str1.equals(str2)) &#123;      System.out.println("equals比较内容相同");  &#125;  //  length    获取字符串的长度  String str3 = "123456";  //获取字符串str3的长度  System.out.println(str3.length());  //  charAt   获取指定索引位置的字符  String str4 = "123456";  System.out.println(str4.charAt(0));  //  indexOf  获取指定字符或字符串在当前字符串中首次出现的位置,没找到返回-1  String str5 = "123456789";  System.out.println(str5.indexOf(3));  //  split    将字符串以某个字符拆分成字符串数组,字符串拆分  String str6 = "2021-12-2";  //接收的参数为正则,需注意特殊符号,以特殊符号拆分可以添加在[ ]之内  System.out.println(str6.split("[-]"));  //  substring    截取字符串,并返回新的字符串  String str7 = "1十分1吖1放啊东方1阿发吖131516发sasafafasdfas";  //截取索引从0-5之间(包括0,不包括5)的字符,  System.out.println(str7.substring(5));  //截取索引从2-12之间(包括2,不包括12)的字符  System.out.println(str7.substring(2, 12));  //  concat 将指定字符串拼接到此字符串的末尾  //  参数长度为0时,返回此字符串对象;否则返回新的String对象  String str8 = "123"  System.out.println(str8.concat("abc"));&#125;</code></pre><h3 id="String和-基本数据类型的转换"><a href="#String和-基本数据类型的转换" class="headerlink" title="String和 基本数据类型的转换"></a>String和 基本数据类型的转换</h3><ul><li>基本数据类型转String：<ul><li>把基本数据类型和一个””做拼接即可。</li></ul></li><li>String转换为基本数据类型：<ul><li>使用包装类中的parseXXX方法即可。</li></ul></li></ul><pre class=" language-Java"><code class="language-Java">String s = "520";int i = Integer.parseInt(s);</code></pre><h3 id="StringBuilder类与StringBuffer类"><a href="#StringBuilder类与StringBuffer类" class="headerlink" title="StringBuilder类与StringBuffer类"></a>StringBuilder类与StringBuffer类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>  String类是长度不可改变的字符序列;做拼接操作的时候每次都会创建常量,非常消费内存<br>  StringBuilder类是一个长度可变的字符序列;线程不安全，效率高<br>  StringBuffer类是一个长度可变的字符序列;线程安全，效率低<br>  StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作<br>  它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。  StringBuilder会自动维护数组的扩容</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>  public StringBuilder()<br>  public StringBuidler(String str)</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>StringBuilder append(…)<ul><li>拼接内容;字符串拼接的 + 在底层为StringBuilder类的append()</li></ul></li><li>String toString()<ul><li>转成String类型</li></ul></li><li>StringBuffer reverse() <ul><li>内容反转</li></ul></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>String类与StringBuilder类与StringBuffer类的区别<ul><li>String是长度不可变的字符序列;一旦创建，内容不能改变</li><li>StringBuilder类是一个长度可变的字符序列;线程不安全，效率高</li><li>StringBuffer类是一个长度可变的字符序列;线程安全，效率低</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object</title>
      <link href="/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.Object/"/>
      <url>/2021/12/29/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.Object/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><ul><li><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类</li><li>没有使用extends 继承父类的类都默认继承Object</li><li>所有的类都可以使用Object类中的方法</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h2><ul><li>String toString()<br>  返回该对象的字符串表示;其实该字符串内容就是 <code>对象的类型+@+内存地址值</code><br>  <font color="red">Java中直接打印对象,实际调用了对象的toString()</font></li><li>boolean equals()<br>  比较两个对象的地址值是否相同;<br>  这里推荐使用Objects的equals(); Object的equals()容易抛出空指针异常，而Objects类中的equals方法优化了这个问题</li><li>Object clone()<br>  创建并返回此对象的副本<br>  在执行clone操作的时候，不会调用构造函数<br>  <code>clone()</code>本身是浅拷贝;拷贝对象返回的是一个新的对象，而不是一个对象的引用地址；<br>  拷贝对象已经包含原来对象的信息，而不是对象的初始信息，即每次拷贝动作不是针对一个全新对象的创建。<br>  注意:Object类本身并不实现接口<code>Cloneable</code>;如果使用clone(),必须实现<code>Cloneable</code>接口;否则会报<code>CloneNotSupportedException</code>异常<br>  使用:<font color="red">轻量级的对象可以使用new，其他对象可以使用clone</font><h2 id="常用方法的使用"><a href="#常用方法的使用" class="headerlink" title="常用方法的使用"></a>常用方法的使用</h2></li><li>toString()<br>由于toString()返回的是内存地址，而在开发中，需要按照对象的属性得到相应的字符串表现形式，因此可以重写它<br>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项;选择需要包含的成员变量并确定进行自动代码生成</li><li>equals()<br>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法<br>在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>  == 和 equals的区别？<br>  区别:<br>    ==<br>      基本类型:比较内容是否相同<br>      引用类型:比较地址值是否相同<br>    equals<br>      只能比较引用类型;默认继承Object情况下比较地址值是否相同;<br>      Object中的equals()是用==比较的</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2021/12/29/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/12/29/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE面试题"><a href="#JavaSE面试题" class="headerlink" title="JavaSE面试题"></a>JavaSE面试题</h2><ol><li>jdk，jre，jvm的含义以及三者之间的关系?<br>JVM: Java虚拟机，是Java程序的运行环境,<br>JRE: Java程序的运行时环境,包含JVM和运行时需要的核心类库<br>JDK: Java程序的开发工具包,包含JRE和开发使用的工具</li><li>i++和++i的区别?<br>i++ 先执行,后自增</li></ol><p>  ++i 先自增,后执行<br>3. short s = 1,s = s + 1 有错吗？为什么？s += 1有错吗？为什么？<br>  s = s+1会报错;不兼容的类型: 从int转换到short可能会有损失<br>  s += 1不会报错;因为 s += 1; 相当于 s = (short)(s + 1); 其中有隐含的强制类型转换<br>4. ArrayIndexOutOfBoundsException（数组下标越界异常）和NullPointerException(空指针异常)出现的原因是?<br>  ArrayIndexOutOfBoundsException出现的原因:使用不合法的索引访问呢数组时,会报数组下标越界异常<br>  NullPointerException出现的原因:是一个运行时异常，尝试调用真实对象上的方法但在运行时该对象引用为 Null 时会引发该异常<br>7. 值传递和址传递的区别?<br>  值传递:传递的是真实的数据<br>  址传递:传递的是对象的引用<br>8. 成员变量,局部变量,静态变量之间的区别?<br>  成员变量是类中定义的变量<br>  局部变量是方法内部的变量<br>  静态变量是类中添加static关键字的变量<br>9. 成员方法与静态方法的区别?<br>  成员方法:由对象调用<br>  静态方法:使用类.方法()调用<br>10. 包装类的来历?<br>  Java是面向对象的编程语言，所以包装类型为了解决基本数据类型无法面向对象编程所提供的<br>12. 泛型的含义及使用<br>  泛型的本质是参数化类型，就是所操作的数据类型被指定为一个参数<br>19. super与this代表的含义<br>  super：代表父类的存储空间标识(通过这个标识可以访问父类的成员和构造，但是其实是不同于父类的引用的)<br>  this：代表当前对象的引用(谁调用就代表谁)<br>20. 面向对象中,创建子类对象会创建父类对象吗?画出内存中父子类的关系形式</p><ol start="21"><li><p>匿名内部类的使用场景及编写使用方式</p></li><li><p>==和equals的区别,以及它们之间的关系</p></li><li><p>获取当前系统时间的方式,写出2-3种</p></li></ol><ol start="24"><li><p>String[] strArr = {“a”, “b”, “c”, “d”, “e”} 转换为集合,使用迭代器遍历,删除其中的 c 字符串,最后打印删除 c 字符串后的集合</p></li><li><p>什么情况下会出现ClassCastException异常</p></li><li><p>Java中的泛型是什么 ? 使用泛型的好处是什么?</p></li><li><p>Java的泛型是如何工作的 ? 什么是类型擦除 ?</p></li><li><p>什么是泛型中的限定通配符和非限定通配符 ?</p></li><li><p>如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p></li><li><p>编写一段泛型程序来实现LRU缓存?</p></li><li><p>你可以把List<String>传递给一个接受List<Object>参数的方法吗？</Object></String></p></li><li><p>Java中创建对象的方式有几种?何时使用哪种方式?</p><ul><li>使用<ol><li>使用new关键字</li><li>使用clone方法</li><li>反射机制</li><li>反序列化</li></ol></li><li>区别<br>  1,3都会明确的显式的调用构造函数<br>  2是在内存上对已有对象的拷贝 所以不会调用构造函数<br>  4是从文件中还原类的对象 也不会调用构造函数</li></ul></li><li><p>说一下浅拷贝与深拷贝</p></li></ol><ol start="37"><li>什么是哈希冲突</li></ol><ol start="39"><li>HashSet集合与Map的关系</li></ol><ul><li>HashSet类中有一个全局变量HashMap map,然后在HashSet的构造函数中有一句话map=new HashMap(),说明在创建HashSet类对象的时候底层创建了一个HashMap对象</li></ul><ol start="40"><li>hashCode的本质</li></ol><ul><li>帮助HashMap和HashSet集合加快插入的效率，当插入一个数据时，通过hashCode能够快速地计算插入位置，就不需要从头到尾地使用equlas方法进行比较</li></ul><ol start="41"><li>自定义类型的实例对象使用set存储或作为Map的键需要做什么?</li></ol><ul><li>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法</li><li>如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals</li></ul><ol start="42"><li>为什么重写equals</li></ol><ul><li>Object类的equals，比较的是对象的地址值</li><li>如果希望比较对象的值是否相同，必须重写equals方法</li></ul><ol start="43"><li><p>为什么重写equals就必须重写hashCode?</p></li><li><p>equals()和hashCode()的作用    - equals()  用来比较两个对象是否相等;没有重写比较两个对象的地址值(地址值不会相同),若是想让两个内容相同的对象在equals后得到true，则需重写equals方法    - hashCode()  用来返回对象的hash码值,通常情况下，我们都不会使用到这个方法;本质是为了帮助HashMap和HashSet集合加快插入的效率</p></li><li><p>为什么只要重写了equals方法，就必须重写hashCode    - 主要是针对一些使用到了hashCode方法的集合，比如HashMap、HashSet等    - 当equals方法被重写时，两个对象的内容相同即代表相同;但是如果没有重写hashCode方法,向hash结构的集合中添加这两个对象时,两个都会添加成功,因为没有重写hascode，生成的是两个hash值，在hash集合看来就是两个对象;说明这里必须重写hashCode(),两个内容相同的对象hash值相同,hash结构才会认为是一个对象;</p></li><li><p>哈希结构的集合中添加元素</p></li></ol><ul><li>先调用hashCode，唯一则存储，不唯一则再调用equals，结果相同则不再存储，结果不同则散列到其他位置。因为hashCode效率更高（仅为一个int值），比较起来更快</li></ul><ol start="45"><li>Apache和Apache Tomcat的区别是什么？</li></ol><ul><li>Apache 和 Tomcat 都是web网络服务器，两者既有联系又有区别</li><li>Apache是web服务器（静态解析，如HTML），tomcat是java应用服务器（动态解析，如JSP）</li><li>Tomcat只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但可以独立于apache运行</li><li>Apache和Tomcat是独立的，在同一台服务器上可以集成</li><li>Apache和Tomcat整合使用<br>  如果客户端请求的是静态页面，则只需要Apache服务器响应请求；<br>  如果客户端请求动态页面，则是Tomcat服务器响应请求，将解析的JSP等网页代码解析后回传给Apache服务器，再经Apache返回给浏览器端。<br>  这是因为jsp是服务器端解释代码的，Tomcat只做动态代码解析，Apache回传解析好的静态代码，Apache+Tomcat这样整合就可以减少Tomcat的服务开销。</li><li>APACHE+TOMCAT+JDK整合的好处：<br>  如果客户端请求的是静态页面，则只需要Apache服务器响应请求 如果客户端请求动态页面，则是Tomcat服务器响应请求<br>  因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销</li></ul><ol start="46"><li>Java 中 clone() 和 new 效率哪个更高？</li></ol><p>拷贝对象返回的是一个新的对象，而不是一个对象的引用地址；<br>拷贝对象已经包含原来对象的信息，而不是对象的初始信息，即每次拷贝动作不是针对一个全新对象的创建。</p><p>利用clone，在内存中进行数据块的拷贝，复制已有的对象，也是生成对象的一种方式。前提是类实现Cloneable接口，Cloneable接口没有任何方法，是一个空接口，也可以称这样的接口为标志接口，只有实现了该接口，才会支持clone操作。有的人也许会问了，java中的对象都有一个默认的父类Object。</p><p>Object中有一个clone方法，为什么还必须要实现Cloneable接口呢，这就是cloneable接口这个标志接口的意义，只有实现了这个接口才能实现复制操作，因为jvm在复制对象的时候，会检查对象的类是否实现了Cloneable这个接口，如果没有实现，则会报CloneNotSupportedException异常。类似这样的接口还有Serializable接口、RandomAccess接口等。</p><p>还有值得一提的是在执行clone操作的时候，不会调用构造函数。还有clone操作还会面临深拷贝和浅拷贝的问题。关于这方面的问题，网上有很多的相关知识了，不再累述了。由于通过复制操作得到对象不需要调用构造函数，只是内存中的数据块的拷贝，那是不是拷贝对象的效率是不是一定会比new的时候的快。</p><p>答案：不是。显然jvm的开发者也意识到通过new方式来生成对象占据了开发者生成对象的绝大部分，所以对于利用new操作生成对象进行了优化。</p><p>结论：轻量级的对象可以使用new，其他对象可以使用clone。</p><ol start="46"><li><p>DataSource 和DriverManager的区别</p></li><li><p>获取的对象不同。DataSource主要是获取数据库连接池，而DriverManager主要是获取数据库连接，通过管理JDBC驱动程序来建立连接。</p></li><li><p>DataSource中封装了DriverManager的使用</p></li><li><p>DataSource创建的connection可以被复用，而DriverManager的则不行</p></li><li><p>TCP与UDP的区别;TCP协议的三次握手,四次挥手</p></li><li><p>网络通信的三要素</p></li><li><p>final和finally的区别</p></li></ol><ul><li>final是一个安全修饰符,用final修饰的类不能被继承,用final声明的方法不能被重写,使用final声明的变量是常量,不能被修改</li><li>finally是在异常里经常用到的, 是try和cach里的代码执行完以后,必须要执行的方法,主要执行一些释放资源的操作,比如说关闭数据库连接,或者关闭IO流</li></ul><ol start="49"><li>int和Integer的区别？</li></ol><ul><li>int是基本数据类型;Integer是java为int提供的封装类，是引用数据类型；</li><li>int的默认值为0，而integer的默认值为null</li></ul><ol start="49"><li>servlet的生命周期？</li></ol><ul><li>init：初始化方法，默认在第一次访问时被执行，只执行1次</li><li>service：提供服务的方法，在每次访问时都会执行，执行多次</li><li>destory：销毁的方法。会在服务器正常关闭的之后执行1次</li></ul><h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><ol><li>String类中常用的方法</li></ol><ul><li>split         将字符串拆分成字符串数组</li><li>indexOf       获取指定字符或字符串在当前字符串中首次出现的位置,没找到返回-1</li><li>substring     截取字符串,并返回新的字符串</li><li>replace()：   替换字符串内匹配的子字符串</li><li>equals()：    比较字符串的内容是否相同</li><li>concat()：    将指定字符串连接到此字符串的结尾</li></ul><ol start="2"><li>String中的==和equals的区别</li></ol><ul><li>== 默认比较的是地址值是否相同</li><li>equals默认比较的也是地址值是否相同,但String中的equals进行了重写,比较的是内容是否相同</li></ul><ol start="3"><li>Java中的String，StringBuilder，StringBuffer三者的区别</li></ol><ul><li>String是长度不可变的字符序列;一旦创建，内容不能改变;主要用于少量的字符串操作</li><li>StringBuilder类是一个长度可变的字符序列;线程不安全，效率高;append方法拼接内容,不会创建新的对象</li><li>StringBuffer类是一个长度可变的字符序列;线程安全，效率低;append方法拼接内容,不会创建新的对象</li></ul><ol start="4"><li><p>String s = “hello” 和 String s = new String(“hello”)的区别?</p></li><li><p>String s1 = “hello”,s1 += “word”, 问原始的s1的内容改变了 吗？</p></li></ol><h2 id="Collecation集合相关"><a href="#Collecation集合相关" class="headerlink" title="Collecation集合相关"></a>Collecation集合相关</h2><ol><li>java arrayList的存储结构,初始化的时候创建多大的数组?</li></ol><ul><li>ArrayList是基于数组实现的，是一个动态数组,容量能自动增长，初始化长度是10, 扩容规则:  扩容后的大小= 原始大小*1.5</li><li>ArrayList是线程不安全的，只能用在单线程环境下，多线程环境下可以考虑用<code>Collections.synchronizedList(List l)</code>函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的<code>CopyOnWriteArrayList</code>类</li></ul><ol start="2"><li>ArrayList与LinkedList区别及使用</li></ol><ul><li>数据结构不同;ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构</li><li>效率不同<ul><li>查询时<br>LinkedList是线性的数据存储方式，需要移动指针从前往后依次查找<br>ArrayList使用数组方式存储数据，根据索引查询数据速度快</li><li>新增或删除时<br>LinkedList使用链表结构存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可,操作比较快<br>ArrayList使用数组存储数据，所以在其中进行增删操作时，新增或删除后会对所有数据的下标索引造成影响，需要进行数据的移动,操作比较慢</li></ul></li><li>ArrayList使用数组方式存储数据，根据索引查询数据速度快，而新增或者删除元素时需要位移操作，所以比较慢。 <ul><li>LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。开发中什么时候到ArrayList?,我们在做查询的时候把查询出来的数据经常存到arraylist里.</li></ul></li></ul><ol start="3"><li><p>Collection和Collections的区别？</p></li><li><p>List集合与Set集合的特性</p></li><li><p>集合与数组的区别?</p></li><li><p>ArrayList和linkedList作用及区别,分别介绍常用的方法?</p></li><li><p>HashMap底层实现原理<br>底层结构为数组,链表,红黑树<br>数组中的每个元素都是一个链表,链表中的节点大于8个后会,链表会转为红黑树</p></li></ol><ul><li>put(k,v)实现原理<br>（1）首先将k,v封装到Node对象当中（节点）。<br>（2）底层会调用K的hashCode()方法得出hash值。<br>（3）通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。</li><li>get(k)实现原理<br>(1)先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标<br>(2)通过数组下标定位到某个位置上。如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。<br>为何随机增删、查询效率都很高的原因是？<br>增删是在链表上完成的，而查询只需扫描部分，则效率高。<br>HashMap集合的key，会先后调用两个方法，hashCode and equals方法，这这两个方法都需要重写。</li></ul><p>为什么放在hashMap集合key部分的元素需要重写equals方法？<br>因为equals方法默认比较的是两个对象的内存地址</p><p>HashMap红黑树原理分析<br>相比 jdk1.7 的 HashMap 而言，jdk1.8最重要的就是引入了红黑树的设计，红黑树除了插入操作慢其他操作都比链表快，当hash表的单一链表长度超过 8 个的时候，数组长度大于64，链表结构就会转为红黑树结构。当红黑树上的节点数量小于6个，会重新把红黑树变成单向链表数据结构。<br>为什么要这样设计呢？好处就是避免在最极端的情况下链表变得很长很长，在查询的时候，效率会非常慢。</p><p>红黑树查询：其访问性能近似于折半查找，时间复杂度 O(logn)；<br>链表查询：这种情况下，需要遍历全部元素才行，时间复杂度 O(n)；<br>简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。</p><p>关于红黑树的内容，网上给出的内容非常多，主要有以下几个特性：<br>1、每个节点要么是红色，要么是黑色，但根节点永远是黑色的；</p><p>2、每个红色节点的两个子节点一定都是黑色；</p><p>3、红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；</p><p>4、从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</p><p>5、所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；<br>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件 3 或条件 4，需要通过调整使得查找树重新满足红黑树的条件。</p><p>三、HashMap的原理1.7 和1.8 的区别<br>jdk1.7中底层是由数组+链表实现；jdk1.8中底层是由数组+链表/红黑树实现<br>可以存储null键和null值，线程不安全<br>初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂<br>扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入<br>当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀<br>hash冲突<br>当两个key通过hashCod计算相同时（其实hashCode是随机产生的，是有可能hashCode相同）,则发生了hash冲突，开放定址法、再哈希法、链地址法、建立公共溢出区<br>HashMap解决hash冲突的方式是用链表。当发生hash冲突时，则将存放在数组中的Entry设置为新值的next，说白就是比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上</p><p>开放定址法：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中<br>再哈希法：同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。<br>链地址法：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。<br>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><ol start="49"><li>Java里可不可以有多继承？</li></ol><ul><li>不可以，想多继承的话,使用接口</li></ul><ol start="15"><li><p>什么是类？什么是对象？</p></li><li><p>说一下面向对象三大特征：封装，继承，多态</p></li></ol><ul><li>继承就是子类继承父类的属性和方法(使用extends)</li><li>封装,使用 private 把成员变量设置为私有，然后可以对外提供 public 的 set 和 get 方法</li><li>多态,多态就是同一个类或接口，使用不同的实例而执行不同操作</li></ul><ol start="17"><li>重载与重写的区别,作用?</li></ol><ul><li>区别<br>重写是父类与子类之间的多态;<br>重载是在一个类中多态的体现;</li><li>作用<br>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)<br>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)</li></ul><ol start="18"><li>抽象类与接口的区别,包括使用(什么情况使用抽象类,什么情况使用接口)<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2></li><li>内存概述<br>内存是计算机的临时存储设备，当程序被启动时，会被cpu加载到内存中。</li><li>内存区域划分<br>寄存器：计算机直接使用，我们不需要管<br>本地方法栈：jvm使用操作系统功能时使用，不需要管。<br>栈区：存放局部变量，基本数据类型等。<br>堆区：存放引用数据类型。<br>方法区：存放运行时的字节码文件。</li></ol><h2 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h2><h3 id="内存空间回收"><a href="#内存空间回收" class="headerlink" title="内存空间回收"></a>内存空间回收</h3><p>  GC垃圾回收器是JAVA的特有功能,能自动释放内存空间，减轻内存的负担<br>  在Java中，当没有引用指向原先分配给某个对象的内存时，该内存便成为垃圾;JVM的一个系统级线程会自动释放该内存块并回收它占领的空间，以便空间被后来的新对象使用</p><h3 id="清除内存记录碎片"><a href="#清除内存记录碎片" class="headerlink" title="清除内存记录碎片"></a>清除内存记录碎片</h3><p>  垃圾收集也可以清除内存记录碎片<br>  由于创建对象和垃圾收集器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>它能使编程效率提高</p></li><li><p>不需要花时间来解决存储器问题,Java语言,靠垃圾收集机制可大大缩短时间</p></li><li><p>保护程序的完整性,垃圾收集是Java语言安全性策略的一个重要部分</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li><p>开销影响程序性能;Java虚拟机必须追踪运行程序中有用的对象，而最终释放没用的对象。这一个过程需要花费处理器的时间</p></li><li><p>垃圾收集算法的不完备性，垃圾收集算法不能保证100%收集到所有的废弃内存</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>充分理解Java的GC垃圾回收器可以更有效地利用资源;同时要注意finalize()方法是Java的缺省机制，有时为确保对象资源的明确释放，可以编写自己的finalize方法</p><h3 id="jdk1-7-0-79-JVM使用的垃圾回收算法-GC算法"><a href="#jdk1-7-0-79-JVM使用的垃圾回收算法-GC算法" class="headerlink" title="jdk1.7.0_79 JVM使用的垃圾回收算法(GC算法)"></a>jdk1.7.0_79 JVM使用的垃圾回收算法(GC算法)</h3></li><li><p>标记-清除算法<br>　　等待被回收对象的“标记”过程在上文已经提到过，如果在被标记后直接对对象进行清除，会带来另一个新的问题——内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收</p></li><li><p>复制算法（Java堆中新生代的垃圾回收算法）<br>此GC算法实际上解决了标记-清除算法带来的“内存碎片化”问题。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。它的缺点就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制<br>　　在Java堆中被分为了新生代和老年代，这样的划分是方便GC。Java堆中的新生代就使用了GC复制算法。</p></li><li><p>标记-压缩算法（或称为标记-整理算法，Java堆中老年代的垃圾回收算法）</p></li></ol><p>　　老年代中大部分对象可能会继续存活下去，此时还用复制算法，效率会降低。标记-压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。老年代的垃圾回收称为“Major GC”。</p><ol start="4"><li>分代收集算法(大多商用虚拟机都采用)<br>根据对象的存活的时间的长短，将内存分为了新生代和老年代，这样就可以针对不同的区域，采取对应的算法。<br>如：<br>新生代，每次都有大量对象死亡，有老年代作为内存担保，采取复制算法。<br>老年代，对象存活时间长，采用标记整理，或者标记清理算法都可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象三大特性</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol><li><p>概述：<br>把类中的属性私有化，提供公共的访问方式，保证代码的安全性。</p></li><li><p>步骤：</p></li><li><p>使用private 修饰成员变量</p></li><li><p>让成员变量私有化，提供set…方法让用户可以设置值，提供get…方法让用户可以获取值。<br> private：被此关键字修饰的成员是私有成员，只能在本类中使用。</p></li><li><p>this关键字：<br>当成员变量和局部变量同名时，可以使用this.变量表示访问成员变量。</p></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  子类会继承父类的所有的非私有成员（构造方法除外）;<br>  使用 extends关键字;<br>  所有的类都直接或间接继承自Object类;</p><h3 id="为什么要使用继承"><a href="#为什么要使用继承" class="headerlink" title="为什么要使用继承"></a>为什么要使用继承</h3><ul><li>好处：<ul><li>代码的复用性</li><li>是多态的前提。</li></ul></li><li>弊端：让类和类之间产生了关系(耦合的产生)         <!--   (高内聚低耦合)   --></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在new子类对象时,JVM会先new出父类对象</li><li>构造函数第一行默认有个super(),super是指向父类的引用</li></ul><h3 id="继承示例"><a href="#继承示例" class="headerlink" title="继承示例"></a>继承示例</h3><pre class=" language-Java"><code class="language-Java">//子类 继承 父类public class 子类名 extends 父类名&#123;&#125;</code></pre><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><ul><li>当子类出现和父类中完全相同的方法时，子类会重写父类中的方法。</li></ul><h4 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h4><ul><li>方法重载和方法重写的区别?或overwrite和overload()的区别?<ul><li>方法重载：在同一个类中，方法名相同，参数列表不同构成重载关系。</li><li>方法重写：子类出现和父类完成相同的方法时，子类会重写父类中的方法。</li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>多态是同一个行为具有多个不同表现形式或形态的能力。</li><li>多态就是同一个接口，使用不同的实例而执行不同操作</li></ul><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：Parent p = new Child();</li></ul><h3 id="多态的格式"><a href="#多态的格式" class="headerlink" title="多态的格式"></a>多态的格式</h3><pre class=" language-Java"><code class="language-Java">// 多态存在的三个必要条件//    继承//    重写//    父类引用指向子类对象：Parent p = new Child();public class Parent&#123;  public void demo()&#123;System.out.println("父类打印信息...")&#125;&#125;public class Child extends Parent&#123;// 1 继承  // 2 写父类方法  public void demo()&#123;System.out.println("子类打印信息...")&#125;&#125;public class Run&#123;  public static void main(String [] args)&#123;    // 3 父类引用指向子类对象    Parent p = new Child();  &#125;&#125;</code></pre><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ol><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理</p><h3 id="多态下的成员变量访问"><a href="#多态下的成员变量访问" class="headerlink" title="多态下的成员变量访问"></a>多态下的成员变量访问</h3><p>多态下会访问父类里的成员变量<br>  访问成员变量的的两种方式:</p><ol><li>直接通过对象名称访问成员变量,看等号左边是谁,优先用谁,没有则向上找</li><li>间接通过成员方法访问: 看该方法属于谁,优先用谁,没有则向上找</li></ol><h3 id="多态下的成员方法访问"><a href="#多态下的成员方法访问" class="headerlink" title="多态下的成员方法访问"></a>多态下的成员方法访问</h3><p>在多态下成员方法的访问规则</p><ol><li>首先检查父类中是否有该方法</li><li>如果没有，则编译错误</li><li>如果有，再去调用子类的同名方法</li></ol><h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><p>多态的转型分为向上转型与向下转型两种：</p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>概述:</p><ul><li>向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</li><li>当父类引用指向一个子类对象时，便是向上转型。</li><li>向上转型一定是安全的没有问题的,正确的</li></ul><p>缺点:</p><ul><li>对象一但向上转型为父类,就无法调用子类原本特有的内容</li></ul><p>使用格式：</p><ul><li>父类类型 变量名 = new 子类类型(); <pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如：</span>Animal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>概述：</p><ul><li>父类类型向子类类型向下转换的过程，这个过程是强制的。</li><li>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><ul><li>子类类型 变量名 = (子类类型) 父类变量名;<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如:</span>Cat c <span class="token operator">=</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span> a<span class="token punctuation">;</span></code></pre></li></ul><h4 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h4><p>使用多态调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。<br>也就是说，不能调用子类拥有，而父类没有的方法。<br>编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><h4 id="转型报错-ClassCastException"><a href="#转型报错-ClassCastException" class="headerlink" title="转型报错(ClassCastException)"></a>转型报错(ClassCastException)</h4><p><code>ClassCastException</code>，类型转换异常！<br>这是因为，这两个类型并没有任何继承关系，不符合类型转换的定义。<br>为了避免ClassCastException的发生，Java提供了<code>instanceof</code>关键字，给引用变量做类型的校验，格式如下：</p><pre class=" language-Java"><code class="language-Java">变量名 instanceof 数据类型如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。</code></pre><blockquote><h2 id="多态内存描述-转载自CSDN博主学术期刊编辑"><a href="#多态内存描述-转载自CSDN博主学术期刊编辑" class="headerlink" title="多态内存描述 转载自CSDN博主学术期刊编辑"></a>多态内存描述 转载自CSDN博主<a href="https://blog.csdn.net/weixin_36349918/article/details/114140453">学术期刊编辑</a></h2><p>1：Animal a = new Cat();<br>1.1:在栈中创建区域，类型为Animal，变量名:a;<br>1.2:在堆中new Cat();占用一块区域。地址值：[0x3a4]<br>1.3:spuer()实例化父类Animal。<br>1.3.1:new Animal();占用一块区域，地址值:0x3ab;<br>1.3.2:引用着在方法区中初始化[Animal中的所有方法,该引用为：[0x754]]。<br>1.3.3:将Animal()引用赋给spuer();spuer引用着Animal();<br>1.4:在方法区中初始化Cat类的所有方法,引用值为0x343。<br>1.5:将0x3a4赋给栈中的变量a;a就开始引用Cat()。</p><hr><p>2：a.eat();<br>2.1:通过[0x3a4]找到Cat。<br>2.2:编译时期：先spuer()找到Animal中的方法。如果没有，则报错。<br>2.3:运行时：直接在Cat中找到eat(),当Cat中没有，再去Animal中找。<br>2.4:将eat()方法要方法区压栈，执行，输出:SOP(猫吃鱼);</p><hr><p>3：a = new Dog();<br>3.1:在堆new Dog(),开辟一块新区域，地址值:0x87xfds<br>3.2:spuer();实例化父类Animal<br>3.2.1:new Animal()开辟新区域，地址值0x33fa;<br>3.2.2:成员方法引用着方法区中已初始化的[0x754];<br>3.2.3:将Animal地址值0x33fa赋给spuer();;spuer引用着Animal();<br>3.3:在方法区中初始化Dog类的所有方法,引用值为0x422ac。<br>3.4:将[0x87xfds]赋给栈中的变量a; a不再引用Cat,而是引用着Dog;这时堆中的Cat已成为垃圾，等待JVM空闲时来回收。</p><hr><p>4：a.eat();<br>4.1:通过a变量引用值找到堆中标记为0x87xfds的区域。<br>4.2:编译时:先进super();去检查Animal引用的方法区中有没有eat()方法,如有没有则报错。<br>4.3:运行时:直接去Doa方法区中找到eat();如果Doa没有，再去执行super()调用父类的eat()方法。<br>4.4:从方法区中将eat()压栈，执行(SOP(‘狗吃粮’))。</p><hr><p>5：a.shudy();<br>5.1:通过a变量引用值找到堆中标记为0x87xfds的区域。<br>5.2:编译时:先进super();去检查Animal引用的方法区中有没有shudy()方法,结果Animal中没有shudy()方法，所以就在编译时期就报错。</p><hr><p>6：Dog d = (Dog)a;<br>6.1:在栈中开辟区域，存储类型为Dog,变量名d<br>6.2:将a向下转型，从Animal转为Dog来引用Dog;(将a变量赋给d)<br>6.3:a和d都指向堆中同一个Dog对象。</p><hr><p>7：d.eat();//从Dog方法中压栈执行eat()方法，然后弹栈;<br>8：d.shudy();//从Dog方法中压栈执行shudy()方法，然后弹栈;<br>9：Cat c = (Cat) a;<br>9.1:在栈中开辟一块区域，存储类型：Cat,变量名称:c<br>9.2:将a向下转型，将Anmail引用Dao转为Cat引用Dog;结果抛出类型转换异常。Dog不能被转为Cat;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><ol><li>概述:<blockquote><p>分析出解决问题所需的步骤，用函数把这些步骤一步一步实现，使用的时候一个一个依次调用</p></blockquote></li><li>特点:<ul><li><font color="red">强调的是功能行为</font></li><li><font color="red">关注的是解决问题需要哪些步骤</font></li></ul></li><li>优缺点:<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul></li></ol><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>概述:<blockquote><p>把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为</p></blockquote></li><li>特点:<ul><li><font color="red">将功能封装进对象，强调具备了功能的对象</font></li><li><font color="red">关注的是解决问题需要哪些对象</font></li></ul></li><li>优缺点:<ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul></li></ol><hr><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ol><li>概述:<blockquote><p>类 是一个模板，它描述一类对象的行为和状态,是具有相同属性和行为的一类事物的抽象。<br>对象 是类的具体体现(实例),有状态和行为;对象的状态就是属性,行为通过方法体现。</p></blockquote></li><li>创建类和创建对象的步骤<ul><li>抽取出具有相同属性和行为的一类对象，封装成一个类。</li><li>使用类去创建对象。</li></ul></li><li>创建类 格式<ul><li>找到属性和行为：<ul><li>属性一般使用变量来体现。</li><li>行为一般使用方法来体现。</li></ul></li></ul></li></ol><pre class=" language-Java"><code class="language-Java">public class 类名&#123;       //类名大写字母开头  //属性  //行为&#125;</code></pre><ol start="4"><li>创建对象 格式<ul><li>类名 对象名 = new 类名();</li></ul></li></ol><pre class=" language-Java"><code class="language-Java">Student stu1 = new Student();</code></pre><hr><h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法(构造器)"></a>构造方法(构造器)</h2><p>概述:</p><blockquote><p>用来创建对象的方法,只能在创建对象时调用<br>编译器会提供一个默认构造方法(无参),创建对象时至少要调用一个构造方法<br>构造方法的名称必须与类名相同,构造方法传参是为了给属性赋值,构造方法的返回值是对象的地址值<br>  　this的本质就是“创建好的的对象的地址”, 由于在构造方法调用前,对象已经创建. 因此,在构造方法中也可以使用this代表“当前对象”.</p></blockquote><pre class=" language-Java"><code class="language-Java">//无参构造方法public class 类名()&#123;&#125;</code></pre><hr><h2 id="成员变量-实例变量-属性-局部变量"><a href="#成员变量-实例变量-属性-局部变量" class="headerlink" title="成员变量(实例变量,属性),局部变量"></a>成员变量(实例变量,属性),局部变量</h2><h3 id="成员变量-实例变量-属性"><a href="#成员变量-实例变量-属性" class="headerlink" title="成员变量(实例变量,属性)"></a>成员变量(实例变量,属性)</h3><ul><li>概述:<ul><li>类中，方法外，叫做成员变量</li></ul></li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li>概述:<ul><li>写在方法中，叫局部变量</li></ul></li></ul><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>局部变量不赋值不能使用，成员变量不赋值有默认值</li><li>作用范围不同，局部变量只能在定义的方法中使用，成员变量在类的所有的方法中都可以使用。</li><li>内存不同。局部变量在栈区，成员变量在堆区。</li><li>生命周期不同，局部变量会在方法被调用时创建，方法结束销毁;成员变量随着对象的创建而存在，随着对象的销毁而销毁。</li><li>如果成员变量和局部变量名字相同，优先会使用局部变量。如果想要使用成员变量，需要加上this关键字。</li><li>调用方式:<ul><li>调用成员变量:   对象.变量名</li><li>调用局部变量:   变量名</li></ul></li></ul><h2 id="静态成员-静态变量与静态方法"><a href="#静态成员-静态变量与静态方法" class="headerlink" title="静态成员: 静态变量与静态方法"></a>静态成员: 静态变量与静态方法</h2><ol><li>概述:<br> 有static关键字的变量为静态变量;有static关键字的方法为静态方法,统称为静态成员<br> 静态变量不赋值默认值为null<br> 静态成员在内存的方法区<br> 静态成员随着类的加载而创建,随着类的销毁而销毁</li></ol><ul><li>调用静态变量:   类名.变量名</li><li>调用静态方法:   类名.方法名()</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><ul><li>Java 泛型是 JDK 5 中引入的一个新特性,</li><li><strong><font color="red">泛型的本质是参数化类型，就是所操作的数据类型被指定为一个参数</font></strong></li><li>在不创建新的类型的情况下,通过泛型指定的不同类型来控制形参具体限制的类型</li><li>操作的数据类型被指定为一个参数,这种参数类型可以用在类,接口,方法中,分别被称为泛型类,泛型接口,泛型方法</li><li>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</li></ul><h2 id="java-中泛型标记符："><a href="#java-中泛型标记符：" class="headerlink" title="java 中泛型标记符："></a>java 中泛型标记符：</h2><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java 类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ - 表示不确定的 java 类型</li></ul><h2 id="定义泛型方法的规则："><a href="#定义泛型方法的规则：" class="headerlink" title="定义泛型方法的规则："></a>定义泛型方法的规则：</h2><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 &lt;E&gt;）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等）。</li></ul><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p><ul><li>答案是可以使用 Java 泛型。</li><li>使用 Java 泛型的概念，可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</li></ul><pre class=" language-Java"><code class="language-Java">import java.util.Arrays;public class ArrayUtil&#123;    //  泛型方法;该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用    //  排序    public static <T> void sort(T[] t) &#123;        try &#123;            Arrays.sort(t);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;import java.util.Arrays;public class Run &#123;    public static void main(String[] args) &#123;        String[] stringArray = &#123;"d", "a", "c", "b", "e"&#125;;        Integer[] intArray = &#123;3, 43, 64, 2, 43, 45, 67, 9&#125;;        Double[] doubleArray = &#123;23.43, 3.4, 24.4, 4.4, 74.3&#125;;        ArrayUtil.sort(stringArray);        ArrayUtil.sort(intArray);        ArrayUtil.sort(doubleArray);        System.out.println(Arrays.toString(stringArray));        System.out.println(Arrays.toString(intArray));        System.out.println(Arrays.toString(doubleArray));    &#125;&#125;</code></pre><h2 id="泛型的非限定通配符"><a href="#泛型的非限定通配符" class="headerlink" title="泛型的非限定通配符"></a>泛型的非限定通配符</h2><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;public class Run &#123;    public static void main(String[] args) &#123;      //集合，里面存储字符串      ArrayList<String> list1 = new ArrayList<>();      //集合，里面存储整数      ArrayList<Integer> list2 = new ArrayList<>();      list1.add("asbgrgh");      list2.add(15);      fun(list1);      fun(list2);    &#125;    //  ?是通配符,泛指所有类型的数据    public static void fun(ArrayList<?> list) &#123;      System.out.println(list);    &#125;&#125;</code></pre><h2 id="泛型的限定通配符"><a href="#泛型的限定通配符" class="headerlink" title="泛型的限定通配符"></a>泛型的限定通配符</h2><ul><li><font color="red">List&lt;? extends T&gt;可以接受任何继承自T的类型的List</font></li><li><font color="red">List&lt;? super T&gt;可以接受任何T的父类构成的List</font></li></ul><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;public class Run &#123;    public static void main(String[] args) &#123;        // String ->  Object                       //      String 是 Object的子类        // Integet ->  Number  -> Object            //      Integer 是 Number的子类, Number 是 Object 的子类        //  String  类型集合        ArrayList<String> stringArrayList = new ArrayList<>();        //  Integer 类型集合        ArrayList<Integer> integerArrayList = new ArrayList<>();          //  Object  类型集合        ArrayList<Object> objectArrayList = new ArrayList<>();          //  Number  类型集合        ArrayList<Number> numberArrayList = new ArrayList<>();        //  fun1(stringArrayList);        //  fun1(objectArrayList);        //  fun1(integerArrayList);        //  fun1(numberArrayList);        //  fun2(stringArrayList);        //  fun2(objectArrayList);        //  fun2(integerArrayList);        //  fun2(numberArrayList);    &#125;    //  上限    只支持Number及Number的子类    public static void fun1(ArrayList<? extends Number> list)&#123;        System.out.println("123");    &#125;    //  下限    只支持Number及Number的父类,包括Object    public static void fun2(ArrayList<? super Number> list)&#123;        System.out.println("123");    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口-英文：Interface"><a href="#接口-英文：Interface" class="headerlink" title="接口 (英文：Interface)"></a>接口 (英文：Interface)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口以<font color="red">interface</font>关键字来声明。<br>类描述对象的属性和方法;接口则包含类要实现的方法<br>除非实现接口的类是抽象类，否则该类要实现接口中的所有方法</p><h2 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新:"></a>版本更新:</h2><ul><li>接口在jdk8之前，接口中只能有抽象方法,</li><li>jdk8之后，接口中可以有默认方式和静态方法，jdk9之后可以有私有方法</li></ul><h2 id="抽象类与接口的相同点"><a href="#抽象类与接口的相同点" class="headerlink" title="抽象类与接口的相同点:"></a>抽象类与接口的相同点:</h2><ul><li>不能实例化对象</li></ul><h2 id="抽象类与接口的区别-面试题"><a href="#抽象类与接口的区别-面试题" class="headerlink" title="抽象类与接口的区别(面试题):"></a>抽象类与接口的区别(面试题):</h2><ol><li>构造方法:<ul><li>抽象类  ：有构造方法。用于子类继承父类的时候给父类成员初始化。</li><li>接口    : 没有构造方法</li></ul></li><li>成员<ul><li>抽象类  :有变量，有常量;有具体的实现方法,有抽象方法</li><li>接口    : 只有常量;jdk1.8前只能有抽象方法。jdk1.8后，可以有默认方法，静态方法，jdk1.9后可以有私有方法。</li></ul></li><li>抽象概念<ul><li>抽象类  : 抽象类对类整体进行抽象，包括属性、行为,是对一种事物的抽象，即对类抽象</li><li>接口    : 接口是对行为的抽象</li></ul></li><li>设计层面<ul><li>抽象类  :抽象类作为很多子类的父类，它是一种模板式设计;抽象类加入新的具体方法时，那么所有的子类都继承到了这个新方法</li><li>接口    :接口是一种行为规范，它是一种辐射式设计;接口加入新的抽象方法时，那么所有的子类都必须重写这个新方法</li></ul></li></ol><h2 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h2><pre class=" language-Java"><code class="language-Java">//  接口：public interface 类名&#123;    // 接口中只可定义常量,不可定义变量    public static final 常量名;    //   抽象方法    public abstract void training();    // 默认方法    default void fun2() &#123;        //在jdk1.8后，接口中可以有默认方法，不常用    &#125;    // 静态方法    public static void fun3() &#123;        // 在jdk1.8后，接口中可以有静态方法，不常用    &#125;    // 私有方法    private void fun4() &#123;        //jdk1.9后，接口中可以放私有方法，不常用    &#125;&#125;</code></pre><h2 id="接口的继承与实现"><a href="#接口的继承与实现" class="headerlink" title="接口的继承与实现:"></a>接口的继承与实现:</h2><ul><li>接口无法被实例化，但是可以被实现</li></ul><pre class=" language-Java"><code class="language-Java">// 接口与接口可以多重继承,也可以多次继承public interface 子接口名称 extends 父接口名称1,父接口名称2&#123;&#125;// 类与接口可以多实现public class 类名称 implements 接口名称1,接口名称2&#123;&#125;</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断对象的类型</p><pre class=" language-Java"><code class="language-Java">// 判断object属不属于class的类型if(object instanceof class)&#123;//是class类型为true&#125;else&#123;//不是class类型为false&#125;</code></pre><h2 id="抽象类和接口的应用场景"><a href="#抽象类和接口的应用场景" class="headerlink" title="抽象类和接口的应用场景"></a>抽象类和接口的应用场景</h2><ul><li>拥有一些方法并且想有一些有默认实现，使用抽象类。</li><li>实现多重继承，必须使用接口。由于Java不支持多继承，子类不能继承多个类，但可以实现多个接口。因此可以使用接口来解决。</li><li>基本功能在不断改变，就需要使用抽象类。如果使用接口，那么就需要改变所有实现了该接口的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Java语言中，用abstract 关键字来修饰一个类时，这个类叫作抽象类。</li><li>抽象类是它的所有子类的公共属性的集合，是包含一个或多个抽象方法的类。</li><li>抽象类可以看作是对类的进一步抽象。在面向对象领域，抽象类主要用来进行类型隐藏</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>抽象类的作用在于将许多有关的类组织在一起，提供一个公共的类，而那些被组织在一起的具体的类作为其子类而派生出来。</li><li>抽象类刻画了公有行为的特征，并通过继承机制传送给它的派生类。</li><li>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类</li><li>除抽象类不能实例化对象之外;类的其它功能和普通类一样。</li><li>抽象类不能实例化对象，所以抽象类必须被继承，才能被使用</li><li>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。</li></ul><h3 id="抽象类示例"><a href="#抽象类示例" class="headerlink" title="抽象类示例"></a>抽象类示例</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名称<span class="token punctuation">(</span><span class="token punctuation">)</span>；</code></pre><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><h3 id="抽象方法的由来"><a href="#抽象方法的由来" class="headerlink" title="抽象方法的由来"></a>抽象方法的由来</h3><ul><li>如果要让某个方法的具体实现由它的子类确定，那么可以在父类中声明该方法为抽象方法。</li><li>抽象方法使用abstract 关键字来声明，抽象方法只包含一个方法名，而没有方法体。</li><li>Java语法规定，包含抽象方法的类就是抽象类。</li></ul><h3 id="抽象方法示例"><a href="#抽象方法示例" class="headerlink" title="抽象方法示例"></a>抽象方法示例</h3><pre class=" language-java"><code class="language-java">修饰符 <span class="token keyword">abstract</span> 返回值类型 方法名 <span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span>；</code></pre><h2 id="抽象类的使用"><a href="#抽象类的使用" class="headerlink" title="抽象类的使用"></a>抽象类的使用</h2><pre class=" language-Java"><code class="language-Java">//定义抽象类public abstract class AbstractDemo &#123;    public AbstractDemo() &#123;&#125;    // 定义抽象方法    public abstract void demo();&#125;//定义继承实现类public  class AbstractDemoSon extends AbstractDemo &#123;    public AbstractDemo() &#123;&#125;    // 这里必须实现父类中的抽象方法,否则该类必须声明为抽象类    public  void demo()&#123;&#125;;&#125;</code></pre><h3 id="抽象类的使用细节"><a href="#抽象类的使用细节" class="headerlink" title="抽象类的使用细节"></a>抽象类的使用细节</h3><ol><li>抽象类不能创建对象，只能创建 子类不为抽象类(就是继承的子类不是抽象类,实现了抽象方法的类) 的对象。</li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 </li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关键字</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>概述:</p><ol><li>this表示一个对象的引用,它指向正在执行的对象. </li><li>在构造方法中,通过this关键字调用其他构造方法时,必须放在第一行, 且在构造方法中, 只能通过this调用一次其他构造方法</li></ol><p>使用</p><ol><li>调用当前对象的属性: this.属性名</li><li>调用当前对象的方法: this.方法名</li></ol><hr><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>概述:<br>  创建子类对象的时候，会调用子类的构造方法，子类构造方法执行之前，会默认访问父类的无参构造。</p><p>使用</p><ul><li>调用父类的无参构造:   super()</li><li>调用父类的带参构造:   super(参数)</li><li>调用父类的成员变量:   super.变量名;    </li><li>调用父类的方法:       super.方法名();</li></ul><hr><h2 id="this-amp-amp-super-注意事项"><a href="#this-amp-amp-super-注意事项" class="headerlink" title="this &amp;&amp; super  !注意事项"></a>this &amp;&amp; super  !注意事项</h2><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li></ul><hr><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>用来表达类与类之间的继承关系;类之类只可多重继承,不可多次继承</p><pre class=" language-Java"><code class="language-Java">public class A extends B&#123;&#125;</code></pre><p>用来表达接口与接口之间的继承关系;接口与接口可以多重继承,也可以多次继承</p><pre class=" language-Java"><code class="language-Java">public interface 子接口名称 extends 父接口名称1,父接口名称2&#123;&#125;</code></pre><hr><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>用来声明接口</p><pre class=" language-Java"><code class="language-Java">// 声明方式public interface 接口名称&#123;&#125;</code></pre><hr><h2 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h2><p>类用来实现接口</p><pre class=" language-Java"><code class="language-Java">// 单实现public class 类名称 implements 接口名称&#123;&#125;// 多实现public class 类名称 implements 接口名称1,接口名称2&#123;&#125;</code></pre><hr><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断对象的类型</p><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><h3 id="访问修饰符-权限修饰符"><a href="#访问修饰符-权限修饰符" class="headerlink" title="访问修饰符(权限修饰符)"></a>访问修饰符(权限修饰符)</h3><h4 id="权限控制表"><a href="#权限控制表" class="headerlink" title="权限控制表"></a>权限控制表</h4><ul><li>YES:可以访问</li><li>NO:不可以访问</li></ul><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一包内</th><th>子孙类(同一包)</th><th>子孙类(不同包)</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>protected</td><td>YES</td><td>YES</td><td>YES</td><td>YES/NO</td><td>NO</td></tr><tr><td>default</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>private</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><h4 id="public-公共的"><a href="#public-公共的" class="headerlink" title="public 公共的"></a>public 公共的</h4><h4 id="protected-受保护的-不能修饰外部类"><a href="#protected-受保护的-不能修饰外部类" class="headerlink" title="protected 受保护的(不能修饰外部类)"></a>protected 受保护的(不能修饰外部类)</h4><ul><li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li></ul><h4 id="default-默认的，什么修饰符都不加"><a href="#default-默认的，什么修饰符都不加" class="headerlink" title="default 默认的，什么修饰符都不加"></a>default 默认的，什么修饰符都不加</h4><h4 id="private-私有的-不能修饰外部类"><a href="#private-私有的-不能修饰外部类" class="headerlink" title="private 私有的(不能修饰外部类)"></a>private 私有的(不能修饰外部类)</h4><h3 id="非访问修饰符-状态修饰符"><a href="#非访问修饰符-状态修饰符" class="headerlink" title="非访问修饰符(状态修饰符)"></a>非访问修饰符(状态修饰符)</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>用来修饰静态成员;包含类方法(静态方法)和类变量(静态变量)</p><ol><li>概述:<br> 有static关键字的变量为静态变量;有static关键字的方法为静态方法,统称为静态成员<br> 静态变量不赋值默认值为null<br> 静态成员在内存的方法区<br> 静态成员随着类的加载而创建,随着类的销毁而销毁</li></ol><ul><li>调用静态变量:   类名.变量名</li><li>调用静态方法:   类名.方法名()</li></ul><ol start="2"><li>注意:<br> 静态变量只有一份拷贝。局部变量不能被声明为 static 变量<br> 静态成员只能调用静态成员</li></ol><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li><p>概述<br> final是一个修饰符，作用是：最终的，不可改变的意思。</p></li><li><p>作用<br> 修饰类，类为最终类，类不能被继承。<br> 修饰变量，变量为常量，只能被赋值1次，值不能改变。<br> 修饰方法，方法不能被重写</p></li><li><p>注意<br> final修饰成员变量，变量的值必须要给初始化，值不能改变。<br> final修饰局部变量，变量的值允许赋值一次，值不能改变。<br> final修饰基本类型，基本类型的值不能改变。<br> final修饰引用类型，引用类型的地址值不能改变,内部数据可以改变<br> final使用大写字母来表示</p></li><li><p>例</p><pre class=" language-Java"><code class="language-Java">//  被final修饰的类不能被继承public final class  Demo1 &#123;//  final修饰基本类型，基本类型的值不能改变。//  final修饰引用类型，引用类型的地址值不能改变;内部数据可以改变        //  final修饰成员变量    public static final String CONSTANT = "String";    public void test()&#123;        //  final修饰局部变量        final int CONSTANT = 123456;    &#125;&#125;</code></pre><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>用来声明抽象类和抽象方法</p><pre class=" language-Java"><code class="language-Java">//抽象类public abstract 类名称&#123;//抽象方法public abstract 抽象方法名称();&#125;//接口public interface 接口名称&#123;//抽象方法public abstract 抽象方法名称();&#125;</code></pre></li></ol><h4 id="synchronized-和-volatile-修饰符，主要用于线程的编程"><a href="#synchronized-和-volatile-修饰符，主要用于线程的编程" class="headerlink" title="synchronized 和 volatile 修饰符，主要用于线程的编程"></a>synchronized 和 volatile 修饰符，主要用于线程的编程</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存详解</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>方法区</p><ul><li>运行时常量池</li><li>自动和方法数据</li><li>构造函数和普通方法的字节码内容</li><li>一些特殊方法<br>堆区</li></ul><p>栈区</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java修饰符</title>
      <link href="/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2021/12/29/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><blockquote><p>是一个状态修饰符。静态的意思。被此修饰符修饰的成员为静态成员。</p></blockquote><h2 id="静态"><a href="#静态" class="headerlink" title="静态:"></a>静态:</h2><p>  1）静态成员不属于对象，会随着类的加载而加载，随着类的销毁而销毁。存在方法区中。<br>  2）静态成员可以通过类名直接访问<br>  3）静态成员只能访问静态成员。<br>  例:</p><pre class=" language-Java"><code class="language-Java">public class Demo1 &#123;  //  静态成员变量  static String name;  //  静态成员方法  public static void test() &#123;    &#125;&#125;</code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><p>静态代码块(只会执行一次，在类加载时执行)<br>构造代码块（每次创建对象都会执行，在构造方法前执行）<br>局部代码块（主要用于限制变量的作用域，了解）<br>例:</p><pre class=" language-Java"><code class="language-Java">public class Demo1 &#123;  //  静态代码块  static &#123; &#125;  //  构造代码块  &#123;  &#125;  public void test2() &#123;    //局部代码块    &#123; &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接池</title>
      <link href="/2021/12/28/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2021/12/28/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  是一种容器;使用集合来存储连接对象<br>  属于DriverManager的强化版;用来替代DriverManager<br>  接口:<code>javax.sql.DataSource</code>定义基础获取数据库连接的接口<br>  接口:<code>javax.sql.ConnectionPoolDataSource</code>：定义从数据库连接池中获取连接的接口<br>  接口:<code>javax.sql.XADataSource</code>：定义获取分布式事务连接的接口。一般少有直接使用 XA 分布式事务，具体原因参考分布式 2PC、3PC 事务模型</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>可以节省创建连接和释放连接的时间，提高效率</li><li>同一个连接可以被多次使用</li><li>可以进行连接的管理。使用连接池之后，close方法不再是关闭连接，而是归还到连接池</li></ol><h2 id="连接池实现"><a href="#连接池实现" class="headerlink" title="连接池实现"></a>连接池实现</h2><h3 id="有各种第三方实现"><a href="#有各种第三方实现" class="headerlink" title="有各种第三方实现:"></a>有各种第三方实现:</h3><ul><li>c3p0  <ul><li>c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象</li><li>c3p0有自动回收空闲连接功能</li></ul></li><li>dbcp  <ul><li>依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP;DBCP（DataBase Connection Pool）数据库连接池，是apache上的一个java连接池项目，也是tomcat使用的连接池组件。单独使用dbcp需要两个包：commons-dbcp.jar,commons-pool.jar</li><li>dbcp没有自动回收空闲连接的功能</li></ul></li><li>druid <ul><li>阿里提供的连接池技术</li></ul></li></ul><h3 id="第三方实现的使用"><a href="#第三方实现的使用" class="headerlink" title="第三方实现的使用"></a>第三方实现的使用</h3><ul><li><p>c3p0</p><ol><li>导入c3p0的jar包以及c3p0的依赖包和jdbc的jar包</li><li>编写配置文件,配置文件类型可以是properties和xml</li></ol><ul><li>名称：c3p0.properties 或c3p0-config.xml;<strong>c3p0会自动扫描配置文件,所以名称必须是这两种</strong></li></ul><ol start="3"><li>创建数据连接池对象(数据源对象)<br> <code>DataSource  ds = new ComboPooledDataSource();</code></li></ol></li><li><p>druid</p><ol><li>导入druid的jar包和jdbc的jar包</li><li>编写配置文件,名称随意,配置文件类型为properties;</li></ol><p>  <strong>注意:<font color="red">该文件不能有多余的空格,否则会读取入项目中</font></strong></p><ul><li>内容<pre class=" language-Properties"><code class="language-Properties"># jdbc配置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/day04?useUnicode=true&characterEncoding=utf-8username=rootpassword=root# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000</code></pre></li></ul><ol start="3"><li>创建JdbcUtil工具类;内容如下:</li></ol><ul><li><p>内容:</p><pre class=" language-Java"><code class="language-Java">package cn.jdbc.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JdbcUtil &#123;    private static DataSource dataSource = null;    static &#123;        //  创建Properties类对象        Properties properties = new Properties();        //  使用当前类的类加载器的getResourceAsStream("配置文件地址") 用于获取输入流Stream内容(读取配置文件)        InputStream is = JdbcUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");        try &#123;            //  使用Properties类对象的load(输入流Stream)加载输入流内容            properties.load(is);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        try &#123;            //  DruidDataSourceFactory  数据源工厂            //  createDataSource(加载配置文件后的Properties类对象)  创建数据源            dataSource = DruidDataSourceFactory.createDataSource(properties);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /*     *  获取连接对象     */    public static Connection getConnection() &#123;        try &#123;            return dataSource.getConnection();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**    * 释放资源    */    public static void close(Statement stmt, Connection conn) &#123;        close(null, stmt, conn);    &#125;    /**    * 释放资源    */    public static void close(ResultSet rs, Statement stmt, Connection conn) &#123;        if (rs != null) &#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (stmt != null) &#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (conn != null) &#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**    * 获取连接池(数据源)    */    public static DataSource getDataSource() &#123;        return dataSource;    &#125;  &#125;</code></pre></li></ul></li></ul><h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>  由apache基金会提供,对jdbc的操作进行了优化</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>创建QueryRunner类,传入jdbc数据源(连接池)<br><code>QueryRunner queryRunner = new QueryRunner(JdbcUtil.getDataSource());</code></p></li><li><p>使用</p></li></ol><ul><li>增,删,改 调用<code>QueryRunner</code>对象的<code>update(sql语句,占位符填充数据...);</code></li><li>查单个 调用<code>QueryRunner</code>对象的<code>query(sql语句,new BeanHandler&lt;&gt;(Bean对象(又称实体类对象).class),占位符填充数据...);</code><br><code>new BeanHandler&lt;&gt;(Bean对象(又称实体类对象).class)</code>;作用:创建Bean处理器对象传入bean对象,内部进行反射解析;将查询的数据映射在该类型对象的属性上,</li><li>查多个   调用<code>QueryRunner</code>对象的<code>query(sql语句,new BeanListHandler&lt;&gt;(Bean对象(又称实体类对象).class),占位符填充数据...);</code><br><code>new BeanListHandler&lt;&gt;(Bean对象(又称实体类对象).class)</code>;作用:创建Bean处理器集合对象传入bean对象,内部进行反射解析;将查询的数据映射在该类型对象的属性上,并将对象存入List集合中</li><li>查个数<pre class=" language-Java"><code class="language-Java">  //  ScalarHandler用来查询个数如count查询;返回类型为Object或Long;一般整数类型为int;所以这里进行强转  Object obj = queryRunner.query("select count(1)  from emp where ename like ? ", new ScalarHandler(),"%"+name+"%");   Integer.parseInt(String.valueOf(obj));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 代理模式</title>
      <link href="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E4%BB%A3%E7%90%86/"/>
      <url>/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>代理模式（Proxy）是通过代理对象访问目标对象<br><img src="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E4%BB%A3%E7%90%86/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.webp"><br><img src="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E4%BB%A3%E7%90%86/%E4%BB%A3%E7%90%86%E7%BB%93%E6%9E%84.webp"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在目标对象基础上增强额外的功能</p><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>代理对象是对目标对象的扩展,并会调用目标对象</p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>需要定义父类或接口,目标对象与代理对象一起实现相同的接口或继承相同的父类,通过调用相同的方法来调用目标对象的方法</li><li>缺点: 接口或父类增加方法,目标对象与代理对象都要维护,增加维护成本</li></ul><h4 id="静态代理案例"><a href="#静态代理案例" class="headerlink" title="静态代理案例"></a>静态代理案例</h4><p>AdminService.java接口</p><pre class=" language-Java"><code class="language-Java">public interface AdminService &#123;    void update();    Object find();&#125;</code></pre><p>AdminServiceImpl.java实现类</p><pre class=" language-Java"><code class="language-Java">public class AdminServiceImpl implements AdminService&#123;    public void update() &#123;        System.out.println("修改管理系统数据");    &#125;    public Object find() &#123;        System.out.println("查看管理系统数据");        return new Object();    &#125;&#125;</code></pre><p>AdminServiceProxy.java代理类</p><pre class=" language-Java"><code class="language-Java">public class AdminServiceProxy implements AdminService &#123;    private AdminService adminService;    public AdminServiceProxy(AdminService adminService) &#123;        this.adminService = adminService;    &#125;    public void update() &#123;        System.out.println("判断用户是否有权限进行update操作");        adminService.update();        System.out.println("记录用户执行update操作的用户信息、更改内容和时间等");    &#125;    public Object find() &#123;        System.out.println("判断用户是否有权限进行find操作");        System.out.println("记录用户执行find操作的用户信息、查看内容和时间等");        return adminService.find();    &#125;&#125;</code></pre><p>测试类StaticProxyTest.java</p><pre class=" language-Java"><code class="language-Java">public class StaticProxyTest &#123;    public static void main(String[] args) &#123;        AdminService adminService = new AdminServiceImpl();        AdminServiceProxy proxy = new AdminServiceProxy(adminService);        proxy.update();        System.out.println("=============================");        proxy.find();    &#125;&#125;</code></pre><h3 id="动态代理-jdk代理-接口代理"><a href="#动态代理-jdk代理-接口代理" class="headerlink" title="动态代理(jdk代理,接口代理)"></a>动态代理(jdk代理,接口代理)</h3><ul><li>特点: <ol><li>代理对象不需要实现接口或继承父类</li><li>代理对象的生成利用JDK的Api，在JVM内存中动态的构建Proxy对象。</li><li>需要使用<code>java.lang.reflect.Proxy</code>类的<code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler)</code></li></ol><ul><li>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler)详解<ul><li>ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的；</li><li>Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型</li><li>InvocationHandler invocationHandler:事件处理,执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。</li></ul></li></ul></li></ul><h4 id="动态代理案例"><a href="#动态代理案例" class="headerlink" title="动态代理案例"></a>动态代理案例</h4><p>AdminServiceImpl.java和AdminService.java和原来一样</p><p>AdminServiceInvocation.java</p><pre class=" language-Java"><code class="language-Java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class AdminServiceInvocation  implements InvocationHandler &#123;    private Object target;    public AdminServiceInvocation(Object target) &#123;        this.target = target;    &#125;    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println("判断用户是否有权限进行操作");       Object obj = method.invoke(target);        System.out.println("记录用户执行操作的用户信息、更改内容和时间等");        return obj;    &#125;&#125;</code></pre><p>AdminServiceDynamicProxy.java</p><pre class=" language-Java"><code class="language-Java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class AdminServiceDynamicProxy &#123;    private Object target;    private InvocationHandler invocationHandler;    public AdminServiceDynamicProxy(Object target,InvocationHandler invocationHandler)&#123;        this.target = target;        this.invocationHandler = invocationHandler;    &#125;    public Object getPersonProxy() &#123;        Object obj = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocationHandler);        return obj;    &#125;&#125;</code></pre><p>DynamicProxyTest.java</p><pre class=" language-Java"><code class="language-Java">package com.lance.proxy.demo.service;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxyTest &#123;    public static void main(String[] args) &#123;        // 方法一        System.out.println("============ 方法一 ==============");        AdminService adminService = new AdminServiceImpl();        System.out.println("代理的目标对象：" + adminService.getClass());        AdminServiceInvocation adminServiceInvocation = new AdminServiceInvocation(adminService);        AdminService proxy = (AdminService) new AdminServiceDynamicProxy(adminService, adminServiceInvocation).getPersonProxy();        System.out.println("代理对象：" + proxy.getClass());        Object obj = proxy.find();        System.out.println("find 返回对象：" + obj.getClass());        System.out.println("----------------------------------");        proxy.update();        //方法二        System.out.println("============ 方法二 ==============");        AdminService target = new AdminServiceImpl();        AdminServiceInvocation invocation = new AdminServiceInvocation(adminService);        AdminService proxy2 = (AdminService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocation);        Object obj2 = proxy2.find();        System.out.println("find 返回对象：" + obj2.getClass());        System.out.println("----------------------------------");        proxy2.update();        //方法三        System.out.println("============ 方法三 ==============");        final AdminService target3 = new AdminServiceImpl();        AdminService proxy3 = (AdminService) Proxy.newProxyInstance(target3.getClass().getClassLoader(), target3.getClass().getInterfaces(), new InvocationHandler() &#123;            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println("判断用户是否有权限进行操作");                Object obj = method.invoke(target3, args);                System.out.println("记录用户执行操作的用户信息、更改内容和时间等");                return obj;            &#125;        &#125;);        Object obj3 = proxy3.find();        System.out.println("find 返回对象：" + obj3.getClass());        System.out.println("----------------------------------");        proxy3.update();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式，即Design Patterns，在软件设计中，被反复使用的一种代码设计经验  </p><p><strong>使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性</strong></p><h2 id="使用设计模式的原因"><a href="#使用设计模式的原因" class="headerlink" title="使用设计模式的原因"></a>使用设计模式的原因</h2><p>根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度</p><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>设计模式主要是基于OOP编程提炼的，它基于以下几个原则<br>单一职责原则：每个类应该专注于做一件事情<br>里氏替换原则：超类存在的地方，子类是可以替换的<br>依赖倒置原则：实现尽量依赖抽象，不依赖具体实现<br>接口隔离原则：应当尽量为客户端提供小的单独的接口，而不是提供大的总的接口<br>迪米特法则：又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用<br>开闭原则：面向扩展开放，面向修改关闭<br>组合/聚合原则：尽量使用组合聚合来达到复用效果，尽量少使用继承。继承一定程度上是牺牲了封装性来达到复用的效果的，这样有时是得不偿失的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ab工具</title>
      <link href="/2021/12/22/%E9%AB%98%E5%8E%8B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/ab%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/12/22/%E9%AB%98%E5%8E%8B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/ab%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="ab-压力测试工具"><a href="#ab-压力测试工具" class="headerlink" title="ab(压力测试工具)"></a>ab(压力测试工具)</h2><p>httpd-tools<br>安装命令:（yum install -y httpd-tools）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>ab  -n（一次发送的请求数）  -c（请求的并发数） 访问路径</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在缓存(redis)中存num,初始值为0<br>使用缓存中的StringRedisTemplate获取到当前的num值<br>若num不为空,则对当前num+1;并写回缓存<br>若num为空,则直接返回</p><h3 id="直接测试"><a href="#直接测试" class="headerlink" title="直接测试"></a>直接测试</h3><p>  数据错误</p><h3 id="测试本地锁-synchronized"><a href="#测试本地锁-synchronized" class="headerlink" title="测试本地锁(synchronized):"></a>测试本地锁(synchronized):</h3><pre><code> 单服务    结果：没有问题 多服务(集群)   server.port 8206  server.port 8226  server.port 8236   结果：数据错误</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>测试本地锁: 单击版本  没有问题</p><p>测试本地锁: 分布式式, 多个服务</p><p>有问题: synchronized 在一个tomcat中是没有问题的,在jvm内存<br>   分布式:  多个tomcat中,  多个jvm虚拟中.没有办法控制线程安全问题.</p>]]></content>
      
      
      <categories>
          
          <category> 高压测试工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类负责创建自己的对象，同时确保只有单个对象被创建;<br>提供访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol><li>单例类只能有一个实例(构造方法私有化)</li><li>单例类必须自己创建自己的唯一实例(创建自己的对象)</li><li>单例类必须给所有其他对象提供这一实例(提供对外的静态方法并返回唯一的对象)</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>主要解决：一个全局使用的类频繁地创建与销毁。<br>何时使用：当您想控制实例数目，节省系统资源的时候。<br>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>1、一个班级只有一个班主任。<br>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）<br>2、避免对资源的多重占用（比如写文件操作）<br>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>  懒汉式:类调用时创建唯一实例对象<br>  饿汉式:类加载时创建唯一实例对象</p><h2 id="饿汉式与懒汉式的区别"><a href="#饿汉式与懒汉式的区别" class="headerlink" title="饿汉式与懒汉式的区别"></a>饿汉式与懒汉式的区别</h2><p>饿汉式<br>    /**<br>     *是否 Lazy 初始化：否<br>     *是否多线程安全：是<br>     *实现难度：易<br>     *描述：这种方式比较常用，但容易产生垃圾对象。<br>     *优点：没有加锁，执行效率会提高。<br>     *缺点：类加载时就初始化，浪费内存。<br>     <em>它基于 classloder 机制避免了多线程的同步问题，<br>     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，<br>    * 在单例模式中大多数都是调用 getInstance 方法，<br>     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，<br>     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。<br>     <em>/<br>     懒汉式<br>/</em></em><br>     *是否 Lazy 初始化：是<br>     *是否多线程安全：否<br>     *实现难度：易<br>     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br>     */</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>饿汉式</p><pre class=" language-Java"><code class="language-Java">public class Student&#123;  //  创建自己的对象  private static Student stu = new Student();  //  构造方法私有化  private Student()&#123;&#125;  //  提供外部访问的唯一方式并返回唯一的实例对象  public static Student getStudent()&#123;    return stu;  &#125;&#125;</code></pre><p>懒汉式<br><strong>会引发线程安全问题!!!</strong></p><ol><li>同步方法<pre class=" language-Java"><code class="language-Java">public class Student &#123; //  volatile  禁止jvm指令重排 private static volatile Student stu; //  构造方法私有 private Student()&#123; &#125; //  提供外部访问的唯一方式 public static Student getStudent()&#123;     //  没有stu对象时进入     if(stu==null)&#123;         //  为了保证线程安全,这里使用同步代码块         synchronized(Student.class)&#123;             //  同步代码块内部需要再次判断             if(stu==null)&#123;                 stu = new Student();             &#125;         &#125;     &#125;     return stu; &#125;&#125;</code></pre></li><li>内部类<pre class=" language-Java"><code class="language-Java">public class Student &#123; //  构造方法私有化 private Student()&#123;&#125; //  静态内部类 private static class StudentFactory&#123;     //  唯一实例为需要的单例对象     private static Student student = new Student(); &#125; //  提供外部访问的方式,返回内部类的唯一实例 public static Student getStudent()&#123;     return StudentFactory.student; &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Java%20%E5%B7%A5%E5%8E%82/"/>
      <url>/2021/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Java%20%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工厂方法即Factory Method，是一种对象创建型模式</p><h2 id="目的-作用"><a href="#目的-作用" class="headerlink" title="目的(作用)"></a>目的(作用)</h2><p>让创建对象和使用对象分离，并且调用方总是引用抽象工厂和抽象产品</p><pre class=" language-Java"><code class="language-Java">工厂接口//  定义一个用于创建对象的接口public interface NumberFactory &#123;    Number parse(String s);    static NumberFactory impl = new NumberFactoryImpl();    //  获取工厂实例:    //  定义一个静态方法getFactory()来返回真正的子类    static NumberFactory getFactory() &#123;        return impl;    &#125;    &#125;工厂的实现类public class NumberFactoryImpl implements NumberFactory &#123;    public Number parse(String s) &#123;        return new BigDecimal(s);    &#125;&#125;调用方使用NumberFactory factory = NumberFactory.getFactory();Number result = factory.parse("123.456");</code></pre><p>调用方可以完全忽略真正的工厂NumberFactoryImpl和实际的产品BigDecimal，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方</p><h2 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h2><p>通过静态方法直接返回产品</p><pre class=" language-Java"><code class="language-Java">public class NumberFactory&#123;    public static Number parse(String s)&#123;        return new BigDecimal(s);    &#125;&#125;</code></pre><p><code>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）</code><br>静态工厂方法广泛地应用在Java标准库中</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>** 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程**</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p><p>实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。</p><p>调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Servlet封装</title>
      <link href="/2021/12/22/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E5%B0%81%E8%A3%85/"/>
      <url>/2021/12/22/Java/Java%20EE%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8/Java%20Servlet%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p><strong>封装DispatcherServlet.java</strong></p><pre class=" language-Java"><code class="language-Java">import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * servlet封装 * 通过反射的原理,执行方法分发 * 在一个servlet中完成同一资源的操作 */public class DispatcherServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //  设置字符编码        req.setCharacterEncoding("utf-8");        //  获取uri        String requestURI = req.getRequestURI();        //  截取请求资源        String methodName = requestURI.substring(requestURI.lastIndexOf("/") + 1);        Method method = null;        try &#123;            //  使用反射,通过请求资源获取到与该资源同名的方法对象            method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();            //  未找到该方法,返回404            resp.sendRedirect(req.getContextPath() + "/404.jsp");            return;        &#125;        try &#123;            //  执行该方法对象            method.invoke(this, req, resp);        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>使用UserServlet.java</strong></p><pre class=" language-Java"><code class="language-Java">import cn.dy.entity.User;import cn.dy.service.UserService;import cn.dy.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author zrh * @date 2022/2/18 * @apiNote *///  配置资源路径,所有user下的资源都访问这里@WebServlet("/user/*")public class UserServlet extends DispatcherServlet &#123;    private UserService userService = new UserServiceImpl();    /**     * 用户登录     *     * @param request     * @param response     */    public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String username = request.getParameter("username");        String password = request.getParameter("password");        User user = userService.login(username, password);        if (user == null) &#123;            request.setAttribute("msg","用户名或密码错误!");            request.getRequestDispatcher("/fail.jsp").forward(request, response);            return;        &#125;        request.getSession().setAttribute("user", user);        response.sendRedirect(request.getContextPath() + "/index.jsp");    &#125;&#125;</code></pre><p><strong>测试</strong></p><pre class=" language-Java"><code class="language-Java">该服务启动后,浏览器访问该登录资源即可</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java EE企业应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2021/12/22/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/12/22/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>反射就是把Java类中的各个成分映射成一个个的Java对象</li><li>即在运行状态中，对于任意一个类，都能够知道这个类的所以属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制</li></ul><h2 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h2><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>可以在程序运行过程中，操作这些对象</li><li>可以解耦，提高程序的可扩展性</li></ol><h2 id="实现反射机制的类"><a href="#实现反射机制的类" class="headerlink" title="实现反射机制的类"></a>实现反射机制的类</h2><ul><li>Class类：代表一个类 </li><li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li><li>Method类：代表类的方法。</li><li>Constructor类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li></ul><h2 id="反射案例"><a href="#反射案例" class="headerlink" title="反射案例"></a>反射案例</h2><p>创建pojo类</p><pre class=" language-Java"><code class="language-Java">public class Student &#123;    private String name;    private Integer age;    private String grade;    public Student() &#123;    &#125;    public Student(String name, Integer age, String grade) &#123;        this.name = name;        this.age = age;        this.grade = grade;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public String getGrade() &#123;        return grade;    &#125;    public void setGrade(String grade) &#123;        this.grade = grade;    &#125;    @Override    public String toString() &#123;        return "Student&#123;" +                "name='" + name + '\'' +                ", age=" + age +                ", grade='" + grade + '\'' +                '&#125;';    &#125;&#125;</code></pre><p>执行类,注意: <code>setAccessible(true)</code>:暴力反射</p><pre class=" language-Java"><code class="language-Java">import java.lang.reflect.Field;import java.lang.reflect.Method;public class Run &#123;    public static void main(String[] args) throws Exception &#123;        Student student = new Student("张三", 18, "p2");        Object copy = new Run().copy(student);        System.out.println(copy);    &#125;    //    自定义的copy方法用来创建一个和参数objcet同样类型的对象，然后把object对象中的所有属性拷贝到新建的对象中，并将其返回    public Object copy(Object object) throws Exception &#123;        //  1. 获取object的类型        Class classType = object.getClass();        System.out.println("Class:" + classType.getName());        //  2. 通过默认构造方法创建一个新的对象        Object objectCopy = classType.getConstructor(new Class[]&#123;&#125;).newInstance(new Object[]&#123;&#125;);                //  忽略访问权限修饰符的安全检查        fieldName.setAccessible(true);        //  3. 获得对象的所有属性        Field fields[] = classType.getDeclaredFields();        for (int i = 0; i < fields.length; i++) &#123;            Field field = fields[i];            String fieldName = field.getName();            String firstLetter = fieldName.substring(0, 1).toUpperCase();            //获得和属性对应的getXXX()方法的名字            String getMethodName = "get" + firstLetter + fieldName.substring(1);            //获得和属性对应的setXXX()方法的名字            String setMethodName = "set" + firstLetter + fieldName.substring(1);            //获得和属性对应的getXXX()方法            Method getMethod = classType.getMethod(getMethodName, new Class[]&#123;&#125;);            //获得和属性对应的setXXX()方法            Method setMethod = classType.getMethod(setMethodName, new Class[]&#123;field.getType()&#125;);            //调用原对象的getXXX()方法            Object value = getMethod.invoke(object, new Object[]&#123;&#125;);            System.out.println(fieldName + ":" + value);            //调用拷贝对象的setXXX()方法            setMethod.invoke(objectCopy, new Object[]&#123;value&#125;);        &#125;        return objectCopy;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见操作</title>
      <link href="/2021/12/22/%E7%B3%BB%E7%BB%9F/Linux/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/12/22/%E7%B3%BB%E7%BB%9F/Linux/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h2><ol><li>列表的方式显示当前目录<br><code> ll</code>    </li></ol><p>2并排的方式显示     ls</p><p>10.3新建文件夹 mkdir  family</p><p>10.4进入family文件夹   cd family</p><p>创建一个 room-a   room-b  room-c   mkdir room-a room-b room-c </p><p>10.5创建两个文件   father   mother   &gt; father   &gt; mother</p><p>10.6把father和mother移动到 room-a这个房间   剪切命令  mv  father mother room-a</p><p>10.7回到上级目录   cd ..</p><p>10.8创建一个  son  文件   </p><p>把这个文件放到 room-b这个文件下   mv  剪切   重命名</p><p>重命名一下room-c  改成  room-d   mv  room-a room-d  </p><p>把room-d 文件夹删除掉    删除命令  rm -rf room-d</p><p>创建一本书 book文件   &gt; book</p><p>往book文件中写入内容   think in java    echo “think in java” &gt; book</p><p>把book这本书给 room-a一本   复制命令   cp  book  room-a</p><p>再给room-b这个房间一本     mv book room-b</p><p>进入到room-b这个房间,显示一下当前所在的路径   pwd  </p><p>回到family目录     cd ..<br>Cd ..</p><p>查看book文件中的内容   cat book </p><p>命令总结:<br>Cd  进入文件目录<br>Cd ..  回到上个文件目录<br>Cp  复制的文件  复制的目的地<br>Mv  剪切的文件  剪切到的目的地<br>Echo  “think in java” &gt; book    给文件里直接写入内容<br>自动补全   tab</p><p>清屏<br>Ctrl + l</p><p>回到根目录  cd</p><p>Top显示当前电脑进程</p><p>Ctrl + c</p><p>复制命令:  鼠标选中就可以复制</p><p>Wc查看文件大小   wc  install.log<br>[root@localhost ~]# wc install.log<br>  911  1835 39343 install.log</p><p>联想输入:  tab  键     输入完前缀,会联想到后面文件.</p><p>10.9查找文件<br>find  family/room-a -name book<br>10.10创建链接命令</p><p>访问方式:</p><p>10.11显示系统进程<br>Top</p><p>Ctrl+C停止<br>10.12带分页的<br>Ps-ef | more<br>| 这个符号叫管道符号    more是分页的意思。按空格是下一页  按会出是下一行</p><p>10.13显示磁盘情况<br>Df</p><p>10.14显示文件大小<br>Du</p><p>10.15查看网络进程<br>netstat –anu</p><p>10.16查看TCP进程<br>netstat –ant</p><p>11压缩命令<br>11.1第一种压缩格式:  gzip<br>压缩命令:  gzip install.log</p><p>解压命令:gzip -d install.log.gz</p><p>11.2第二种压缩格式: tar<br>压缩命令:tar -czvf f.tar.gz family/</p><p>//    f.tar.gz压缩后的文件名     family 压缩的文件<br>[root@localhost ~]# tar -czvf f.tar.gz family/</p><p>减压命令:</p><p>tar  -zvxf  f.tar.gz </p><p>Z  需要解压文件的格式     v是否显示解压过程   x减压的方式   f 后跟着的是减压的文件名<br>[root@localhost ~]# tar -zxf f.tar.gz </p><p>把压缩包减压到指定文件夹里<br>tar -zvxf f.tar.gz -C dom/</p><p>12Vim命令</p><p>12.1插入命令<br>i    在光标前插入<br>I    在光标当前行开始插入<br>a    在光标后插入<br>A    在光标当前行末尾插入<br>o    在光标当前行的下一行插入新行<br>O    在光标当前行的上一行插入新行<br>按ESC<br>编辑文件,  vim 文件名<br>保存编辑后以后的文件  :wq<br>强制保存:  :wq!<br>不保存,退出   :q<br>强制退出      :q!</p><p>插入文字:    i<br>查找:  /name  </p><p>a 在光标后插入<br>i插入光标前面数据<br>o 在下一行插入</p><p>A在光标当前行末尾插入<br>I在光标当前行插入<br>O在当前光标行的上一行插入数据<br>12.2定位命令<br>按esc  输入 :set nu   显示行号</p><p>:set nu    显示行号<br>:set nonu    取消行号<br>gg    到文本的第一行<br>G    到文本的最后一行<br>:n    到文本的第n行</p><p>12.3删除命令<br>x    删除光标所在处字符<br>nx    删除光标所在处后的n个字符<br>dd    删除光标所在行。ndd删除n行<br>dG    删除光标所在行到末尾行的所有内容<br>D    删除光标所在处到行尾的内容<br>:n1,n2d    删除指定范围的行</p><p>12.4替换和取消命令<br>u    undo，取消上一步操作<br>Ctrl + r    redo，返回到undo之前<br>r    替换光标所在处的字符<br>R    从光标所在处开始替换，按Esc键结束</p><p>12.5查找指定字符<br>/name    name处输入要查找的字符<br>n    向下查找<br>13关机/重启命令<br>13.1halt 关机后关闭电源 </p><p>13.2reboot 重新启动<br>14用户操作和权限控制<br>14.1创建用户<br>[root@localhost ~]# useradd zhangsan<br>14.2查看当前系统的用户<br>[root@localhost ~]# more /ect/passwd<br>14.3给用户设置密码<br>[root@localhost ~]# passwd zhangsans<br>14.4修改用户名<br>[root@localhost ~]# usermod -l lisi zhangsans<br>14.5删除用户<br>[root@localhost ~]# userdel -r lisi<br>15用户权限<br>文件类型:<br>用户<br>用户组<br>用户权限:读,写,执行</p><p>赋予权限的过程:<br>先找到这个文件,把文件赋予某些用户或者用户组的读写和执行权限.</p><p>15.1给当前用户赋予执行权限<br>[root@localhost ~]# chmod u+x anaconda-ks.cfg<br>15.2给用户组一个执行权限<br>[root@localhost ~]# chmod g+x anaconda-ks.cfg<br>15.3给所有的用户都加执行权限<br>包括当前用户,用户组里的所有用户,其他用户<br>[root@localhost ~]# chmod +x anaconda-ks.cfg<br>15.4取消当前用户的执行权限<br>[root@localhost ~]# chmod u-x anaconda-ks.cfg<br>15.5取消所有用户的执行权限<br>[root@localhost ~]# chmod -x anaconda-ks.cfg</p><p>不给当前用户任何权限, 给用户组读的权限,  给其他用户所有权限</p><ul><li> —  –r   -rwx</li><li> 0    4   4+2+1=7<br>[root@localhost ~]# chmod  047 anaconda-ks.cfg </li></ul><p>16网络配置<br>在linux里改ip地址,<br>1.建议使用图形化界面进行修改<br>2.也可以使用命令修改,(不推荐).</p><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h2 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h2><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>linux查看进程的方法：1、ps命令，查看静态的进程统计信息；2、top命令，查看进程动态信息；3、pgrep命令，根据特定条件查询进程PID信息；4、pstree命令，查看进程树，以树形结构列出进程信息。</p><p>本教程操作环境：linux7.3系统、DELL G3电脑，该方法适用于所有品牌电脑。</p><p>linux查看进程的方法：</p><p>1、ps命令——查看静态的进程统计信息（Processes Statistic）</p><p>常见的选项：</p><p>a：显示当前终端下的所有进程信息，包括其他用户的进程。</p><p>u：使用以用户为主的格式输出进程信息。</p><p>x：显示当前用户在所有终端下的进程。</p><p>-e：显示系统内的所有进程信息。</p><p>-l：使用长（long）格式显示进程信息。</p><p>-f：使用完整的（full）格式显示进程信息。</p><p>2、top命令——查看进程动态信息</p><p>以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次，其作用基本类似于Windows系统中的任务管理器。</p><p>3、pgrep命令——根据特定条件查询进程PID信息</p><p>示例：</p><p>adc514be7ef838d588df76a856e2197.png</p><p>4、pstree命令——查看进程树，以树形结构列出进程信息</p><p>示例：</p><p>832c29776fba17ece419f35cdb176c1.png</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class</title>
      <link href="/2021/12/22/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.Class/"/>
      <url>/2021/12/22/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.lang.Class/</url>
      
        <content type="html"><![CDATA[<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>java有两种对象: 实例对象和Class对象</li><li>Class对象: 表示正在运行的 类和接口 的<code>运行时的类型信息</code>,包含了与类和接口有关的信息</li><li>实例对象: 实例对象是通过Class对象来创建的</li><li><code>枚举是一种类，注释是一种接口</code></li><li>每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象</li><li>Class对象对应着<code>java.lang.Class</code>类，如果说类是对象抽象和集合的话，那么Class类就是对类的抽象和集合</li><li>Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象</li><li>Class类继承自Object</li></ul><h2 id="类被加载到内存需要经历如下三个阶段："><a href="#类被加载到内存需要经历如下三个阶段：" class="headerlink" title="类被加载到内存需要经历如下三个阶段："></a>类被加载到内存需要经历如下三个阶段：</h2><ul><li>加载，这是由类加载器（ClassLoader）执行的;<code>生成一个代表这个类的java.lang.Class对象</code><br>通过一个类的全限定名来获取其定义的二进制字节流（Class字节码），将这个字节流所代表的静态存储结构转化为方法去的运行时数据接口，根据字节码在java堆中生成一个代表这个类的java.lang.Class对象。</li><li>链接;<code>为静态域分配存储空间并设置类变量的初始值</code><br>在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求，为静态域分配存储空间并设置类变量的初始值（默认的零值），并且如果必需的话，将常量池中的符号引用转化为直接引用。</li><li>初始化;<code>真正开始执行类中定义的java程序代码</code><br>到了此阶段，才真正开始执行类中定义的java程序代码。用于执行该类的静态初始器和静态初始块，如果该类有父类的话，则优先对其父类进行初始化。</li></ul><h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2><ul><li>所有的类都是在对其第一次使用时，动态加载到JVM中的（懒加载）。当程序创建第一个对类的静态成员的引用时，就会加载这个类。使用new创建类对象的时候也会被当作对类的静态成员的引用。动态加载:<code>java程序程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的</code></li><li>在类加载阶段，类加载器首先检查这个类的Class对象是否已经被加载。如果尚未加载，默认的类加载器就会根据类的全限定名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良java代码。一旦某个类的Class对象被载入内存，我们就可以它来创建这个类的所有对象</li></ul><h2 id="获得Class对象的方式："><a href="#获得Class对象的方式：" class="headerlink" title="获得Class对象的方式："></a>获得Class对象的方式：</h2><ul><li>Class.forName(“类的全限定名”) <code>类的全限定名:类全名,包括包名</code><ul><li><code>Class.forName()方法是Class类的一个静态成员</code></li><li><code>forName在执行的过程中如果发现类XXX还没有被加载，那么JVM就会调用类加载器去加载XXX类，并返回加载后的Class对象</code>如果Class .forName找不到你要加载的类，它会抛出<code>ClassNotFoundException</code>异常</li><li>不需要为了获得Class引用而持有该类型的对象，只要通过全限定名就可以返回该类型的一个Class引用,对Class引用立即进行了初始化</li></ul></li><li>实例对象.getClass()<ul><li>如果已经有了该类型的对象，可以通过调用getClass()方法来获取Class引用，这个方法属于根类Object的一部分，它返回的是表示该对象的实际类型的Class引用</li><li>利用new操作符创建对象后，类已经装载到内存中了，所以执行getClass()方法的时候，就不会再去执行类加载的操作了，而是直接从java堆中返回该类型的Class引用</li></ul></li><li>类名.class （类字面常量）<ul><li><code>类名.class</code>这样做不仅更简单，而且更安全，因为它在编译时就会受到检查</li><li>根除了对forName()方法的调用，所以也更高效</li><li>类字面量不仅可以应用于普通的类，也可以应用于接口、数组及基本数据类型</li><li>用.class来创建对Class对象的引用时，不会自动地初始化该Class对象（这点和Class.forName方法不同）;类对象的初始化阶段被延迟到了对静态方法或者非常数静态域首次引用时才执行</li></ul></li></ul><h2 id="获取Class对象案例"><a href="#获取Class对象案例" class="headerlink" title="获取Class对象案例"></a>获取Class对象案例</h2><pre class=" language-Java"><code class="language-Java">public class Test1 &#123;    //  静态代码块    static &#123;        System.out.println("Loading Test1");    &#125;    public static void main(String[] args) &#123;        try &#123;            //  使用Class.forName("类的全名,包括包名")获取Class对象            Class c = Class.forName("Test1");            System.out.println(c);        &#125; catch (ClassNotFoundException e) &#123;            System.out.println("Couldn't find Test1");        &#125;        //  使用实例对象.getClass()获取Class对象        Test1 test1 = new Test1();        Class c = test1.getClass();        System.out.println(c);        //  使用类.class获取Class对象        System.out.println(Test1.class);    &#125;&#125;</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>基本数据类型的Class对象和包装类的Class对象是不一样的</li><li>在包装类中有个字段TYPE，TYPE字段是一个引用，指向对应的基本数据类型的Class对象</li></ul><h2 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h2><p>如果一个字段被static final修饰，我们称为<code>编译时常量</code>;那么在调用这个字段的时候是不会对当前类进行初始化的</p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><ul><li>类被加载到内存中，那么不论通过哪种方式获得该类的Class对象，它们返回的都是指向同一个java堆地址上的Class引用。jvm不会创建两个相同类型的Class对象</li><li>其实对于任意一个Class对象，都需要由它的<code>类加载器</code>和<code>这个类本身</code>一同确定其在Java虚拟机中的唯一性</li><li><code>即使两个Class对象来源于同一个Class文件，只要加载它们的类加载器不同，那这两个Class对象就必定不相等</code>这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。所以在java虚拟机中使用双亲委派模型来组织类加载器之间的关系，来保证Class对象的唯一性。</li></ul><h2 id="泛型Class引用"><a href="#泛型Class引用" class="headerlink" title="泛型Class引用"></a>泛型Class引用</h2><ul><li>Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。</li><li>在JavaSE5中，允许你对Class引用所指向的Class对象的类型进行限定，也就是说你可以对Class对象使用泛型语法。通过泛型语法，可以让编译器强制指向额外的类型检查</li></ul><h2 id="Class类的方法"><a href="#Class类的方法" class="headerlink" title="Class类的方法"></a>Class类的方法</h2><ul><li>static Class&lt;?&gt; forName()    <ul><li>获取Class对象的引用，引用的类还没有加载就加载这个类</li><li>为了产生Class引用，forName()立即就进行了初始化</li></ul></li><li>getClass()    <ul><li>获取Class对象的引用，返回表示该对象的实际类型的Class引用;该方法继承自Object</li></ul></li><li>getName()    <ul><li>取全限定的类名(包括包名)，即类的完整名字</li></ul></li><li>getClassLoader() <ul><li>返回该类的类加载器</li></ul></li><li>newInstance()    <ul><li>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器</li></ul></li><li>getFields()    <ul><li>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors</li></ul></li><li>getDeclaredFields    <ul><li>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2021/12/22/%E7%B3%BB%E7%BB%9F/Linux/%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/22/%E7%B3%BB%E7%BB%9F/Linux/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2021/12/20/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/12/20/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li><li>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</li><li>Java处理异常的方式是中断处理。</li></ul><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>异常的根类是<code>java.lang.Throwable</code><br>子类：</p><ul><li><code>java.lang.Error</code>错误：无法通过代码处理的错误，只能事先避免</li><li><code>java.lang.Exception</code>异常：异常产生后程序员可以通过代码的方式纠正，使程序继续运行</li></ul><h2 id="Throwable中的常用方法："><a href="#Throwable中的常用方法：" class="headerlink" title="Throwable中的常用方法："></a><strong>Throwable中的常用方法：</strong></h2><ul><li><code>void printStackTrace()</code>:打印异常的详细信息。<br>  包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace</li><li><code>String getMessage()</code>:获取发生异常的原因。<br>  提示给用户的时候,就提示错误原因</li><li><code>String toString()</code>:获取异常的类型和异常描述信息(不用)。</li></ul><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>Java异常处理的五个关键字：<code>try、catch、finally、throw、throws</code></p><ul><li><p>抛异常</p><ul><li>throw：<br>抛出一个异常。<br>格式： throw new 异常对象;</li><li>throws 把异常抛出给调用者去处理；如果到主方法还没有处理，那么就交给jvm去处理</li></ul></li><li><p>捕获异常<br>使用try…catch..finally格式来捕获异常<br>格式：</p><pre class=" language-Java"><code class="language-Java">try&#123;//有可能会出现异常的代码&#125;catch()&#123;//出现异常后执行的操作，出现异常的补救措施//catch块可以有多个&#125;finally&#123;//一定会执行的代码，一般用于资源释放&#125;</code></pre><p>throw和throws的区别（面试题）？<br>throw：<br>手动抛出一个异常，一定会抛出。<br>只能抛一个异常。<br>在方法体中使用。<br>throws：<br>声明一个异常，可能会抛出。<br>可以抛多个异常。<br>在方法的声明后使用。</p></li></ul><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>当java给我们提供的异常满足不了我们的需求时，我们可以自定义异常类。</p><ul><li>编译期异常：<ul><li>自定义一个类，继承Exception类即可</li><li><pre class=" language-Java"><code class="language-Java">  public class MyException extends Exception&#123;    public MyException()&#123;&#125;    public MyException(String name)&#123;        super(name);    &#125;  &#125;</code></pre></li></ul></li><li>运行期异常：<ul><li>自定义一个类，继承RunTimeException类即可</li><li><pre class=" language-Java"><code class="language-Java">  public class MyException extends RunTimeException&#123;    public MyException()&#123;&#125;    public MyException(String name)&#123;        super(name);    &#125;  &#125;</code></pre></li></ul></li></ul><p>ArrayIndexOutOfBoundsException（数组下标越界异常）<br>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</p><p>NullPointerException(空指针异常)<br>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><p>ClassCastException(类型转换异常)<br>试图将对象强制转换为不是实例的子类时，抛出该异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optional</title>
      <link href="/2021/12/19/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Optional/"/>
      <url>/2021/12/19/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Optional/</url>
      
        <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象</li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。</li><li>Optional 类的引入很好的解决空指针异常。</li><li>Java8引入</li><li>包:位于<code>java.util.Optional&lt;T&gt; </code></li></ul><h2 id="常用静态方法"><a href="#常用静态方法" class="headerlink" title="常用静态方法"></a>常用静态方法</h2><ul><li><p>创建 Optional  实例</p><ul><li><code>Optional&lt;T&gt; of(T value)</code><ul><li>返回具有Optional的当前非空值的Optional;明确对象不为null时使用</li></ul></li><li><code>Optional&lt;T&gt; ofNullable(T value)</code> <ul><li>返回一个 Optional指定值的Optional;可能是 null 也可能是非 null时使用</li></ul></li></ul></li><li><p>访问 Optional 对象的值</p><ul><li><code>isPresent()</code><ul><li>检查是否有值</li></ul></li><li><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code><ul><li> 检查是否有值，还接受一个Consumer(消费者) 参数，如果对象不是空的，就执行传入的 Lambda 表达式</li></ul></li></ul></li><li><p>返回默认值<br>Optional 类提供了 API 用以返回对象值，或者在对象为空的时候返回默认值</p><ul><li><code>T orElse(T other)</code><ul><li>如果有值则返回该值，否则返回传递给它的参数值</li></ul></li><li><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code><ul><li>如果有值则返回该值，否则调用 other并返回该调用的结果</li></ul></li><li>orElse() 和 orElseGet() 的不同之处<ul><li>对象为空而返回默认对象时，行为并无差异</li><li>两个 Optional  对象都包含非空值，两个方法都会返回对应的非空值;orElse() 方法仍然创建了 T类型 对象。与之相反，orElseGet() 方法不创建 T类型 对象</li></ul></li></ul></li></ul><h2 id="常用方法案例"><a href="#常用方法案例" class="headerlink" title="常用方法案例"></a>常用方法案例</h2><pre class=" language-Java"><code class="language-Java">//  实体类public class User &#123;    private String name;    private Integer age;    private String email;    public User() &#123;    &#125;    public User(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    @Override    public String toString() &#123;        return "User&#123;" +                "name='" + name + '\'' +                ", age=" + age +                ", email='" + email + '\'' +                '&#125;';    &#125;&#125;//  运行类public class Run &#123;    public static void main(String[] args) &#123;        User user = null;        //  对象可能是 null 也可能是非 null时使用 ofNullable()        Optional<User> opt2 = Optional.ofNullable(user);        user = new User("张三", 18);        //  明确对象不为 null  时使用 of()        Optional<User> opt1 = Optional.of(user);        User user1 = new User("张三", 18);        //  检查是否有值是 ifPresent() 方法。        //  该方法除了执行检查，还接受一个Consumer(消费者) 参数，如果对象不是空的，就执行传入的 Lambda 表达式：        opt1.ifPresent( u ->  assertEquals(user1.getEmail(), u.getEmail()) );        //  取回实际值对象使用 get() 方法        System.out.println(opt1.get());    &#125;    public static void assertEquals(String email1,String email2)&#123;        System.out.println(email1);        System.out.println(email2);    &#125;&#125;</code></pre><h2 id="Optional-使用"><a href="#Optional-使用" class="headerlink" title="Optional  使用"></a>Optional  使用</h2><ul><li>Optional 不是 Serializable。因此，它不应该用作类的字段。</li><li>在将其类型用作方法或构建方法的参数时;这样做会让代码变得复杂，完全没有必要</li><li>Optional 主要用作返回类型;在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。</li><li>Optional 类有一个非常有用的用例，就是将其与流或其它返回 Optional 的方法结合，以构建流畅的API。</li></ul><h2 id="Optional-使用示例"><a href="#Optional-使用示例" class="headerlink" title="Optional  使用示例"></a>Optional  使用示例</h2><p>使用 Stream 返回 Optional 对象的 findFirst() 方法：</p><pre class=" language-Java"><code class="language-Java">@Testpublic void whenEmptyStream_thenReturnDefaultOptional() &#123;    List<User> users = new ArrayList<>();    User user = users.stream().findFirst().orElse(new User("default", "1234"));    assertEquals(user.getEmail(), "default");&#125;</code></pre><p>总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map集合</title>
      <link href="/2021/12/17/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20Map%E9%9B%86%E5%90%88/"/>
      <url>/2021/12/17/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20Map%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><ul><li>Map集合是java中提供的一种容器，可以用来存储键值对数据</li><li>包: <code>java.util.Map</code></li><li>类型: 接口</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>元素由键和值构成。左边叫键，右边叫值</li><li>键无序，不可重复。值可以是任意类型,任意值</li><li>set集合的底层使用的就是map集合的键</li></ul><h2 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h2><ul><li>HashMap：底层是哈希表，键无序，不可重复。</li><li>LinedHashMap：底层是哈希表+链表，键有序，不可重复。</li><li>TreeMap：底层是红黑树，查询效率高</li><li>Hashtable</li></ul><h2 id="HashMap和Hashtable的区别-面试题-？"><a href="#HashMap和Hashtable的区别-面试题-？" class="headerlink" title="HashMap和Hashtable的区别(面试题)？"></a>HashMap和Hashtable的区别(面试题)？</h2><ul><li>HashMap：1.2版本出现。线程不安全，效率高。允许null作为键和值。</li><li>Hashtable：1.0版本出现。线程安全，效率低。（最早的双列集合）不允许null作为键和值</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><code>V put(K key, V value)</code><ul><li>添加元素，如果键存在，那么新值会替换掉旧值。返回旧值。</li></ul></li><li><code>V remove(Object key)</code><ul><li>根据键删除键值对，返回被删除的值。如果键不存在，返回null。</li></ul></li><li><code>V get(Object key)</code><ul><li>根据键获取值，如果键不存在，返回null。</li></ul></li><li><code>boolean containsKey(Object key)</code><ul><li>判断集合中是否包含该键，如果不包含，返回false。</li></ul></li><li><code>Set&lt;K&gt; keySet()</code><ul><li>获取map集合中的所有的键，存储到一个set集合中</li></ul></li><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code><ul><li>获取map集合中所有的键值对对象，存储到一个set集合中键值对对象</li></ul></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">import java.util.HashMap;import java.util.Map;public class Run &#123;    public static void main(String[] args) &#123;        //  创建(键值对集合)        Map<String,Integer> stringIntegerMap = new HashMap<>();        map.put("杨过","小龙女");        map.put("郭靖","黄蓉");        map.put("小明","小红");        //  添加元素        stringIntegerMap.put("1",22);        stringIntegerMap.put("2",18);        stringIntegerMap.put("3",32);        stringIntegerMap.put("4",42);        stringIntegerMap.put("5",12);        stringIntegerMap.put(null,null);        //  通过键获取值        Integer integer = stringIntegerMap.get(null);        System.out.println(integer);        //  判断集合中是否包含该键        boolean b = stringIntegerMap.containsKey(null);        System.out.println(b);        //  keySet()返回Set集合,其中是所有的key        Set<String> strings = stringIntegerMap.keySet();        for (String string : strings) &#123;            System.out.println(string);            stringHashMap.get(string);        &#125;        //  entrySet()返回键值对集合        Set<Map.Entry<String, Integer>> set = map.entrySet();        //  遍历键值对对象集合        for (Map.Entry<String, Integer> entry : set) &#123;            //获取键            String key = entry.getKey();            //获取值            String value = entry.getValue();            System.out.println(key + "-" + value);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collections</title>
      <link href="/2021/12/16/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Collections/"/>
      <url>/2021/12/16/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Collections/</url>
      
        <content type="html"><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>操作单列集合（Collection）的工具类</li></ul><h2 id="Collection和Collections的区别-面试题-？"><a href="#Collection和Collections的区别-面试题-？" class="headerlink" title="Collection和Collections的区别(面试题)？"></a>Collection和Collections的区别(面试题)？</h2><ul><li>Collection是单列集合的根接口。</li><li>Collections是工具类。</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>static <T> boolean <code>addAll(Collection&lt;T&gt; c, T... elements) </code><ul><li>批量添加元素</li></ul></T></li><li>static void <code>shuffle(List&lt;?&gt; list)</code><ul><li>打乱集合中的元素顺序。</li></ul></li><li>static <T> void <code>sort(List&lt;T&gt; list)</code><ul><li>给集合中的元素排序。</li></ul></T></li><li>static <T> void <code>sort(List&lt;T&gt; list，Comparator&lt;? super T&gt;)</code><ul><li>给集合中的元素排序。</li></ul></T></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.Collections;/*  addAll(Collection<T> c, T... elements)    批量添加元素  shuffle(List<?> list)    打乱集合中的元素顺序。 */public class Test3 &#123;    public static void main(String[] args) &#123;        //创建集合        ArrayList<String> list = new ArrayList<>();//        list.add("张飞");//        list.add("王菲");//        list.add("刘亦菲");//        list.add("胡一菲");        Collections.addAll(list,"张飞","王菲","胡一菲","贵妃");        Collections.shuffle(list);        System.out.println(list);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>数据结构是计算机存储、组织数据的方式。</li><li>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</li><li>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。</li><li>数据结构往往同高效的检索算法和索引技术有关</li><li>数据与数据之间的关系</li></ul><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><ul><li>栈、队列、数组、链表和红黑树</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>  <strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>  先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）<br>  栈的入口、出口的都是栈的顶端位置</p><h3 id><a href="#" class="headerlink" title></a></h3><ul><li>压栈(入栈)：就是存元素。</li><li>弹栈(出栈)：就是取元素。<br><img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png"></li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>queue</strong>,队列，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）</li><li>队列的入口、出口各占一侧<br><img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png"></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><strong>数组(Array)</strong>:是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>查找元素快：<ul><li>通过索引，可以快速访问指定位置的元素</li></ul></li><li>增删元素慢:<ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置</li><li><strong>指定索引位置删除元素</strong>：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中<br><img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.png"></li></ul></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><strong>链表</strong>:由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>多个结点之间，通过地址进行连接</li><li>查找元素慢：<ul><li>想查找某个元素，需要通过连接的节点，依次向后查找指定元素</li></ul></li><li>增删元素快：<ul><li>增加元素：只需要修改连接下个元素的地址即可</li><li>删除元素：只需要修改连接下个元素的地址即可<br><img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8.png"></li></ul></li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><strong>二叉树</strong>：</p><ul><li>二叉树是每个节点最多有两个子树的树结构。</li><li>顶上的叫根节点，两边被称作“左子树”和“右子树”。</li><li>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。</li><li>意味着，树的键值仍然是有序的。</li></ul><h3 id="红黑树的约束"><a href="#红黑树的约束" class="headerlink" title="红黑树的约束:"></a>红黑树的约束:</h3><ol><li>节点可以是红色的或者黑色的</li><li>根节点是黑色的</li><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><h3 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点:"></a>红黑树的特点:</h3><ul><li>速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p> <img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h3 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h3><p> <img src="/2021/12/16/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2021/12/14/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20jdbc/"/>
      <url>/2021/12/14/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>JDBC 规范定义接口，具体的实现由数据库厂商实现。</li><li>JDBC 是 Java 访问数据库的标准规范，真正操作数据库还需要具体的实现类，也就是数据库驱动。</li><li>每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动。所以只需要调用 JDBC 接口中的方法即可，数据库驱动由数据库厂商提供。</li></ul><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>导入驱动jar包<ul><li>项目下新建lib(插件)文件夹</li><li>将mysql驱动jar包解压至lib文件夹</li></ul></li><li>注册驱动<ul><li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><ul><li>Class.forName():<br><code>使用Class.forName()会将调用的类初始化，即调用class中的static块，并返回该类的Class对象</code></li><li>Class.forName(“com.mysql.jdbc.Driver”)调用的是此操作<br><code>DriverManager.registerDriver(new Driver());//  注册数据库驱动</code> </li></ul></li></ul></li><li>获取连接对象<ul><li>使用用户名、密码、URL 得到连接对象<br><code>Connection connection = DriverManager.getConnection(url,用户名,密码);</code></li></ul></li><li>获取执行sql对象<br> <code>Statement stat = conn.createStatement();</code></li><li>执行sql<ul><li>增,删,改  调用executeUpdate() 执行成功返回值为影响的行数,执行失败返回0<br><code>int i = stat.executeUpdate(&quot;delete from student where name = &#39;陈七&#39;&quot;);</code></li><li>查询      调用executeQuery()  执行成功返回查询结果集对象  ResultSet类型<br><code>ResultSet rs = stat.executeQuery( &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot; + password +&quot;&#39;&quot;);</code></li></ul></li><li>处理结果<ul><li><pre class=" language-Java"><code class="language-Java">//next()    结果集中存在下一个结果,返回true;否则返回falsewhile(rs.next())&#123;   //  获取数据  int id = rs.getInt("id");  String name = rs.getString("name");  double score = rs.getDouble("score");  String sex = rs.getString("sex");&#125;</code></pre></li></ul></li><li>释放资源<ul><li><pre class=" language-Java"><code class="language-Java">//  关闭结果集对象rs.close();//  关闭执行sql对象stat.close();//  关闭Connection连接对象conn.close();</code></pre></li></ul></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class=" language-Java"><code class="language-Java">public class Run &#123;    public static void main(String[] args) throws SQLException, ClassNotFoundException &#123;        //  注册        Class.forName("com.mysql.jdbc.Driver");Class.forName("com.mysql.jdbc.Driver");         //  获取连接对象        Connection connection = DriverManager.getConnection("jdbc:mysql://192.168.124.6/db1?characterEncoding=utf-8", "zrh", "imachinese;910");         //  获取sql语句执行对象        Statement statement = connection.createStatement();         //  获取查询结果集对象        ResultSet resultSet = statement.executeQuery("select * from student where name = '张三'");         //  迭代打印查询到的信息        while (resultSet.next()) &#123;            System.out.println(resultSet.getString("name"));        &#125;         //  关闭连接        resultSet.close();        statement.close();        connection.close();    &#125;&#125;</code></pre><h2 id="PreparedStatement-更换执行sql对象"><a href="#PreparedStatement-更换执行sql对象" class="headerlink" title="(PreparedStatement)更换执行sql对象"></a>(PreparedStatement)更换执行sql对象</h2><h3 id="Statement的劣势"><a href="#Statement的劣势" class="headerlink" title="Statement的劣势"></a>Statement的劣势</h3><ul><li>存在sql注入问题</li><li>性能方面损耗严重<ul><li>每次执行sql语句，相关数据库都要执行sql语句的编译</li></ul></li></ul><h3 id="PreparedStatement与Statement的区别"><a href="#PreparedStatement与Statement的区别" class="headerlink" title="PreparedStatement与Statement的区别"></a>PreparedStatement与Statement的区别</h3><ul><li>PreparedStatement是预编译的,对于批量处理可以大大提高效率</li><li>支持占位符<code>?</code>可有效防止SQL注入</li></ul><h3 id="预编译语句的优势"><a href="#预编译语句的优势" class="headerlink" title="预编译语句的优势"></a>预编译语句的优势</h3><ul><li>一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入</li></ul><h3 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h3><pre class=" language-Java"><code class="language-Java">  //  使用连接对象创建sql预编译语句对象  PreparedStatement prepareStatement = connection.prepareStatement("insert into student values (null,?,?,?)");  //  填充占位符  占位符从1开始,类型为要填充的数据类型  prepareStatement.setString(1, "赵六");  prepareStatement.setInt(2, 18);  prepareStatement.setDouble(3, 95);  // 执行sql  int i = prepareStatement.executeUpdate();</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="JDBC中的事务"><a href="#JDBC中的事务" class="headerlink" title="JDBC中的事务"></a>JDBC中的事务</h3><p>由Connection连接对象调用</p><ul><li><code>void setAutoCommit(boolean autoCommit)</code>参数true或false;如果设置为 false，表示关闭自动提交，相当于开启事务</li><li><code>void commit()</code>    提交事务</li><li><code>void rollback()</code>    回滚事务</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre class=" language-Java"><code class="language-Java">import java.sql.*;public class JdbcUtil &#123;    private static final String driver = "com.mysql.jdbc.Driver";    private static final String url = "jdbc:mysql://127.0.0.1/db1?characterEncoding=utf-8";    private static final String username = "root";    private static final String password = "root";    static &#123;        try &#123;            Class.forName(driver);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();            System.out.println("MySQL驱动注册失败!!!");        &#125;    &#125;    public static Connection getConnection() &#123;        try &#123;            return DriverManager.getConnection(url, username, password);        &#125; catch (SQLException throwables) &#123;            throwables.printStackTrace();            System.out.println("MySQL连接建立失败!!!");        &#125;        return null;    &#125;    public static void close(Statement statement, Connection connection) &#123;        close(null,statement,connection);    &#125;    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;        if (resultSet != null) &#123;            try &#123;                resultSet.close();            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125;        if( statement != null || connection != null)&#123;            try &#123;                statement.close();                connection.close();            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125;    &#125;&#125;import version3.utils.JdbcUtil;import java.sql.*;public class Run &#123;    //  获取连接对象    static Connection connection = JdbcUtil.getConnection();    //  创建学生初始化对象    static Student student = null;    //  创建执行sql预编译对象    static PreparedStatement prepareStatement = null;    //  创建查询结果集对象    static ResultSet resultSet = null;    public static void main(String[] args) &#123;//        insert();//        update();//        select();//        selectAll();//        delete();    &#125;    //增    public static void insert() &#123;        try &#123;            prepareStatement = connection.prepareStatement("insert into student values (null,?,?,?)");            prepareStatement.setString(1, "赵六");            prepareStatement.setInt(2, 18);            prepareStatement.setDouble(3, 95);            int i = prepareStatement.executeUpdate();            if (i == 0) &#123;                System.out.println("操作失败");                System.exit(1);            &#125;            System.out.println("操作成功");            System.out.println("影响的代码行数为:" + i);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    //删    public static void delete() &#123;        try &#123;            prepareStatement = connection.prepareStatement("delete from student where age=?");            prepareStatement.setInt(1, 18);            int i = prepareStatement.executeUpdate();            if (i == 0) &#123;                System.out.println("操作失败");                System.exit(1);            &#125;            System.out.println("操作成功");            System.out.println("影响的代码行数为:" + i);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    //改    public static void update() &#123;        try &#123;            prepareStatement = connection.prepareStatement("update  student set name=?,score=?  where age=18");            prepareStatement.setString(1, "赵六update");            prepareStatement.setDouble(2, 95);            int i = prepareStatement.executeUpdate();            if (i == 0) &#123;                System.out.println("操作失败");                System.exit(1);            &#125;            System.out.println("操作成功");            System.out.println("影响的代码行数为:" + i);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void select() &#123;        try &#123;            prepareStatement = connection.prepareStatement("select * from student where age=18");            resultSet = prepareStatement.executeQuery();            //  resultSet.next()  存在下一条数据时返回true,否则返回false            while (resultSet.next()) &#123;                student = new Student(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getInt("age"), resultSet.getDouble("score"));            &#125;            System.out.println(student);            System.out.println("操作成功");        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream</title>
      <link href="/2021/12/10/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Stream/"/>
      <url>/2021/12/10/Java/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB/java.util.Stream/</url>
      
        <content type="html"><![CDATA[<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</li><li>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</li></ul><h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><ul><li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Stream是Java 8提供的新功能，是对集合（Collection）对象功能的增强，能对集合对象进行各种非常便利、高效的聚合操作- （aggregate operation），或者大批量数据操作 (bulk data operation)。</li><li>Stream流其实是一个集合元素的函数模型，不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值），Stream是一个来自数据源的元素队列。它是有关算法和计算的，它更像一个高级版本的 Iterator。</li><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li>同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</li><li>包:<code>java.util.stream</code>接口</li><li>版本: <code>1.8</code>开始支持</li><li>同类型接口:<code>IntStream</code>,<code>LongStream</code>,<code>DoubleStream</code></li></ul><h2 id="Stream的优势"><a href="#Stream的优势" class="headerlink" title="Stream的优势"></a>Stream的优势</h2><ul><li>与Lambda 表达式结合，也可以提高编程效率、简洁性和程序可读性。</li><li>通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</li><li>高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</li></ul><h3 id="Stream的优势案例"><a href="#Stream的优势案例" class="headerlink" title="Stream的优势案例"></a>Stream的优势案例</h3><p>遍历姓“花”的到集合A，再找出名字是3个字的到集合B，最后遍历输出B中的元素。</p><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;public class Demo1 &#123;    public static void main(String[] args) &#123;        // 传统的做法：        List<String> list = new ArrayList<>();        list.add("花和尚");        list.add("花豹子");        list.add("花花公子");        List<String> listA = new ArrayList<>();        for (String s : list) &#123;            if (s.startsWith("花")) &#123;                listA.add(s);            &#125;        &#125;        List<String> listB = new ArrayList<>();        for (String s : listA) &#123;            if (s.length() == 3) &#123;                listB.add(s);            &#125;        &#125;        for (String s : listB) &#123;            System.out.println(s);        &#125;        // 使用stream的方式:        List<String> listC = new ArrayList<>();        list.stream().filter(item -> item.startsWith("花")).filter(item -> item.length() == 3).forEach(item -> listC.add(item));//forEach(item -> listC.add(item)另一写法为forEach (listC::add)        System.out.println(listC);    &#125;&#125;</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</li></ul><h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li>stream() − 为集合创建串行流。</li><li>parallelStream() − 为集合创建并行流。</li></ul><h2 id="Stream流的构造-及-转换"><a href="#Stream流的构造-及-转换" class="headerlink" title="Stream流的构造 及 转换"></a>Stream流的构造 及 转换</h2><pre class=" language-Java"><code class="language-Java">public class Demo&#123;  public static void main(String [] args)&#123;    //转为Stream对象      //  数组转Stream对象    String[] stringArray = new String[]&#123;"a", "b", "c"&#125;;    //    使用Stream的of()    Stream stream1 = Stream.of(stringArray);//Stream 的of()调用的还是Arrays.stream()    //    使用数组工具类Arrays的stream()    Stream stream2 = Arrays.stream(stringArray);    //  集合转Stream对象    List<String> list = Arrays.asList(stringArray);    //    使用List接口的stream()    Stream stream3 = list.stream();    //Stream转为Array    String[] strArray = (String[]) stream1.toArray(String[]::new);    //Stream转为Collection    List<String> list1 = (List<String>) stream3.collect(Collectors.toList());  &#125;&#125;</code></pre><h2 id="Stream操作的特征"><a href="#Stream操作的特征" class="headerlink" title="Stream操作的特征"></a>Stream操作的特征</h2><ul><li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h2 id="Stream的常用操作"><a href="#Stream的常用操作" class="headerlink" title="Stream的常用操作"></a>Stream的常用操作</h2><ul><li><p>Intermediate：(中间操作)</p><ul><li>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。</li><li><font color="red">这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历</font><ul><li>包含的操作：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered </li></ul></li></ul></li><li><p>Terminal：(终点操作)</p><ul><li>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。  </li><li><font color="red">Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect</font><ul><li>包含的操作有：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li></ul></li></ul></li></ul><h2 id="Stream操作案例"><a href="#Stream操作案例" class="headerlink" title="Stream操作案例"></a>Stream操作案例</h2><pre class=" language-Java"><code class="language-Java">public class Demo&#123;  public static void main(String [] args)&#123;    //  forEach 来迭代流中的每个数据    Random random = new Random();    random.ints().limit(10).forEach(System.out::println);    //  map 方法用于映射每个元素到对应的结果    List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);    List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());// 获取对应的平方数    //  filter 方法用于通过设置的条件过滤出元素    List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");    long count = strings.stream().filter(string -> string.isEmpty()).count();// 获取空字符串的数量    //  limit 方法用于获取指定数量的流    Random random = new Random();    random.ints().limit(10).forEach(System.out::println);    //  parallelStream 是流并行处理程序的代替方法    List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");    long count = strings.parallelStream().filter(string -> string.isEmpty()).count();//// 获取空字符串的数量  &#125;&#125;</code></pre><h2 id="for、foreach、stream-哪家的效率更高？"><a href="#for、foreach、stream-哪家的效率更高？" class="headerlink" title="for、foreach、stream 哪家的效率更高？"></a>for、foreach、stream 哪家的效率更高？</h2><p>1万以内的数据，for循环的性能要高于foreach和stream；<br>数据量上去之后（1000万），三种遍历方式基本已经没有什么差距了，但是Stream提供并行处理，在数据量大了之后，效率会明显增强。（但是单核CPU，Stream并行处理可能会效率更慢）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%B3%A8%E8%A7%A3(Annotation)/"/>
      <url>/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%B3%A8%E8%A7%A3(Annotation)/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 注解(Annotation)又称<code>Java 标注</code>，是<code>JDK5.0 引入</code>的一种注释机制(一种特殊的接口)<br>注解本质上就是一个接口，该接口默认继承<code>Annotation</code>接口<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。Java 标注可以通过反射获取标注内容<br>注解: 对程序进行说明解释; 给计算机看的<br>注释：对程序进行说明解释; 给程序员看的</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="作用在代码的注解"><a href="#作用在代码的注解" class="headerlink" title="作用在代码的注解"></a>作用在代码的注解</h3><p>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。<br>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。<br>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</p><h3 id="元注解-作用在其他注解的注解-是"><a href="#元注解-作用在其他注解的注解-是" class="headerlink" title="元注解(作用在其他注解的注解)是:"></a>元注解(作用在其他注解的注解)是:</h3><p>元注解：描述注解的注解<br>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。<br>@Documented - 标记这些注解是否包含在用户文档中。<br>@Target - 标记这个注解应该是哪种 Java 成员。<br>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p><h3 id="新增注解"><a href="#新增注解" class="headerlink" title="新增注解"></a>新增注解</h3><p>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。<br>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。<br>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p><h2 id="Annotation-架构"><a href="#Annotation-架构" class="headerlink" title="Annotation 架构"></a>Annotation 架构</h2><p><img src="/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E6%B3%A8%E8%A7%A3(Annotation)/Annotation%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="Annotation-组成部分"><a href="#Annotation-组成部分" class="headerlink" title="Annotation 组成部分"></a>Annotation 组成部分</h2><p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p><p><strong>Annotation.java</strong><br>Annotation 是个接口</p><pre class=" language-Java"><code class="language-Java">public interface Annotation &#123;    boolean equals(Object obj);    int hashCode();    String toString();    Class<? extends Annotation> annotationType();&#125;每个 Annotation 对象，都会有唯一的 RetentionPolicy 属性和 1~n 个ElementType 属性</code></pre><p><strong>ElementType.java</strong><br>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</p><pre class=" language-Java"><code class="language-Java">package java.lang.annotation;public enum ElementType &#123;  TYPE,               /* 类、接口（包括注释类型）或枚举声明  */  FIELD,              /* 字段声明（包括枚举常量）  */  METHOD,             /* 方法声明  */  PARAMETER,          /* 参数声明  */  CONSTRUCTOR,        /* 构造方法声明  */  LOCAL_VARIABLE,     /* 局部变量声明  */  ANNOTATION_TYPE,    /* 注释类型声明  */  PACKAGE             /* 包声明  */&#125;</code></pre><p><strong>RetentionPolicy.java</strong><br>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略;<br>就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</p><pre class=" language-Java"><code class="language-Java">package java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RU    NTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;SOURCE ：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了CLASS ：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为RUNTIME ：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入</code></pre><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>Annotation 通用定义</p><pre class=" language-Java"><code class="language-Java">@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;</code></pre><p>说明：<br>定义一个 Annotation,名字是 MyAnnotation1,在代码中通过 “@MyAnnotation1” 来使用它<br>其余注解用来修饰MyAnnotation1</p><ol><li>@interface<br> 意味着MyAnnotation1实现了 java.lang.annotation.Annotation 接口，即表示这是一个Annotation<code>(这是一个注解)</code><br><code>定义 Annotation 时，@interface 是必须的</code><br>注意：<code>它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口</code></li><li>@Documented<br>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的<br>如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。<br>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中</li><li>@Target(ElementType.TYPE)<br>ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性<br>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE<br>这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解<br>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方</li><li>@Retention(RetentionPolicy.RUNTIME)<br>RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性<code>(运行环境)</code><br>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME<br>这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取<br>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</li></ol><h2 id="常用注解-常用的-Annotation"><a href="#常用注解-常用的-Annotation" class="headerlink" title="常用注解(常用的 Annotation)"></a>常用注解(常用的 Annotation)</h2><p>@Deprecated  – @Deprecated 所标注内容，不再被建议使用。<br>@Override    – @Override 只能标注方法，表示该方法覆盖父类中的方法。<br>@Documented  – @Documented 所标注内容，可以出现在javadoc中。<br>@Inherited   – @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。<br>@Retention   – @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。<br>@Target      – @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。<br>@SuppressWarnings – @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。<br>由于 “@Deprecated 和 @Override” 类似，”@Documented, @Inherited, @Retention, @Target” 类似；下面，我们只对 @Deprecated, @Inherited, @SuppressWarnings 这 3 个 Annotation 进行说明。</p><h2 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h2><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。<br>用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能</p><ol><li><p>编译检查<br>Annotation 具有”让编译器进行编译检查的作用”。<br>例如，@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p></li><li><p>在反射中使用 Annotation<br>在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。</p></li><li><p>根据 Annotation 生成帮助文档<br>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p></li><li><p>能够帮忙查看查看代码<br>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p></li><li><p>可以通过自定义 Annotation 来实现一些功能(自定义注解)</p></li></ol><h2 id="注解中的属性"><a href="#注解中的属性" class="headerlink" title="注解中的属性"></a>注解中的属性</h2><p>属性：接口中的抽象方法<br>*要求：<br>1.属性的返回值类型有下列取值：</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul><p>2.定义了属性，在使用时必须要给属性赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使        用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value        可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省        略</li></ol><h3 id="属性案例"><a href="#属性案例" class="headerlink" title="属性案例"></a>属性案例</h3><p>定义注解</p><pre class=" language-Java"><code class="language-Java">import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD,ElementType.TYPE,ElementType.FIELD&#125;)public @interface AA&#123;    String[] name() default "张三";&#125;</code></pre><p>使用注解</p><pre class=" language-Java"><code class="language-Java">@AA(name= "呵呵")public class Test1 &#123;    @AA(name= "呵呵")    String name;    @AA(name= "呵呵")    public static void main(String[] args) &#123;        System.out.println("aa");    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20Collection%E9%9B%86%E5%90%88/"/>
      <url>/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20Collection%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><ul><li>Collection集合是java中提供的一种容器，可以用来存储数据</li><li>包: <code>java.util.Collection</code></li><li>类型: 接口</li></ul><h2 id="集合和数组的区别-面试题-？"><a href="#集合和数组的区别-面试题-？" class="headerlink" title="集合和数组的区别(面试题)？"></a>集合和数组的区别(面试题)？</h2><ul><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中只能存储同一种数据类型，集合中可以存储不同的数据类型</li><li>数组中可以存储基本数据类型也可以存储引用数据类型;集合中只能存储引用数据类型（集合存储基本数据类型其实存储的是对应的包装类）</li></ul><h2 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h2><ul><li><code>java.util.List</code></li><li><code>java.util.Set</code>;</li></ul><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>位于<code>java.util.List</code>包</li><li>特点:有序，有索引，可重复</li><li>类型:接口</li></ul><h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><ul><li><code>java.util.ArrayList</code><ul><li>结构:数组结构</li><li>特点:元素增删慢，查询快</li></ul></li><li><code>java.util.LinkedList</code><ul><li>结构:链表结构</li><li>特点:元素查询慢,增删快</li></ul></li><li><code>Vector</code></li></ul><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>位于<code>java.util.Set</code>包</li><li>特点:没有索引，不可重复</li><li>类型:接口</li></ul><h4 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h4><ul><li><code>java.util.HashSet</code><ul><li>结构:哈希表</li><li>特点:元素无序，不可重复</li><li>子类<ul><li><code>java.util.LinkedHashSet</code>    <ul><li>结构:哈希表+链表</li><li>特点:元素有序，不可重复</li></ul></li></ul></li></ul></li><li><code>java.util.TreeSet</code><ul><li>结构:红黑树</li><li>特点:查询速度非常快</li><li>案例<pre class=" language-Java"><code class="language-Java">//TreeSet底层是红黑树，内部实现了自然排序，如果使用TreeSet存储自定义数据类型，那么可以在构造方法中给一个比较器对象即可。//  使用TreeSet存储自定义数据类型，可以在构造方法中给一个比较器对象并重写compare();给一个排序依据。import java.util.Comparator;import java.util.TreeSet;public class Demo1 &#123;    public static void main(String[] args) &#123;        //  TreeSet底层是红黑树，内部实现了自然排序，        //  使用TreeSet存储自定义数据类型，可以在构造方法中给一个比较器对象并重写compare();给一个排序依据。        TreeSet<Student> studentTreeSet = new TreeSet<>(new Comparator<Student>() &#123;            @Override            public int compare(Student o1, Student o2) &#123;                return (int) (o1.getScore() - o2.getScore());            &#125;        &#125;);        studentTreeSet.add(new Student("张三", 18, 44.5));        studentTreeSet.add(new Student("李四", 16, 100.0));        studentTreeSet.add(new Student("王五", 20, 91.0));        for (Student student : studentTreeSet) &#123;            System.out.println(student);        &#125;    &#125;&#125;</code></pre></li></ul></li></ul><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><ul><li>在jdk8之前，底层是数组+链表。</li><li>在jdk8之后，底层是数组+链表/红黑树（当同一个哈希值对应的元素多于7个，会自动的把链表变成红黑树）</li></ul><h6 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h6><ul><li>两个没有任何联系的字符串的哈希值竟然一样，这个现象叫哈希冲突。</li></ul><h6 id="set集合的去重原理："><a href="#set集合的去重原理：" class="headerlink" title="set集合的去重原理："></a>set集合的去重原理：</h6><ol><li>先使用哈希值进行对比，如果没有一样的，直接存储  hasCode()</li><li>如果有哈希值一样的，那么会用equals方法来比较内容，如果内容不同，存        储，如果内容相同，说明存在，不存储<br><img src="/2021/12/09/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20Collection%E9%9B%86%E5%90%88/%E5%93%88%E5%B8%8C%E8%A1%A8.png"></li></ol><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ul><li>用set集合来存储元素，如果存储自定义的数据类型，那么类中必须重写equals和hasCode方法，来保证set集合去重。<h6 id="HashSet集合与Map的关系"><a href="#HashSet集合与Map的关系" class="headerlink" title="HashSet集合与Map的关系"></a>HashSet集合与Map的关系</h6></li><li>HashSet类中有一个全局变量HashMap map,然后在HashSet的构造函数中有一句话map=new HashMap(),说明在创建HashSet类对象的时候底层创建了一个HashMap对象<h3 id="Collection-常用方法"><a href="#Collection-常用方法" class="headerlink" title="Collection 常用方法"></a>Collection 常用方法</h3>Collection是父接口，因此在Collection中定义了(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合</li></ul><ul><li><code>boolean add(E e)</code>：      添加元素</li><li><code>void clear()</code> :          清空元素</li><li><code>boolean remove(E e)</code>:    删除元素</li><li><code>boolean contains(E e)</code>:  判断集合中是否包含该元素</li><li><code>boolean isEmpty()</code>:      判断集合是否为空</li><li><code>int size()</code>:             返回集合中元素的个数</li><li><code>Object[] toArray()</code>:     集合转为数组</li><li><code>Iterator&lt;E&gt; iterator()</code>: 创建迭代器对象</li></ul><h3 id="Collection-常用方法案例"><a href="#Collection-常用方法案例" class="headerlink" title="Collection 常用方法案例"></a>Collection 常用方法案例</h3><pre class=" language-Java"><code class="language-Java">public class Student &#123;    private String name;    private Integer age;    private Double score;    public Student() &#123;&#125;    public Student(String name, Integer age, Double score) &#123;        this.name = name;        this.age = age;        this.score = score;    &#125;    @Override    public String toString() &#123;        return "Student&#123;"+"name='" + name + '\'' +", age=" + age +", score=" + score +'&#125;';    &#125;&#125;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        //创建一个集合        Collection coll = new ArrayList();        Student student = new Student("张三", 19, 85.6);        //  add  添加        coll.add(student);        coll.add(18);        coll.add('@');        coll.add(true);        coll.add(185.45);        System.out.println(coll);        //  remove  删除        //  coll.remove(student);        System.out.println(coll);        //  contains    判断集合中是否存在该元素        //  System.out.println(coll.contains(student));        //  clear   清空        coll.clear();        //  System.out.println(coll);        //  isEmpty  判断集合是否为空        System.out.println(coll.isEmpty());                //  toArray 集合转数组        Object[] objects = coll.toArray();        //创建迭代器对象        Iterator iterator = coll.iterator();    &#125;&#125;</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述:"></a>概述:</h3><ul><li>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器</li><li>包: <code>java.util.Iterator</code></li><li>类型: 接口</li></ul><h3 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h3><p>Collection集合中有一个方法<code>Iterator&lt;E&gt; iterator()</code><br>作用是获取集合对应的迭代器对象，用来遍历集合中的元素</p><pre class=" language-Java"><code class="language-Java">//创建迭代器对象Iterator iterator = 集合对象.iterator();  </code></pre><h3 id="迭代器常用方法"><a href="#迭代器常用方法" class="headerlink" title="迭代器常用方法"></a>迭代器常用方法</h3><ul><li><code>boolean hasNext()</code>:  判断集合的下一个位置是否有元素</li><li><code>E next()</code>:           <font color="red"><strong>获取当前指向的元素,并指向下一个元素</strong></font>此方法使用时需注意!!!             </li><li><code>void remove()</code>:      删除所指向的元素</li></ul><h3 id="常用方法案例"><a href="#常用方法案例" class="headerlink" title="常用方法案例:"></a>常用方法案例:</h3><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionDemo &#123;  public static void main(String[] args) &#123;    //创建集合    ArrayList<String> stringArrayList = new ArrayList<>();    stringArrayList.add("1");stringArrayList.add("2");    //创建迭代器对象    Iterator<String> iterator = stringArrayList.iterator();    // 使用迭代器遍历集合    while (iterator.hasNext()) &#123;//判断集合的下一个位置是否有元素    //获取当前指向的元素,并指向下一位元素;   注意:这里如果没有执行next();将陷入死循环中!!!!!!!!!!!!!!        String s = iterator.next();        if (s.equals("1")) &#123;            iterator.remove();//删除当前指向的元素        &#125;    &#125;  &#125;&#125;</code></pre><h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><ul><li>增强for是jdk1.5的新特性。</li><li>作用是：可以遍历数组和集合。</li><li>内部原理是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作</li></ul><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><ul><li><font color="red">用于遍历元素使用，不能使用增强for删除元素</font></li></ul><h3 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h3><pre class=" language-Java"><code class="language-Java">for(元素类型 元素名: 集合名 )&#123;  System.out.println(元素名)&#125;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><pre class=" language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.Iterator;public class Demo &#123;    public static void main(String[] args) &#123;        ArrayList<String> list  = new ArrayList<>();        list.add("张三");        list.add("李四");        //打印集合元素        for (String s : list) &#123;            System.out.println(s);        &#125;    &#125;&#125;</code></pre><h2 id="可变参数："><a href="#可变参数：" class="headerlink" title="可变参数："></a>可变参数：</h2><ul><li>在jdk1.5后，有可变参数的新特性。</li></ul><h3 id="格式：-1"><a href="#格式：-1" class="headerlink" title="格式："></a>格式：</h3><p>修饰符 返回值类型 方法名(参数类型… 形参名){  }</p><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><ol><li>可变参数的本质是一个数组。</li><li>如果一个方法有多个参数，但只能有一个可变参数，可变参数必须是最后一个参数。</li><li>如果一个方法的参数中有可变参数，那么可以不传递可变参数。</li></ol><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre class=" language-Java"><code class="language-Java">/*  可变参数  修饰符 返回值类型 方法名 (int... a)&#123;&#125;  当我们方法传递参数的时候，我们不知道传递几个，可使用可变参数 */public class Test1 &#123;  public static void main(String[] args) &#123;      getSum(3,5,11,8);  &#125;  //求和  public static void getSum(int... arr)&#123;      System.out.println(arr.length);      System.out.println(arr[0]);      System.out.println(arr[1]);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2021/12/07/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/12/07/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ol><li><p>概述:</p><ul><li>定义于另一个类的内部</li></ul></li><li><p>定义格式:</p><pre class=" language-Java"><code class="language-Java">public class 外部类名称&#123;    class 成员内部类名称&#123; &#125;   &#125;</code></pre></li><li><p>访问方式</p><ul><li>内部类访问外部类<ul><li>成员内部类可以无条件访问外部类的所有成员(属性,行为):包括private成员和静态成员</li></ul></li><li>外部类访问内部类<ul><li>创建内部类的对象,通过这个对象的引用访问</li><li>创建内部类对象的方式,例:<pre class=" language-Java"><code class="language-Java">外部类名.内部类名 对象名 = new 外部类型().new 内部类型();</code></pre></li></ul></li></ul></li><li><p>注意:</p><ol><li>内部类是一个独立的类，在编译时内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 </li><li>有同名的成员变量和方法时:<ul><li>默认访问成员内部类的成员</li><li>访问外部类同名成员方式:<code>外部类.this.成员变量(成员方法)</code></li></ul></li></ol></li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li><p>概述:</p><ul><li>定义于另一个类的方法或作用域中的类</li><li>不能有public,protected,private及static修饰符</li></ul></li><li><p>定义格式:</p><pre class=" language-Java"><code class="language-Java">public class 外部类名称&#123;    修饰符  返回值类型  外部类方法（参数）&#123;     class 局部内部类名称&#123;     &#125;    &#125;&#125;</code></pre></li><li><p>访问方式</p><ul><li>局部内部类访问外部类<ul><li>new 外部类名().成员(变量或方法)</li></ul></li><li>外部类访问内部类<ul><li>调用内部类所在的方法,方法内执行内部类的操作;例:<pre class=" language-Java"><code class="language-Java">public class Demo1 &#123;  public void test()&#123;    class Poto&#123;        private String name;        public void potoFun()&#123;            System.out.println("这里是局部内部类方法");        &#125;      &#125;     Poto poto =new Poto();     poto.potoFun();  &#125;  public static void main(String [] args)&#123;    new Demo1().test();  &#125;&#125;</code></pre></li></ul></li></ul></li></ol><h2 id="权限修饰符在内部类中的使用"><a href="#权限修饰符在内部类中的使用" class="headerlink" title="权限修饰符在内部类中的使用"></a>权限修饰符在内部类中的使用</h2><p>权限修饰符规则：</p><ol><li>外部类： public /(default)</li><li>成员内部类  public/protected/(default)/private</li><li>局部内部类  什么都不能写</li></ol><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ol><li><p>概述:</p><ul><li>是内部类的简化写法。</li><li>本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code> 匿名的</code> 子类对象</li></ul></li><li><p>格式:</p><pre class=" language-Java"><code class="language-Java">new 父类名或者接口名()&#123;      @Override  // 方法重写    public void method() &#123;       // 执行语句    &#125;&#125;;</code></pre></li></ol><p>注意:</p><ol><li>匿名内部类必须继承一个父类或者实现一个父接口</li><li>匿名内部类在”创建对象”的时候,只能使用唯一一次.</li><li>如果希望多次创建对象,而且类的内容一样的话,那么就必须使用单独定义的实现类.</li></ol><p>使用<br>  只使用一次对象时使用,<br>  在方法的形式参数是接口或者抽象类时，可以将匿名内部类作为参数传递;例</p><pre class=" language-Java"><code class="language-Java">//  定义接口public interface class FlyAble&#123;   public abstract void fly();&#125;//  创建匿名内部类，并调用：public class InnerDemo &#123;    public static void main(String[] args) &#123;         //创建匿名内部类,直接传递给showFly(FlyAble f)         showFly(new FlyAble()&#123;             public void fly() &#123; //方法重写              System.out.println("我飞了~~~");           &#125;         &#125;);     &#125;        public static void showFly(FlyAble f) &#123;         f.fly();                                        &#125; &#125;</code></pre><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ol><li><p>概述</p><ul><li>有static关键字,不依赖外部类</li><li></li></ul></li><li><p>注意:<br>不能使用外部类非静态成员</p></li><li><p>格式:</p><pre class=" language-Java"><code class="language-Java">//创建静态内部类对象外部类名.内部类名 xxx = new 外部类名.内部类名()</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/2021/12/06/%E5%85%B6%E5%AE%83/AOP/"/>
      <url>/2021/12/06/%E5%85%B6%E5%AE%83/AOP/</url>
      
        <content type="html"><![CDATA[<p>为了甩锅，我写了个牛逼的日志切面！<br>Java后端技术 2022-04-06 09:19<br>往期热门文章：</p><p>1、撸了一个高仿 B站！</p><p>2、Spring Boot 生产中 16 条最佳实践</p><p>3、@Transactional 注解失效的3种原因及解决办法</p><p>4、我滴个乖乖，我复现了Spring的漏洞，害怕！</p><p>5、小学生们在B站讲算法，网友：我只会阿巴阿巴</p><p>来源：r6d.cn/2Zrc</p><p>最近项目进入联调阶段，服务层的接口需要和协议层进行交互，协议层需要将入参[json字符串]组装成服务层所需的json字符串，组装的过程中很容易出错。入参出错导致接口调试失败问题在联调中出现很多次，因此就想写一个请求日志切面把入参信息打印一下，同时协议层调用服务层接口名称对不上也出现了几次，通过请求日志切面就可以知道上层是否有没有发起调用，方便前后端甩锅还能拿出证据<br>写在前面<br>本篇文章是实战性的，对于切面的原理不会讲解，只会简单介绍一下切面的知识点<br>切面介绍<br>面向切面编程是一种编程范式，它作为OOP面向对象编程的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、权限控制、缓存控制、日志打印等等。AOP把软件的功能模块分为两个部分：核心关注点和横切关注点。业务处理的主要功能为核心关注点，而非核心、需要拓展的功能为横切关注点。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点进行分离，使用切面有以下好处：<br>集中处理某一关注点/横切逻辑<br>可以很方便的添加/删除关注点<br>侵入性少，增强代码可读性及可维护性 因此当想打印请求日志时很容易想到切面，对控制层代码0侵入<br>切面的使用【基于注解】<br>@Aspect =&gt; 声明该类为一个注解类<br>切点注解：<br>@Pointcut =&gt; 定义一个切点，可以简化代码<br>通知注解：<br>@Before =&gt; 在切点之前执行代码<br>@After =&gt; 在切点之后执行代码<br>@AfterReturning =&gt; 切点返回内容后执行代码，可以对切点的返回值进行封装<br>@AfterThrowing =&gt; 切点抛出异常后执行<br>@Around =&gt; 环绕，在切点前后执行代码<br>动手写一个请求日志切面<br>使用@Pointcut定义切点<br>@Pointcut(“execution(* your_package.controller..*(..))”)<br>public void requestServer() {<br>}<br>@Pointcut定义了一个切点，因为是请求日志切边，因此切点定义的是Controller包下的所有类下的方法。定义切点以后在通知注解中直接使用requestServer方法名就可以了<br>使用@Before再切点前执行<br>@Before(“requestServer()”)<br>public void doBefore(JoinPoint joinPoint) {<br>    ServletRequestAttributes attributes = (ServletRequestAttributes)<br>RequestContextHolder.getRequestAttributes();<br>    HttpServletRequest request = attributes.getRequest();</p><pre><code>LOGGER.info(&quot;===============================Start========================&quot;);LOGGER.info(&quot;IP                 : &#123;&#125;&quot;, request.getRemoteAddr());LOGGER.info(&quot;URL                : &#123;&#125;&quot;, request.getRequestURL().toString());LOGGER.info(&quot;HTTP Method        : &#123;&#125;&quot;, request.getMethod());LOGGER.info(&quot;Class Method       : &#123;&#125;.&#123;&#125;&quot;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</code></pre><p>}<br>在进入Controller方法前，打印出调用方IP、请求URL、HTTP请求类型、调用的方法名<br>使用@Around打印进入控制层的入参<br>@Around(“requestServer()”)<br>public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {<br>    long start = System.currentTimeMillis();<br>    Object result = proceedingJoinPoint.proceed();<br>    LOGGER.info(“Request Params       : {}”, getRequestParams(proceedingJoinPoint));<br>    LOGGER.info(“Result               : {}”, result);<br>    LOGGER.info(“Time Cost            : {} ms”, System.currentTimeMillis() - start);</p><pre><code>return result;</code></pre><p>}<br>打印了入参、结果以及耗时<br>getRquestParams方法<br>private Map&lt;String, Object&gt; getRequestParams(ProceedingJoinPoint proceedingJoinPoint) {<br>     Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();</p><pre><code>  //参数名 String[] paramNames = ((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames(); //参数值 Object[] paramValues = proceedingJoinPoint.getArgs(); for (int i = 0; i &lt; paramNames.length; i++) &#123;     Object value = paramValues[i];     //如果是文件对象     if (value instanceof MultipartFile) &#123;         MultipartFile file = (MultipartFile) value;         value = file.getOriginalFilename();  //获取文件名     &#125;     requestParams.put(paramNames[i], value); &#125; return requestParams;</code></pre><p> }<br>通过 @PathVariable以及@RequestParam注解传递的参数无法打印出参数名，因此需要手动拼接一下参数名，同时对文件对象进行了特殊处理，只需获取文件名即可<br>@After方法调用后执行<br>@After(“requestServer()”)<br>public void doAfter(JoinPoint joinPoint) {<br>    LOGGER.info(“===============================End========================”);<br>}<br>没有业务逻辑只是打印了End<br>完整切面代码<br>@Component<br>@Aspect<br>public class RequestLogAspect {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(RequestLogAspect.class);</p><pre><code>@Pointcut(&quot;execution(* your_package.controller..*(..))&quot;)public void requestServer() &#123;&#125;@Before(&quot;requestServer()&quot;)public void doBefore(JoinPoint joinPoint) &#123;    ServletRequestAttributes attributes = (ServletRequestAttributes) </code></pre><p>RequestContextHolder.getRequestAttributes();<br>        HttpServletRequest request = attributes.getRequest();</p><pre><code>    LOGGER.info(&quot;===============================Start========================&quot;);    LOGGER.info(&quot;IP                 : &#123;&#125;&quot;, request.getRemoteAddr());    LOGGER.info(&quot;URL                : &#123;&#125;&quot;, request.getRequestURL().toString());    LOGGER.info(&quot;HTTP Method        : &#123;&#125;&quot;, request.getMethod());    LOGGER.info(&quot;Class Method       : &#123;&#125;.&#123;&#125;&quot;, joinPoint.getSignature().getDeclaringTypeName(), </code></pre><p> joinPoint.getSignature().getName());<br>    }</p><pre><code>@Around(&quot;requestServer()&quot;)public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;    long start = System.currentTimeMillis();    Object result = proceedingJoinPoint.proceed();    LOGGER.info(&quot;Request Params     : &#123;&#125;&quot;, getRequestParams(proceedingJoinPoint));    LOGGER.info(&quot;Result               : &#123;&#125;&quot;, result);    LOGGER.info(&quot;Time Cost            : &#123;&#125; ms&quot;, System.currentTimeMillis() - start);    return result;&#125;@After(&quot;requestServer()&quot;)public void doAfter(JoinPoint joinPoint) &#123;    LOGGER.info(&quot;===============================End========================&quot;);&#125;/** * 获取入参 * @param proceedingJoinPoint * * @return * */private Map&lt;String, Object&gt; getRequestParams(ProceedingJoinPoint proceedingJoinPoint) &#123;    Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();    //参数名    String[] paramNames = </code></pre><p>((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames();<br>        //参数值<br>        Object[] paramValues = proceedingJoinPoint.getArgs();</p><pre><code>    for (int i = 0; i &lt; paramNames.length; i++) &#123;        Object value = paramValues[i];        //如果是文件对象        if (value instanceof MultipartFile) &#123;            MultipartFile file = (MultipartFile) value;            value = file.getOriginalFilename();  //获取文件名        &#125;        requestParams.put(paramNames[i], value);    &#125;    return requestParams;&#125;</code></pre><p>}</p><p>高并发下请求日志切面<br>写完以后对自己的代码很满意，但是想着可能还有完善的地方就和朋友交流了一下。emmmm<br>图片<br>果然还有继续优化的地方 每个信息都打印一行，在高并发请求下确实会出现请求之间打印日志串行的问题，因为测试阶段请求数量较少没有出现串行的情况，果然生产环境才是第一发展力，能够遇到更多bug，写更健壮的代码 解决日志串行的问题只要将多行打印信息合并为一行就可以了，因此构造一个对象<br>RequestInfo.java<br>@Data<br>public class RequestInfo {<br>    private String ip;<br>    private String url;<br>    private String httpMethod;<br>    private String classMethod;<br>    private Object requestParams;<br>    private Object result;<br>    private Long timeCost;<br>}<br>环绕通知方法体<br>@Around(“requestServer()”)<br>public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {<br>    long start = System.currentTimeMillis();<br>    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>    HttpServletRequest request = attributes.getRequest();<br>    Object result = proceedingJoinPoint.proceed();<br>    RequestInfo requestInfo = new RequestInfo();<br>            requestInfo.setIp(request.getRemoteAddr());<br>    requestInfo.setUrl(request.getRequestURL().toString());<br>    requestInfo.setHttpMethod(request.getMethod());<br>    requestInfo.setClassMethod(String.format(“%s.%s”, proceedingJoinPoint.getSignature().getDeclaringTypeName(),<br>            proceedingJoinPoint.getSignature().getName()));<br>    requestInfo.setRequestParams(getRequestParamsByProceedingJoinPoint(proceedingJoinPoint));<br>    requestInfo.setResult(result);<br>    requestInfo.setTimeCost(System.currentTimeMillis() - start);<br>    LOGGER.info(“Request Info      : {}”, JSON.toJSONString(requestInfo));</p><pre><code>return result;</code></pre><p>}<br>将url、http request这些信息组装成RequestInfo对象，再序列化打印对象 打印序列化对象结果而不是直接打印对象是因为序列化有更直观、更清晰，同时可以借助在线解析工具对结果进行解析.<br>图片<br>是不是还不错 在解决高并发下请求串行问题的同时添加了对异常请求信息的打印，通过使用 @AfterThrowing注解对抛出异常的方法进行处理<br>RequestErrorInfo.java<br>@Data<br>public class RequestErrorInfo {<br>    private String ip;<br>    private String url;<br>    private String httpMethod;<br>    private String classMethod;<br>    private Object requestParams;<br>    private RuntimeException exception;<br>}<br>异常通知环绕体<br>@AfterThrowing(pointcut = “requestServer()”, throwing = “e”)<br>public void doAfterThrow(JoinPoint joinPoint, RuntimeException e) {<br>    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>    HttpServletRequest request = attributes.getRequest();<br>    RequestErrorInfo requestErrorInfo = new RequestErrorInfo();<br>    requestErrorInfo.setIp(request.getRemoteAddr());<br>    requestErrorInfo.setUrl(request.getRequestURL().toString());<br>    requestErrorInfo.setHttpMethod(request.getMethod());<br>    requestErrorInfo.setClassMethod(String.format(“%s.%s”, joinPoint.getSignature().getDeclaringTypeName(),<br>            joinPoint.getSignature().getName()));<br>    requestErrorInfo.setRequestParams(getRequestParamsByJoinPoint(joinPoint));<br>    requestErrorInfo.setException(e);<br>    LOGGER.info(“Error Request Info      : {}”, JSON.toJSONString(requestErrorInfo));<br>}<br>对于异常，耗时是没有意义的，因此不统计耗时，而是添加了异常的打印<br>最后放一下完整日志请求切面代码：<br>@Component<br>@Aspect<br>public class RequestLogAspect {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(RequestLogAspect.class);</p><pre><code>@Pointcut(&quot;execution(* your_package.controller..*(..))&quot;)public void requestServer() &#123;&#125;@Around(&quot;requestServer()&quot;)public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;    long start = System.currentTimeMillis();    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    Object result = proceedingJoinPoint.proceed();    RequestInfo requestInfo = new RequestInfo();            requestInfo.setIp(request.getRemoteAddr());    requestInfo.setUrl(request.getRequestURL().toString());    requestInfo.setHttpMethod(request.getMethod());    requestInfo.setClassMethod(String.format(&quot;%s.%s&quot;, proceedingJoinPoint.getSignature().getDeclaringTypeName(),            proceedingJoinPoint.getSignature().getName()));    requestInfo.setRequestParams(getRequestParamsByProceedingJoinPoint(proceedingJoinPoint));    requestInfo.setResult(result);    requestInfo.setTimeCost(System.currentTimeMillis() - start);    LOGGER.info(&quot;Request Info      : &#123;&#125;&quot;, JSON.toJSONString(requestInfo));    return result;&#125;@AfterThrowing(pointcut = &quot;requestServer()&quot;, throwing = &quot;e&quot;)public void doAfterThrow(JoinPoint joinPoint, RuntimeException e) &#123;    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    RequestErrorInfo requestErrorInfo = new RequestErrorInfo();    requestErrorInfo.setIp(request.getRemoteAddr());    requestErrorInfo.setUrl(request.getRequestURL().toString());    requestErrorInfo.setHttpMethod(request.getMethod());    requestErrorInfo.setClassMethod(String.format(&quot;%s.%s&quot;, joinPoint.getSignature().getDeclaringTypeName(),            joinPoint.getSignature().getName()));    requestErrorInfo.setRequestParams(getRequestParamsByJoinPoint(joinPoint));    requestErrorInfo.setException(e);    LOGGER.info(&quot;Error Request Info      : &#123;&#125;&quot;, JSON.toJSONString(requestErrorInfo));&#125;/** * 获取入参 * @param proceedingJoinPoint * * @return * */private Map&lt;String, Object&gt; getRequestParamsByProceedingJoinPoint(ProceedingJoinPoint proceedingJoinPoint) &#123;    //参数名    String[] paramNames = ((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames();    //参数值    Object[] paramValues = proceedingJoinPoint.getArgs();    return buildRequestParam(paramNames, paramValues);&#125;private Map&lt;String, Object&gt; getRequestParamsByJoinPoint(JoinPoint joinPoint) &#123;    //参数名    String[] paramNames = ((MethodSignature)joinPoint.getSignature()).getParameterNames();    //参数值    Object[] paramValues = joinPoint.getArgs();    return buildRequestParam(paramNames, paramValues);&#125;private Map&lt;String, Object&gt; buildRequestParam(String[] paramNames, Object[] paramValues) &#123;    Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();    for (int i = 0; i &lt; paramNames.length; i++) &#123;        Object value = paramValues[i];        //如果是文件对象        if (value instanceof MultipartFile) &#123;            MultipartFile file = (MultipartFile) value;            value = file.getOriginalFilename();  //获取文件名        &#125;        requestParams.put(paramNames[i], value);    &#125;    return requestParams;&#125;@Datapublic class RequestInfo &#123;    private String ip;    private String url;    private String httpMethod;    private String classMethod;    private Object requestParams;    private Object result;    private Long timeCost;&#125;@Datapublic class RequestErrorInfo &#123;    private String ip;    private String url;    private String httpMethod;    private String classMethod;    private Object requestParams;    private RuntimeException exception;&#125;</code></pre><p>}<br>赶紧给你们的应用加上吧【如果没加的话】，没有日志的话，总怀疑上层出错，但是却拿不出证据<br>图片<br>关于traceId 跟踪定位，可以根据traceId跟踪整条调用链，以log4j2为例介绍如何加入traceId<br>添加拦截器<br>public class LogInterceptor implements HandlerInterceptor {<br>    private final static String TRACE_ID = “traceId”;</p><pre><code>@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    String traceId = java.util.UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).toUpperCase();    ThreadContext.put(&quot;traceId&quot;, traceId);    return true;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)        throws Exception &#123;&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)        throws Exception &#123;    ThreadContext. remove(TRACE_ID);&#125;</code></pre><p>}<br>在调用前通过ThreadContext加入traceId，调用完成后移除<br>修改日志配置文件 在原来的日志格式中 添加traceId的占位符<br><property name="pattern">[TRACEID:%X{traceId}] %d{HH:mm:ss.SSS} %-5level %class{-1}.%M()/%L - %msg%xEx%n</property><br>执行效果<br>图片<br>日志跟踪更方便 DMC是配置logback和log4j使用的，使用方式和ThreadContext差不多，将ThreadContext.put替换为MDC.put即可，同时修改日志配置文件。<br>图片<br>MDC是slf4j包下的，其具体使用哪个日志框架与我们的依赖有关.<br>往期热门文章：<br>1、我滴个乖乖，我复现了Spring的漏洞，害怕！<br>2、分布式锁用 Redis 还是 Zookeeper？<br>3、最适合晚上睡不着看的 8 个网站，建议收藏哦<br>4、String长度有限制吗？<br>5、14家互联网公司裁员（1-2月裁员清单）<br>6、Redis实现分布式锁的8大坑！切记！<br>7、请立即卸载这款 IDEA 插件！<br>8、Thread.sleep(0) 到底有什么用？<br>9、为什么不建议用try catch处理异常？<br>10、MySQL 为啥不能用 UUID 做主键？<br>图片<br>阅读 4224<br>写下你的留言</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>耦合</title>
      <link href="/2021/12/06/%E5%85%B6%E5%AE%83/%E8%80%A6%E5%90%88/"/>
      <url>/2021/12/06/%E5%85%B6%E5%AE%83/%E8%80%A6%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h2><p>耦合性(Coupling)，也叫耦合度<br>模块间的耦合度是指<strong>模块之间的依赖关系</strong>，包括控制关系、调用关系、数据传递关系<br>模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)<br>在项目中，耦合指的是<code>对象之间的依赖性</code>;对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小</p><p>软件设计中的一个准则就是<strong>高内聚低耦合</strong>。</p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><p>（1）内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另<br>一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。<br>（2）公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大<br>量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。<br>（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传<br>递该全局变量的信息，则称之为外部耦合。<br>（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进<br>行适当的动作，这种耦合被称为控制耦合。<br>（5）标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间<br>存在一个标记耦合。<br>（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形<br>式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另<br>一些模块的输入数据。<br>（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实<br>现的。 </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须<br>存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。<br>内聚与耦合<br>内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从<br>功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件<br>结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通<br>过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之<br>间的相互依存度却要不那么紧密。<br>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他<br>模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合.<br>我们在开发中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。 </p><p>第2章 IoC 的概念和作用<br>2.1 程序的耦合和解耦[理解] </p><p>请看下面的示例代码：<br>/** </p><ul><li>账户的业务层实现类 </li><li>@author 德源教育 </li><li>@Company <a href="http://www.deyuan.com/">http://www.deyuan.com</a> </li><li>@Version 1.0 </li><li>/<br>public class AccountServiceImpl implements IAccountService {<br>private IAccountDao accountDao = new AccountDaoImpl();<br>}<br>上面的代码表示：<br>业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译<br>将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决</li></ul><p>再比如：<br>早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采<br>用 Class.forName 的方式？<br>public class JdbcDemo1 {<br>/** </p><ul><li>@author 德源教育 </li><li>@Company <a href="http://www.doyens.com/">http://www.doyens.com</a> </li><li>@Version 1.0 </li><li>@param args </li><li>@throws Exception </li><li>/<br>public static void main(String[] args) throws Exception {<br>//1.注册驱动<br>//DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>Class.forName(“com.mysql.jdbc.Driver”);<br>//2.获取连接<br>//3.获取预处理 sql 语句对象<br>//4.获取结果集<br>//5.遍历结果集<br>}<br>}<br>原因就是：<br>我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要<br>修改源码来重新数据库驱动。这显然不是我们想要的。 </li></ul><p>2.1.2 解决程序耦合的思路<br>当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下：<br>Class.forName(“com.mysql.jdbc.Driver”);//此处只是一个字符串</p><p>此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运<br>行就不要想了，没有驱动不可能运行成功的）。<br>同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改<br>源码。<br>解决这个问题也很简单，使用配置文件配置。</p><p>2.1.3 工厂模式解耦<br>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的<br>方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。<br>那么，这个读取配置文件，创建和获取三层对象的类就是工厂。<br>2.1.4 控制反转-Inversion Of Control<br>上一小节解耦的思路有 2 个问题：<br>1、存哪去？<br>分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。<br>到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。<br>所以我们的答案就是<br>在应用加载时，创建一个 Map，用于存放三层对象。<br>我们把这个 map 称之为容器。<br>2、还是没解释什么是工厂？<br>工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。<br>原来：<br>我们在获取对象时，都是采用 new 的方式。是主动的。</p><p>现在：<br>我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo插入图片</title>
      <link href="/2021/12/06/%E5%85%B6%E5%AE%83/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2021/12/06/%E5%85%B6%E5%AE%83/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="HEXO插入图片"><a href="#HEXO插入图片" class="headerlink" title="HEXO插入图片"></a>HEXO插入图片</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-asset-image --save</code></pre><h3 id="修改-config-yml配置"><a href="#修改-config-yml配置" class="headerlink" title="修改_config.yml配置"></a>修改_config.yml配置</h3><blockquote><p>打开hexo的配置文件_config.yml找到 post_asset_folder，把这个选项从false改成true</p></blockquote><h3 id="替换插件源码"><a href="#替换插件源码" class="headerlink" title="替换插件源码"></a>替换插件源码</h3><blockquote><p>打开/node_modules/hexo-asset-image/index.js替换为如下代码:</p></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">'use strict';var cheerio=require('cheerio');function getPosition(str,m,i)&#123;return str.split(m,i).join(m).length&#125;var version=String(hexo.version).split('.');hexo.extend.filter.register('after_post_render',function(data)&#123;var config=hexo.config;if(config.post_asset_folder)&#123;var link=data.permalink;if(version.length>0&&Number(version[0])==3)var beginPos=getPosition(link,'/',1)+1;else var beginPos=getPosition(link,'/',3)+1;var endPos=link.lastIndexOf('/')+1;link=link.substring(beginPos,endPos);var toprocess=['excerpt','more','content'];for(var i=0;i<toprocess.length;i++)&#123;var key=toprocess[i];var $=cheerio.load(data[key],&#123;ignoreWhitespace:false,xmlMode:false,lowerCaseTags:false,decodeEntities:false&#125;);$('img').each(function()&#123;if($(this).attr('src'))&#123;var src=$(this).attr('src').replace('\\','/');if(!/http[s]*.*|\/\/.*/.test(src)&&!/^\s*\//.test(src))&#123;var linkArray=link.split('/').filter(function(elem)&#123;return elem!=''&#125;);var srcArray=src.split('/').filter(function(elem)&#123;return elem!=''&&elem!='.'&#125;);if(srcArray.length>1)srcArray.shift();src=srcArray.join('/');$(this).attr('src',config.root+link+src);console.info&&console.info("update link as:-->"+config.root+link+src)&#125;&#125;else&#123;console.info&&console.info("no src attr, skipped...");console.info&&console.info($(this))&#125;&#125;);data[key]=$.html()&#125;&#125;&#125;);</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>现在可以插入图片了，<br>在hexo new post photo之后就在source/_posts生成photo.md文件和photo文件夹，把要插入的图片复制到photo文件夹内，在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）<br>比如: &nbsp;&nbsp;&nbsp;![代替图片的文字](head.jpeg)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境</title>
      <link href="/2021/12/02/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/12/02/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机——JVM"><a href="#虚拟机——JVM" class="headerlink" title="虚拟机——JVM"></a>虚拟机——JVM</h2><ul><li>概述:<ul><li>JVM（Java Virtual Machine ）: Java虚拟机，简称JVM，是Java程序的运行环境，是Java 最具吸引力的特性之一。 </li></ul></li><li>特性：<ul><li>跨平台: 软件的运行，都必须在操作系统之上，而Java编写的软件可以运行在任何操作系统上，这个特性称为Java<strong>语言的跨平台特性</strong>。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。<br><img src="/2021/12/02/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%8E%AF%E5%A2%83/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.png"></li></ul></li></ul><h2 id="运行时环境——JRE"><a href="#运行时环境——JRE" class="headerlink" title="运行时环境——JRE"></a>运行时环境——JRE</h2><ul><li>概述:<ul><li>JRE: Java程序的运行时环境,包含JVM和运行时需要的核心类库</li></ul></li></ul><h2 id="开发环境——JDK"><a href="#开发环境——JDK" class="headerlink" title="开发环境——JDK"></a>开发环境——JDK</h2><ul><li>概述:<ul><li>JDK: Java程序的开发工具包,包含JRE和开发使用的工具</li></ul></li><li>安装:<ul><li>Windows10搭建Java环境<ol><li>卸载<br>打开控制面板<br> -&gt;卸载程序<br> -&gt;Java(Tm)     右键卸载<br> -&gt;Java        右键卸载</li><li>安装<br>安装开发工具,修改安装路径<br>出现jre的安装,点击 X 取消安装</li><li>环境变量-&gt;系统变量<br>JAVA_HOME(没有则新增)        D:\developer\Java\jdk1.8.0_144(jdk目录)<br>CLASSPATH(没有则新增)    .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;<br>Path(没有则新增)        %JAVA_HOME%\bin</li><li>测试环境是否配置成功<br> cmd下运行Java -version<pre class=" language-bash"><code class="language-bash">Java -version</code></pre></li></ol></li></ul></li></ul><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="/2021/12/02/Java/Java%20SE%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E7%8E%AF%E5%A2%83/Java%E7%8E%AF%E5%A2%83%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p><font color="red"><strong>运行Java程序,只需安装JRE!!!</strong></font><br><font color="red"><strong>开发Java程序,必须安装JDK!!!</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2021/12/01/%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/01/%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>思路：<ul><li>比较相邻的元素,如果第一个比第二个大，就交换它们两个,每轮确定一个最大值,并放入末尾</li><li>下一轮就可以少比较一个</li><li>每个元素都需要比较,所以轮数为长度-1次</li><li>每比一次,就确定一个最大值,就代表一轮结束,所以比较的次数为长度-1-i&nbsp;&nbsp;i为当前的轮数</li></ul></li><li>实现：<ul><li>使用双重for循环</li><li>外层循环控制轮数</li><li>内层循环控制比较的次数</li></ul></li><li>案例:<pre class=" language-Java"><code class="language-Java">public  int[] bubbleSort(int[] arr)&#123; int arrLength = arr.length; for (int i = 0; i < arrLength - 1; i++) &#123;     for (int j = 0; j < arrLength - 1 - i; j++) &#123;         if (arr[j] > arr[j + 1]) &#123;             arr[j] = arr[j] ^ arr[j + 1];             arr[j + 1] = arr[j + 1] ^ arr[j];             arr[j] = arr[j] ^ arr[j + 1];         &#125;     &#125; &#125; return arr;&#125; </code></pre><pre class=" language-JavaScript"><code class="language-JavaScript">function bubbleSort(arr) &#123; var len = arr.length; var temp = null; for (var i = 0; i < len - 1; i++) &#123;     for (var j = 0; j < len - 1 - i; j++) &#123;         if (arr[j] > arr[j+1]) &#123;        // 相邻元素两两对比             temp = arr[j+1];        // 元素交换             arr[j+1] = arr[j];             arr[j] = temp;         &#125;     &#125; &#125; return arr;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/2021/12/01/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2021/12/01/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2021/12/01/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
      <url>/2021/12/01/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mocker-api</title>
      <link href="/2021/11/27/%E5%89%8D%E7%AB%AF/mocker-api/"/>
      <url>/2021/11/27/%E5%89%8D%E7%AB%AF/mocker-api/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>拦截 Ajax 请求,自定义返回数据<br><a href="https://www.npmjs.com/package/mocker-api">npm地址</a></p></blockquote><h2 id="Vue项目中使用mocker-api进行mock"><a href="#Vue项目中使用mocker-api进行mock" class="headerlink" title="Vue项目中使用mocker-api进行mock"></a>Vue项目中使用mocker-api进行mock</h2><h3 id="安装mocker-api"><a href="#安装mocker-api" class="headerlink" title="安装mocker-api"></a>安装mocker-api</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i mocker-api --save-dev</code></pre><h3 id="根目录编写-mocker-index-js，用于定义mock接口"><a href="#根目录编写-mocker-index-js，用于定义mock接口" class="headerlink" title="根目录编写 /mocker/index.js，用于定义mock接口"></a>根目录编写 /mocker/index.js，用于定义mock接口</h3><pre class=" language-JavaScript"><code class="language-JavaScript">// 使用 require 引入json文件，可以直接访问数据const appData = require('../data.json')const proxy = &#123;    'POST /api/userLogin':        (req, res) => &#123;            res.send(&#123;                code: 200,                data: appData.userLogin,            &#125;);        &#125;,    'GET /api/list': [      &#123; id: 1, username: 'kenny', sex: 6 &#125;,      &#123; id: 2, username: 'kenny', sex: 6 &#125;    ],    'POST /api/post': (req, res) => &#123;        res.send(&#123;            status: 'error',            code: 403        &#125;);    &#125;,    'DELETE /api/remove': (req, res) => &#123;        res.send(&#123;            status: 'ok',            message: '删除成功！'        &#125;);    &#125;,    'GET /api/:owner/:repo/raw/:ref/(.*)': (req, res) => &#123;        const &#123; owner, repo, ref &#125; = req.params;        // http://localhost:8081/api/admin/webpack-mock-api/raw/master/add/ddd.md        // owner => admin        // repo => webpack-mock-api        // ref => master        // req.params[0] => add/ddd.md        return res.json(&#123;          id: 1,          owner, repo, ref,          path: req.params[0]        &#125;);      &#125;,      'POST /api/login/account': (req, res) => &#123;        const &#123; password, username &#125; = req.body;        if (password === '888888' && username === 'admin') &#123;          return res.json(&#123;            status: 'ok',            code: 0,            token: "sdfsdfsdfdsf",            data: &#123;              id: 1,              username: 'kenny',              sex: 6            &#125;          &#125;);        &#125; else &#123;          return res.status(403).json(&#123;            status: 'error',            code: 403          &#125;);        &#125;      &#125;,      'DELETE /api/user/:id': (req, res) => &#123;        console.log('---->', req.body)        console.log('---->', req.params.id)        res.send(&#123; status: 'ok', message: '删除成功！' &#125;);      &#125;&#125;module.exports = proxy</code></pre><h3 id="修改-vue-config-js-配置文件（若不存在，在项目下新建即可）"><a href="#修改-vue-config-js-配置文件（若不存在，在项目下新建即可）" class="headerlink" title="修改 vue.config.js 配置文件（若不存在，在项目下新建即可）"></a>修改 vue.config.js 配置文件（若不存在，在项目下新建即可）</h3><pre class=" language-JavaScript"><code class="language-JavaScript">const path = require('path')const apiMocker = require('mocker-api')module.exports = &#123;  devServer: &#123;    before(app) &#123;      // 1. 执行apiMocker,加载mock接口配置      apiMocker(app, path.resolve('./mocker/index.js'), &#123;        proxy: &#123;          // 将路径字符串转成正则表达式          '/repos/(.*)': 'https://api.github.com/',        &#125;,        // 重写目标的 url 路径。对象键将用作 RegExp 来匹配路径。        pathRewrite: &#123;          '^/api/repos/': '/repos/',        &#125;,        changeHost: true,        // 修改http-proxy选项        httpProxy: &#123;          options: &#123;            ignorePath: true,          &#125;,          listeners: &#123;            proxyReq: function (proxyReq, req, res, options) &#123;              console.log('proxyReq');            &#125;,          &#125;,        &#125;,      &#125;)    &#125;  &#125;&#125;</code></pre><h3 id="定义json-数据（用于测试-根目录新增data-json编写模拟数据"><a href="#定义json-数据（用于测试-根目录新增data-json编写模拟数据" class="headerlink" title="定义json 数据（用于测试)根目录新增data.json编写模拟数据"></a>定义json 数据（用于测试)根目录新增data.json编写模拟数据</h3><pre class=" language-JavaScript"><code class="language-JavaScript">&#123;    "login": &#123;      "success": "true",      "message": "登陆成功"    &#125;,    "fileList": &#123;      "success":"true",      "list":[      &#123;"fileId":"1","fileName":"a1.c","content":"content-test1"      &#125;,      &#123;"fileId":"2","fileName":"a2.c","content":"content-test2"      &#125;,      &#123;"fileId":"3","fileName":"a3.c","content":"content-test2"      &#125;,      &#123;"fileId":"4","fileName":"a4.c","content":"content-test2"      &#125;,      &#123;"fileId":"5","fileName":"a5.c","content":"content-test2"      &#125;,      &#123;"fileId":"6","fileName":"a8.c","content":"content-test2"      &#125;,      &#123;"fileId":"7","fileName":"a9.c","content":"content-test2"      &#125;]    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 请求拦截,数据模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP库-axios-vue</title>
      <link href="/2021/11/15/%E5%89%8D%E7%AB%AF/HTTP%E5%BA%93-axios-vue/"/>
      <url>/2021/11/15/%E5%89%8D%E7%AB%AF/HTTP%E5%BA%93-axios-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> axios</code></pre><p>使用 cdn:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="vue中使用axios"><a href="#vue中使用axios" class="headerlink" title="vue中使用axios"></a>vue中使用axios</h2><ol><li>安装<pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> axios</code></pre>安装qs库,修改post请求的编码数据<pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> qs</code></pre></li><li>创建src/plugins/axios.js配置文件;内容如下:<pre class=" language-JavaScript"><code class="language-JavaScript">"use strict";import axios from "axios";import qs from 'qs'//转换数据类型;post请求需要转换字符串类型// cors跨域 如果浏览器开启cookie,则使用withCredentials启用跨域验证if (navigator.cookieEnabled) axios.defaults.withCredentials = trueaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';//全局配置let config = &#123;baseURL: process.env.VUE_APP_BASE_URL,timeout: 3000, // Timeout// withCredentials: true, // Check cross-site Access-Control&#125;;//创建axios实例const _axios = axios.create(config);//请求拦截_axios.interceptors.request.use(config => &#123; //post请求需要转换字符串类型,在请求拦截中封装 if (config.method === "post") &#123;   config.data = qs.stringify(config.data) &#125; if (sessionStorage.getItem("manageToken")) &#123;   config.headers.Authorization = sessionStorage.getItem("manageToken") &#125; return config;&#125;,error => Promise.reject(error));// 响应拦截// Add a response interceptor_axios.interceptors.response.use(response => response.status === 200 || response.status === 304 ? Promise.resolve(response.data) : Promise.reject(response),error => &#123;// Do something with response error const &#123; response &#125; = error; if (response) &#123;   errorHandle(response.status, response.data);   return Promise.reject(error); &#125; console.log("连接失败,请检查网络!!!")&#125;);// 响应状态码的错误处理const errorHandle = (status, info) => &#123;switch (status) &#123; case 400:   console.log("语法错误")   break; case 401:   console.log("请进行身份认证")   break case 403:   console.log("服务器理解请求客户端的请求，但是拒绝执行此请求            ")   break case 404:   console.log("服务器无法根据客户端的请求找到资源（网页）。")   break default:   console.log(info)&#125;&#125;// Plugin.install = function (Vue) &#123;//   Vue.axios = _axios;//   window.axios = _axios;//   Object.defineProperties(Vue.prototype, &#123;//     axios: &#123; get() &#123; return _axios &#125; &#125;,//     $axios: &#123; get() &#123; return _axios &#125; &#125;,//   &#125;);// &#125;;export default _axios;</code></pre></li><li>创建src/api/api.js接口文件,引入配置的axios并创建请求函数;内容如下:<pre class=" language-JavaScript"><code class="language-JavaScript">import axios from "@/plugins/axios"// postconst apiPost = data => axios(&#123; url: 'users', method: 'post', data &#125;)// deleteconst apiDelete = data => axios(&#123; url: `users/$&#123;data&#125;`, method: 'delete' &#125;)// putconst apiPut = data => axios(&#123; url: `users/$&#123;data.id&#125;/state/$&#123;data.status&#125;`, method: 'put'&#125;)// getconst apiGet = () => axios(&#123; url: 'rights/list' &#125;)const apiGet2 = data => axios(&#123; url: `rights/list?$&#123;data&#125;`&#125;)export &#123; apiPost, apiDelete, apiPut, apiGet, apiGet2&#125;</code></pre></li><li>引入api.js接口文件,在vue页面中使用请求函数<pre class=" language-JavaScript"><code class="language-JavaScript">import &#123; apiPost, apiDelete, apiPut,apiGet &#125; from '@/api/api'export default &#123;data() &#123;return &#123; &#125; &#125;,methods: &#123; post: async function () &#123;   let res = await apiPost()   if (res.code !== 200) &#123;     console.log(res.msg)     return   &#125;   console.log(res.data) &#125;&#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node版本管理工具-nvmw</title>
      <link href="/2021/11/15/Node/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-nvmw/"/>
      <url>/2021/11/15/Node/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-nvmw/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nvmw 是 Windows 下的 node 管理工具<br><font color="red">已经安装node了，则需要先卸载</font></p><h2 id="nvmw常用操作"><a href="#nvmw常用操作" class="headerlink" title="nvmw常用操作"></a>nvmw常用操作</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g nvmw</code></pre><h3 id="查看nvmw版本"><a href="#查看nvmw版本" class="headerlink" title="查看nvmw版本"></a>查看nvmw版本</h3><pre class=" language-bash"><code class="language-bash">nvmw -V</code></pre><h3 id="nvmw下载不同的node版本"><a href="#nvmw下载不同的node版本" class="headerlink" title="nvmw下载不同的node版本"></a>nvmw下载不同的node版本</h3><p>命令：</p><pre class=" language-bash"><code class="language-bash">nvmw <span class="token function">install</span> v版本号</code></pre><p>例：<code>nvmw install v12.13.0</code></p><h3 id="nvmw当前终端切换node版本"><a href="#nvmw当前终端切换node版本" class="headerlink" title="nvmw当前终端切换node版本"></a>nvmw当前终端切换node版本</h3><p>命令：</p><pre class=" language-bash"><code class="language-bash">nvmw use  v版本号</code></pre><p>例：<code>nvmw use v12.13.0</code></p><h3 id="nvmw永久切换node版本"><a href="#nvmw永久切换node版本" class="headerlink" title="nvmw永久切换node版本"></a>nvmw永久切换node版本</h3><p>命令：</p><pre class=" language-bash"><code class="language-bash">nvmw switch v版本号</code></pre><p>例：<code>nvmw switch  v12.13.0</code></p><h3 id="nvmw查看node版本"><a href="#nvmw查看node版本" class="headerlink" title="nvmw查看node版本"></a>nvmw查看node版本</h3><pre class=" language-bash"><code class="language-bash">nvmw <span class="token function">ls</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvmw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简介</title>
      <link href="/2021/11/15/Java/Maven/%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/11/15/Java/Maven/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>maven是一款项目管理工具，对Java进行构建,依赖管理</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>依赖管理(解决jar包冲突)</li><li>项目构建(一键完成 编译,打包,部署,发布等操作)</li></ol><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>安装：<br>  直接解压即可<br>  注意：目录中不要有中文和空格</li><li>环境变量：<br>  创建MAVEN_HOME,路径配置maven的根目录。<br>  在系统变量的path变量中添加 %MAVEN_HOME%\bin</li><li>测试:<br>  cmd中输入:<code>mvn -v</code>输出版本信息即为环境搭建成功</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>  本地仓库(本地的仓库)<br>  远程仓库[私服])(公司搭建的仓库)<br>  中央仓库(maven搭建的仓库,在国外)-&gt;可以使用阿里的仓库</p><ul><li>项目中需要的依赖，会先从本地仓库去找，如果本地仓库没有，在联网的情况下，    会从中央仓库去下载。</li><li>在公司一般配有自己的远程仓库，当我们和远程仓库处于同一个局域网时，如果    本地仓库没有依赖，会先从远程仓库去找，如果远程仓库没有，远程仓库会从中央    仓库去下载</li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>bin                 可执行的二进制文件。mvn指令<br>boot                maven自身需要的一个文件。<br>conf\settings.xml   maven的配置文件<br>lib                 maven运行自身需要的一些jar包。</p><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p> <code>&lt;localRepository&gt;本地仓库路径&lt;/localRepository&gt;</code></p><h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2><p><strong>普通java项目</strong></p><ul><li>src<ul><li>main            <ul><li>java                Java源代码        </li><li>resources            项目资源,如property文件,xml文件等</li></ul></li><li>test                测试代码<ul><li>java                项目测试(junit)</li><li>resources            测试用的资源</li></ul></li></ul></li><li>target        打包输出目录<ul><li>classes       编译输出目录</li><li>test-classes  测试编译输出目录</li></ul></li><li>pom.xml   项目的信息和jar包的信息和插件的信息</li></ul><p><strong>web项目</strong></p><ul><li>src<ul><li>main            <ul><li>java                Java源代码        </li><li>resources            项目资源,如property文件,xml文件等</li><li>webapp<ul><li>WEB-INF   web应用文件目录,图片,页面等</li></ul></li></ul></li><li>test                测试代码<ul><li>java                项目测试(junit)</li><li>resources            测试用的资源</li></ul></li></ul></li><li>target        打包输出目录<ul><li>classes       编译输出目录</li><li>test-classes  测试编译输出目录</li></ul></li><li>pom.xml   项目的信息和jar包的信息和插件的信息</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>clean<br>compile<br>test<br>package<br>install<br>deploy</p><p>6.常用的maven命令<br>clean：清理。把生成的字节码文件删除。<br>compile：编译。可以把src/main/java文件编译为字节码文件<br>test：测试。可以把src/test/java文件编译为字节码文件。<br>package：打包。可以把代码进行打包。<br>普通java项目打成jar包。可以提供给别人使用。<br>web项目打成war包。部署在服务器上。<br>可以在pom.xml文件中指定项目的打包方式。<br>install：安装。可以将打好的jar包复制到本地仓库中。<br>deploy：部署。帮我们把web项目的war包部署到服务器中。<br>7.maven的声明周期<br>maven对项目进行构建过程分为三套独立的生命周期。<br>清理周期：clean<br>默认周期：compile    test      package     install        deploy<br>站点生命周期：生成项目报告，站点，发布站点。<br>8.maven概念模型<br>1.通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、插件目标<br>2.依赖管理系统。通过 maven 的依赖管理对项目所依赖的 jar 包进行统一管理。<br>9.pom文件介绍：<br><groupId>com.deyuan.maven</groupId>    – 项目组名称<br><artifactId>maven-helloworld</artifactId>    – 项目名称<br><version>0.0.1-SNAPSHOT</version>        – 版本<br><packaging>war</packaging>                – 打包方式</p><p>dependencies    ： 里面是项目所需要的依赖坐标。<br>build：可以在此标签中给项目添加插件信息。</p><p>三、idea中配置maven环境<br>在Runner的VM options：<br>-DarchetypeCatalog=internal<br>创建普通java项目不建议使用骨架。<br>创建web项目建议使用骨架。webapp<br>jar包坐标：<br><a href="https://mvnrepository.com/">https://mvnrepository.com/</a><br><scope>：依赖范围<br>compile：编译期，测试期，运行时都生效        例如：spring-core<br>test：测试期生效                            例如：junit<br>provided：编译期，测试期有效                例如：servlet<br>runtime：测试期，运行时生效                例如：JDBC<br>system：编译期，测试期有效                本地的，maven仓库之外的类库</scope></p><p>依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test</p><p>2.插件<br><plugins><br>  <plugin><br>    <groupId>org.apache.maven.plugins</groupId><br>    <artifactId>maven-compiler-plugin</artifactId><br>    <configuration><br>      <source>1.8<br>      <target>1.8</target><br>      <encoding>utf-8</encoding><br>    </configuration><br>  </plugin></plugins></p>  <plugin>    <groupId>org.apache.tomcat.maven</groupId>    <artifactId>tomcat7-maven-plugin</artifactId>    <version>2.2</version>    <configuration>      <port>8082</port>      <path></path>/    </configuration>  </plugin><h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><p>Project Object Model  项目对象模型<br>是 Maven 工程的基本工作单元，一个XML文件，包含项目的基本信息，用于描述项目构建，声明项目依赖等</p><p>支持的配置</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>pom.xml配置信息:</p><pre class=" language-XML"><code class="language-XML"><!-- 根标签 --><project><!-- 模型版本 --><modelVersion>4.15</modelVersion><!-- 公司或组织的标志 --><groupId>com.dy.zrh</groupId><!-- 项目唯一Id 一个groupId下可能有多个项目,依靠artifactId来区分 --><artifactId>test</artifactId><!-- 版本号 --><version></version></project></code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><!-- maven-package-build-phase.png --><p>验证 validate    验证项目    验证项目是否正确且所有必须信息是可用的<br>编译 compile    执行编译    源代码编译在此阶段完成<br>测试 Test    测试    使用适当的单元测试框架（例如JUnit）运行测试。<br>包装 package    打包    创建JAR/WAR包如在 pom.xml 中定义提及的包<br>检查 verify    检查    对集成测试的结果进行检查，以保证质量达标<br>安装 install    安装    安装打包的项目到本地仓库，以供其他项目使用<br>部署 deploy    部署    拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端rem</title>
      <link href="/2021/11/15/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem/"/>
      <url>/2021/11/15/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐使用以下两个工具"><a href="#推荐使用以下两个工具" class="headerlink" title="推荐使用以下两个工具"></a>推荐使用以下两个工具</h2><ul><li>postcss-pxtorem  <ul><li>是一款postcss插件，用于将单位转化为 rem  </li></ul></li><li>lib-flexible<ul><li>用于设置 rem 基准值</li></ul></li></ul><h2 id="使用-lib-flexible-动态设置REM基准值（html标签的字体大小）"><a href="#使用-lib-flexible-动态设置REM基准值（html标签的字体大小）" class="headerlink" title="使用 lib-flexible 动态设置REM基准值（html标签的字体大小）"></a>使用 lib-flexible 动态设置REM基准值（html标签的字体大小）</h2><ol><li><p>安装</p><pre class=" language-bash"><code class="language-bash">yarn add amfe-flexible<span class="token comment" spellcheck="true"># 或</span><span class="token function">npm</span> i amfe-flexible</code></pre></li><li><p>在 main.js 中加载执行该模块</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> <span class="token string">'amfe-flexible'</span></code></pre></li><li><p>测试：<br> <strong>在浏览器中切换不同的手机设备尺寸，观察 html 标签 font-size 的变化。</strong></p><ul><li>例如在 iPhone 6/7/8 设备下，html 标签字体大小为 37.5 px</li><li>例如在 iPhone 6/7/8 Plus 设备下，html 标签字体大小为 41.4 px</li></ul></li></ol><h2 id="使用-postcss-pxtorem-将-px-转为-rem"><a href="#使用-postcss-pxtorem-将-px-转为-rem" class="headerlink" title="使用 postcss-pxtorem 将 px 转为 rem"></a>使用 postcss-pxtorem 将 px 转为 rem</h2><blockquote><p>注意<br>    <strong><font color="red">该插件不能转换行内样式中的 px，例如 <code>&lt;div style=&quot;width: 200px;&quot;&gt;&lt;/div&gt;</code></font></strong><br>    <strong><font color="red">postcss-pxtorem扫描的是css文件，要转换的class样式设置在当前vue文件转换是不会生效的</font></strong></p></blockquote><ol><li>安装<pre class=" language-bash"><code class="language-bash">yarn add -D postcss-pxtorem<span class="token comment" spellcheck="true"># 或</span><span class="token function">npm</span> <span class="token function">install</span> postcss-pxtorem -D</code></pre></li><li>在vue.config.js中配置postcss-pxtorem</li></ol><pre class=" language-vue"><code class="language-vue">module.exports = &#123;  lintOnSave: true,  css: &#123;    loaderOptions: &#123;      postcss: &#123;        plugins: [          //在这里配置postcss-pxtorem          require('postcss-pxtorem')(&#123;            rootValue(&#123; file &#125;) &#123;              //如果是 Vant 的样式，就把 rootValue 设置为 37.5 来转换              //如果是我们的样式，就按照 75 的 rootValue 来转换              return file.indexOf('vant') !== -1 ? 37.5 : 75            &#125;,            // 例如 * 就是所有属性都要转换， width 就是仅转换 width 属性            propList: ['*']          &#125;),        ]      &#125;    &#125;  &#125;,&#125;</code></pre><ol start="3"><li>配置完毕，重新启动服务<br>最后测试：刷新浏览器页面，审查元素的样式查看是否已将 px 转换为 rem 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown模板</title>
      <link href="/2021/11/15/%E5%85%B6%E5%AE%83/Markdown%E6%A8%A1%E6%9D%BF/"/>
      <url>/2021/11/15/%E5%85%B6%E5%AE%83/Markdown%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>size调整大小;color调整颜色<br><font size="5" color="red">简介:</font></p><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><p><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>用三个以上的星号、来建立一个分隔线，行内不能有其他东西;可以在星号或是减号中间插入空格。   </p><hr><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>&nbsp;&nbsp;</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h2 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h2><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>使用两个以上空格加上回车 或 在段落之间隔开一个空行</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块引用在段落开头使用(&gt;)符号，后面紧跟一个空格符号：</p><blockquote><p>区块引用</p></blockquote><h3 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h3><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h2><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序1<ul><li>无序1-1</li><li>无序1-2</li></ul></li><li>无序2<ul><li>无序2-1</li><li>无序2-2</li></ul></li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>1<ol><li>1-1</li><li>2-1 </li></ol></li><li>2<ol><li>2-1</li><li>2-2</li></ol></li></ol><h2 id="有序列表与无序列表穿插使用"><a href="#有序列表与无序列表穿插使用" class="headerlink" title="有序列表与无序列表穿插使用"></a>有序列表与无序列表穿插使用</h2><ol><li>1:<ul><li>1-1</li><li>1-2</li></ul></li><li>2<ul><li>2-1</li><li>2-2</li></ul></li></ol><h2 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h2><p>在列表内放进区块,需要在(&gt;)前添加四个空格的缩进</p><ul><li>第一项<blockquote><p>第一项第一个<br>第一项第二个</p></blockquote></li></ul><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><pre class=" language-JavaScript"><code class="language-JavaScript">123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2021/11/15/%E5%85%B6%E5%AE%83/Markdown/"/>
      <url>/2021/11/15/%E5%85%B6%E5%AE%83/Markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Markdown 是轻量级标记语言，它允许使用易读易写的纯文本格式编写文档<br>Markdown 可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档<br>Markdown 编写的文档后缀为 .md 或 .markdown<br><a href="https://markdown.com.cn/">Markdown官网</a></p><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一级标题</span><span class="token comment" spellcheck="true">## 二级标题</span><span class="token comment" spellcheck="true">### 三级标题</span><span class="token comment" spellcheck="true">#### 四级标题</span><span class="token comment" spellcheck="true">##### 五级标题</span><span class="token comment" spellcheck="true">###### 六级标题</span></code></pre><h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>Markdown 段落没有格式，直接编写文字就好<br><strong>段落的换行:</strong><br><strong>使用两个以上空格加上回车 或 在段落之间隔开一个空行</strong></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre class=" language-bash"><code class="language-bash">*斜体文本*  **粗体文本**  ***粗斜体文本***</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'red'</span><span class="token operator">></span>字体颜色<span class="token operator">&lt;</span>/font<span class="token operator">></span><span class="token operator">&lt;</span>font size<span class="token operator">=</span><span class="token string">'2px'</span><span class="token operator">></span>字体大小<span class="token operator">&lt;</span>/font<span class="token operator">></span></code></pre><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>用三个以上的星号、来建立一个分隔线，行内不能有其他东西;可以在星号或是减号中间插入空格。<br>下面每种写法都可以建立分隔线：</p><pre class=" language-bash"><code class="language-bash">**** * *</code></pre><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>在文字的两端加上两个波浪线~~</p><pre class=" language-bash"><code class="language-bash">~~123456~~</code></pre><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线通过&lt;u&gt;标签来实现：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>u<span class="token operator">></span>带下划线文本<span class="token operator">&lt;</span>/u<span class="token operator">></span></code></pre><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。Markdown 脚注的格式如下:</p><pre class=" language-bash"><code class="language-bash">创建脚注格式类似这样 <span class="token punctuation">[</span>^RUNOOB<span class="token punctuation">]</span>。<span class="token punctuation">[</span>^RUNOOB<span class="token punctuation">]</span>: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。<br>无序列表使用星号*作为列表标记，标记后要添加一个空格，再填写内容：</p><pre class=" language-bash"><code class="language-bash">* 无序列表</code></pre><p>有序列表使用数字并加上 . 号来表示，如：</p><pre class=" language-bash"><code class="language-bash">1. 有序列表12. 有序列表23. 有序列表3</code></pre><h3 id="Markdown-列表嵌套"><a href="#Markdown-列表嵌套" class="headerlink" title="Markdown 列表嵌套"></a>Markdown 列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre class=" language-bash"><code class="language-bash">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><p>区块引用在段落开头使用(&gt;)符号，后面紧跟一个空格符号：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 区块引用</code></pre><h3 id="区块是可以嵌套的"><a href="#区块是可以嵌套的" class="headerlink" title="区块是可以嵌套的"></a>区块是可以嵌套的</h3><p>一个&gt;符号是最外层，两个&gt;符号是第一层嵌套，以此类推：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 最外层<span class="token operator">></span> <span class="token operator">></span> 第一层嵌套<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span> 第二层嵌套</code></pre><p>区块中使用列表 实例如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 区块中使用列表<span class="token operator">></span> 1. 第一项<span class="token operator">></span> 2. 第二项<span class="token operator">></span> + 第一项<span class="token operator">></span> + 第二项<span class="token operator">></span> + 第三项</code></pre><p>列表中使用区块<br><strong>在列表内放进区块,需要在(&gt;)前添加四个空格的缩进</strong>;实例如下：</p><pre class=" language-bash"><code class="language-bash">* 第一项    <span class="token operator">></span> 第一项第一个    <span class="token operator">></span> 第一项第二个* 第二项</code></pre><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p><strong>段落上片段的代码用反引号把它包起来 ` `</strong>   例如：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>printf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token variable">`</span></span> </code></pre><p><strong>代码区块</strong> 使用 4 个空格或者一个制表符（Tab 键）。<br>实例如下</p><pre class=" language-bash"><code class="language-bash">    var a <span class="token operator">=</span> b    var b <span class="token operator">=</span> a</code></pre><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用方法如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>链接名称<span class="token punctuation">]</span><span class="token punctuation">(</span>链接地址<span class="token punctuation">)</span></code></pre><p>或者</p><p>直接使用链接地址：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>https://www.runoob.com<span class="token operator">></span></code></pre><p>高级链接<br><strong>通过变量来设置一个链接，变量赋值在文档末尾进行</strong>：</p><pre class=" language-bash"><code class="language-bash">这个链接用 google 作为网址变量<span class="token punctuation">[</span>Google<span class="token punctuation">]</span><span class="token punctuation">[</span>google<span class="token punctuation">]</span>这个链接用 runoob 作为网址变量 <span class="token punctuation">[</span>Runoob<span class="token punctuation">]</span><span class="token punctuation">[</span>runoob<span class="token punctuation">]</span>在文档的结尾为变量赋值:<span class="token operator">&lt;</span><span class="token operator">!</span>-- 赋值操作 --<span class="token operator">></span><span class="token punctuation">[</span>google<span class="token punctuation">]</span>: http://www.google.com/<span class="token punctuation">[</span>runoob<span class="token punctuation">]</span>: http://www.runoob.com/</code></pre><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p>Markdown 图片语法格式如下：<br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，<br>最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>alt 属性文本<span class="token punctuation">]</span><span class="token punctuation">(</span>图片地址<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">[</span>alt 属性文本<span class="token punctuation">]</span><span class="token punctuation">(</span>图片地址 <span class="token string">"可选标题"</span><span class="token punctuation">)</span></code></pre><p><strong>图片网址使用变量</strong>:  </p><pre class=" language-bash"><code class="language-bash">这个链接用 demo 作为网址变量 <span class="token punctuation">[</span>RUNOOB<span class="token punctuation">]</span><span class="token punctuation">[</span>demo<span class="token punctuation">]</span>.然后在文档的结尾为变量赋值<span class="token punctuation">[</span>demo<span class="token punctuation">]</span>: http://static.runoob.com/images/runoob-logo.png</code></pre><p>Markdown 没有办法指定图片的高度与宽度，如果需要可以使用普通的 &lt;img&gt; 标签。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"http://static.runoob.com/images/runoob-logo.png"</span> width<span class="token operator">=</span><span class="token string">"50%"</span><span class="token operator">></span></code></pre><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">|</span>  表头   <span class="token operator">|</span> 表头  <span class="token operator">|</span><span class="token operator">|</span>  ----  <span class="token operator">|</span> ----  <span class="token operator">|</span><span class="token operator">|</span> 单元格  <span class="token operator">|</span> 单元格 <span class="token operator">|</span><span class="token operator">|</span> 单元格  <span class="token operator">|</span> 单元格 <span class="token operator">|</span></code></pre><p>对齐方式</p><pre class=" language-bash"><code class="language-bash">-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><h2 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>kbd<span class="token operator">></span>Ctrl<span class="token operator">&lt;</span>/kbd<span class="token operator">></span>+<span class="token operator">&lt;</span>kbd<span class="token operator">></span>Alt<span class="token operator">&lt;</span>/kbd<span class="token operator">></span>+<span class="token operator">&lt;</span>kbd<span class="token operator">></span>Del<span class="token operator">&lt;</span>/kbd<span class="token operator">></span> 重启电脑</code></pre><h2 id="Markdown-转义"><a href="#Markdown-转义" class="headerlink" title="Markdown 转义"></a>Markdown 转义</h2><p>如果需要显示特定的符号则需要使用转义字符，使用反斜杠转义特殊字符 \ ：</p><pre class=" language-bash"><code class="language-bash">**文本加粗** \*\* 正常显示星号 \*\*</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
